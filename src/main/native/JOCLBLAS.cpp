/*
* JOCLBLAS - Java bindings for clBLAS
*
* Copyright (c) 2015-2016 Marco Hutter - http://www.jocl.org
*
* Permission is hereby granted, free of charge, to any person
* obtaining a copy of this software and associated documentation
* files (the "Software"), to deal in the Software without
* restriction, including without limitation the rights to use,
* copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the
* Software is furnished to do so, subject to the following
* conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
* OTHER DEALINGS IN THE SOFTWARE.
*/

#include "JOCLBLAS.hpp"

#define JOCL_BLAS_STATUS_INTERNAL_ERROR -16384;

#include <string.h>
#include <string>
#include <map>

#include "Logger.hpp"
#include "JOCLCommon.hpp"
#include "JNIUtils.hpp"
#include "PointerUtils.hpp"
#include "CLJNIUtils.hpp"
#include "ConversionsCL.hpp"
#include <clBLAS.h>


/**
* Called when the library is loaded. Will initialize all
* required global class references, field and method IDs
*/
JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM *jvm, void *reserved)
{
    JNIEnv *env = NULL;
    if (jvm->GetEnv((void**)&env, JNI_VERSION_1_4))
    {
        return JNI_ERR;
    }

    Logger::log(LOG_TRACE, "Initializing JOCLBLAS\n");

    // Initialize the utility methods
    if (initJNIUtils(env) == JNI_ERR) return JNI_ERR;
    if (initCLJNIUtils(env) == JNI_ERR) return JNI_ERR;
    if (initPointerUtils(env) == JNI_ERR) return JNI_ERR;

    // Obtain the global class references and the constructor methodIDs
    // for classes which will have to be instantiated
    if (!init(env, "org/jocl/cl_mem", cl_mem_Class, cl_mem_Constructor)) return JNI_ERR;

    return JNI_VERSION_1_4;
}

/**
* Called when the library is unloaded.
*/
JNIEXPORT void JNICALL JNI_OnUnload(JavaVM *vm, void *reserved)
{
    // Nothing to do here
}




/**
* Get the clblas library version info..
*
* @param major (out)        Location to store library's major version.
* @param minor (out)        Location to store library's minor version.
* @param patch (out)        Location to store library's patch version.
*
* @return always  clblasSuccess.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasGetVersionNative(JNIEnv *env, jclass cls, jintArray major, jintArray minor, jintArray patch)
{
    // Null-checks for non-primitive arguments
    if (major == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'major' is null for clblasGetVersion");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (minor == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'minor' is null for clblasGetVersion");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (patch == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'patch' is null for clblasGetVersion");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasGetVersion(major=%p, minor=%p, patch=%p)\n",
        major, minor, patch);

    // Native variable declarations
    cl_uint * major_native = nullptr;
    cl_uint * minor_native = nullptr;
    cl_uint * patch_native = nullptr;

    // Obtain native variable values
    if (!initNative(env, major, major_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, minor, minor_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, patch, patch_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasGetVersion(major_native, minor_native, patch_native);

    // Write back native variable values
    if (!releaseNative(env, major_native, major, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, minor_native, minor, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, patch_native, patch, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Initialize the clblas library..
*
* Must be called before any other clblas API function is invoked.
* This function is not thread-safe.
*
* @return
*   -  clblasSucces on success;
*   -  clblasOutOfHostMemory if there is not enough of memory to allocate
*     library's internal structures;
*   -  clblasOutOfResources in case of requested resources scarcity.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasSetupNative(JNIEnv *env, jclass cls)
{
    // Log message
    Logger::log(LOG_TRACE, "Executing clblasSetup()\n");

    // Native function call
    clblasStatus jniResult_native = clblasSetup();

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Finalize the usage of the clblas library..
*
* Frees all memory allocated for different computational kernel and other
* internal data.
* This function is not thread-safe.
*
*/
JNIEXPORT void JNICALL Java_org_jocl_blas_CLBLAS_clblasTeardownNative(JNIEnv *env, jclass cls)
{
    // Log message
    Logger::log(LOG_TRACE, "Executing clblasTeardown()\n");

    // Native function call
    clblasTeardown();

}

/**
* interchanges two vectors of float..
*
*
* @param N (in)         Number of elements in vector  X.
* @param X (out)        Buffer object storing vector  X.
* @param offx (in)      Offset of first element of vector  X in buffer object.
*                      Counted in elements.
* @param incx (in)      Increment for the elements of  X. Must not be zero.
* @param Y (out)        Buffer object storing the vector  Y.
* @param offy (in)      Offset of first element of vector  Y in buffer object.
*                      Counted in elements.
* @param incy (in)      Increment for the elements of  Y. Must not be zero.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasNotInitialized if clblasSetup() was not called;
*   -  clblasInvalidValue if invalid parameters are passed:
*     -  N is zero, or
*     - either  incx or  incy is zero, or
*     - the vector sizes along with the increments lead to
*       accessing outside of any of the buffers;
*   -  clblasInvalidMemObject if either  X, or  Y object is
*     Invalid, or an image object rather than the buffer one;
*   -  clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   -  clblasInvalidCommandQueue if the passed command queue is invalid;
*   -  clblasInvalidContext if a context a passed command queue belongs
*     to was released;
*   -  clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   -  clblasCompilerNotAvailable if a compiler is not available;
*   -  clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasSswapNative(JNIEnv *env, jclass cls, jlong N, jobject X, jlong offx, jint incx, jobject Y, jlong offy, jint incy, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasSswap");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (Y == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasSswap");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasSswap");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasSswap(N=%ld, X=%p, offx=%ld, incx=%d, Y=%p, offy=%ld, incy=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, X, offx, incx, Y, offy, incy, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    N_native = (size_t)N;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasSswap(N_native, X_native, offx_native, incx_native, Y_native, offy_native, incy_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* @example example_sswap.c
* Example of how to use the @ref clblasSswap function.
*/
/**
* interchanges two vectors of double..
*
*
* @param N (in)         Number of elements in vector  X.
* @param X (out)        Buffer object storing vector  X.
* @param offx (in)      Offset of first element of vector  X in buffer object.
*                      Counted in elements.
* @param incx (in)      Increment for the elements of  X. Must not be zero.
* @param Y (out)        Buffer object storing the vector  Y.
* @param offy (in)      Offset of first element of vector  Y in buffer object.
*                      Counted in elements.
* @param incy (in)      Increment for the elements of  Y. Must not be zero.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasInvalidDevice if a target device does not support the
*     floating point arithmetic with double precision;
*   - the same error codes as the clblasSswap() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasDswapNative(JNIEnv *env, jclass cls, jlong N, jobject X, jlong offx, jint incx, jobject Y, jlong offy, jint incy, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasDswap");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (Y == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasDswap");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasDswap");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasDswap(N=%ld, X=%p, offx=%ld, incx=%d, Y=%p, offy=%ld, incy=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, X, offx, incx, Y, offy, incy, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    N_native = (size_t)N;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasDswap(N_native, X_native, offx_native, incx_native, Y_native, offy_native, incy_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* interchanges two vectors of complex-float elements..
*
*
* @param N (in)         Number of elements in vector  X.
* @param X (out)        Buffer object storing vector  X.
* @param offx (in)      Offset of first element of vector  X in buffer object.
*                      Counted in elements.
* @param incx (in)      Increment for the elements of  X. Must not be zero.
* @param Y (out)        Buffer object storing the vector  Y.
* @param offy (in)      Offset of first element of vector  Y in buffer object.
*                      Counted in elements.
* @param incy (in)      Increment for the elements of  Y. Must not be zero.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   - the same error codes as the clblasSwap() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasCswapNative(JNIEnv *env, jclass cls, jlong N, jobject X, jlong offx, jint incx, jobject Y, jlong offy, jint incy, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasCswap");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (Y == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasCswap");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasCswap");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasCswap(N=%ld, X=%p, offx=%ld, incx=%d, Y=%p, offy=%ld, incy=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, X, offx, incx, Y, offy, incy, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    N_native = (size_t)N;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasCswap(N_native, X_native, offx_native, incx_native, Y_native, offy_native, incy_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* interchanges two vectors of double-complex elements..
*
*
* @param N (in)         Number of elements in vector  X.
* @param X (out)        Buffer object storing vector  X.
* @param offx (in)      Offset of first element of vector  X in buffer object.
*                      Counted in elements.
* @param incx (in)      Increment for the elements of  X. Must not be zero.
* @param Y (out)        Buffer object storing the vector  Y.
* @param offy (in)      Offset of first element of vector  Y in buffer object.
*                      Counted in elements.
* @param incy (in)      Increment for the elements of  Y. Must not be zero.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   - the same error codes as the clblasDwap() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasZswapNative(JNIEnv *env, jclass cls, jlong N, jobject X, jlong offx, jint incx, jobject Y, jlong offy, jint incy, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasZswap");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (Y == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasZswap");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasZswap");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasZswap(N=%ld, X=%p, offx=%ld, incx=%d, Y=%p, offy=%ld, incy=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, X, offx, incx, Y, offy, incy, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    N_native = (size_t)N;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasZswap(N_native, X_native, offx_native, incx_native, Y_native, offy_native, incy_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Scales a float vector by a float constant.
*
*   - \f$ X \leftarrow \alpha X \f$
*
* @param N (in)         Number of elements in vector  X.
* @param alpha (in)     The constant factor for vector  X.
* @param X (out)        Buffer object storing vector  X.
* @param offx (in)      Offset of first element of vector  X in buffer object.
*                      Counted in elements.
* @param incx (in)      Increment for the elements of  X. Must not be zero.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasNotInitialized if clblasSetup() was not called;
*   -  clblasInvalidValue if invalid parameters are passed:
*     -  N is zero, or
*     -  incx zero, or
*     - the vector sizes along with the increments lead to
*       accessing outside of any of the buffers;
*   -  clblasInvalidMemObject if either  X, or  Y object is
*     Invalid, or an image object rather than the buffer one;
*   -  clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   -  clblasInvalidCommandQueue if the passed command queue is invalid;
*   -  clblasInvalidContext if a context a passed command queue belongs
*     to was released;
*   -  clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   -  clblasCompilerNotAvailable if a compiler is not available;
*   -  clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasSscalNative(JNIEnv *env, jclass cls, jlong N, jfloat alpha, jobject X, jlong offx, jint incx, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    // alpha is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasSscal");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasSscal");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasSscal(N=%ld, alpha=%f, X=%p, offx=%ld, incx=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, alpha, X, offx, incx, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_float alpha_native = 0.0f;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    N_native = (size_t)N;
    alpha_native = (cl_float)alpha;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasSscal(N_native, alpha_native, X_native, offx_native, incx_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    // alpha is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* @example example_sscal.c
* Example of how to use the @ref clblasSscal function.
*/
/**
* Scales a double vector by a double constant.
*
*   - \f$ X \leftarrow \alpha X \f$
*
* @param N (in)         Number of elements in vector  X.
* @param alpha (in)     The constant factor for vector  X.
* @param X (out)        Buffer object storing vector  X.
* @param offx (in)      Offset of first element of vector  X in buffer object.
*                      Counted in elements.
* @param incx (in)      Increment for the elements of  X. Must not be zero.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasInvalidDevice if a target device does not support the
*     floating point arithmetic with double precision;
*   - the same error codes as the clblasSscal() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasDscalNative(JNIEnv *env, jclass cls, jlong N, jdouble alpha, jobject X, jlong offx, jint incx, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    // alpha is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasDscal");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasDscal");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasDscal(N=%ld, alpha=%lf, X=%p, offx=%ld, incx=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, alpha, X, offx, incx, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_double alpha_native = 0.0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    N_native = (size_t)N;
    alpha_native = (cl_double)alpha;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasDscal(N_native, alpha_native, X_native, offx_native, incx_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    // alpha is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Scales a complex-float vector by a complex-float constant.
*
*   - \f$ X \leftarrow \alpha X \f$
*
* @param N (in)         Number of elements in vector  X.
* @param alpha (in)     The constant factor for vector  X.
* @param X (out)        Buffer object storing vector  X.
* @param offx (in)      Offset of first element of vector  X in buffer object.
*                      Counted in elements.
* @param incx (in)      Increment for the elements of  X. Must not be zero.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   - the same error codes as the clblasSscal() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasCscalNative(JNIEnv *env, jclass cls, jlong N, jfloatArray alpha, jobject X, jlong offx, jint incx, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    if (alpha == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'alpha' is null for clblasCscal");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasCscal");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasCscal");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasCscal(N=%ld, alpha=%p, X=%p, offx=%ld, incx=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, alpha, X, offx, incx, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_float2 alpha_native;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    N_native = (size_t)N;
    if (!initNative(env, alpha, alpha_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasCscal(N_native, alpha_native, X_native, offx_native, incx_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    if (!releaseNative(env, alpha_native, alpha, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Scales a complex-double vector by a complex-double constant.
*
*   - \f$ X \leftarrow \alpha X \f$
*
* @param N (in)         Number of elements in vector  X.
* @param alpha (in)     The constant factor for vector  X.
* @param X (out)        Buffer object storing vector  X.
* @param offx (in)      Offset of first element of vector  X in buffer object.
*                      Counted in elements.
* @param incx (in)      Increment for the elements of  X. Must not be zero.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   - the same error codes as the clblasDscal() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasZscalNative(JNIEnv *env, jclass cls, jlong N, jdoubleArray alpha, jobject X, jlong offx, jint incx, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    if (alpha == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'alpha' is null for clblasZscal");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasZscal");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasZscal");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasZscal(N=%ld, alpha=%p, X=%p, offx=%ld, incx=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, alpha, X, offx, incx, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_double2 alpha_native;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    N_native = (size_t)N;
    if (!initNative(env, alpha, alpha_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasZscal(N_native, alpha_native, X_native, offx_native, incx_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    if (!releaseNative(env, alpha_native, alpha, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Scales a complex-float vector by a float constant.
*
*   - \f$ X \leftarrow \alpha X \f$
*
* @param N (in)         Number of elements in vector  X.
* @param alpha (in)     The constant factor for vector  X.
* @param X (out)        Buffer object storing vector  X.
* @param offx (in)      Offset of first element of vector  X in buffer object.
*                      Counted in elements.
* @param incx (in)      Increment for the elements of  X. Must not be zero.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasNotInitialized if clblasSetup() was not called;
*   -  clblasInvalidValue if invalid parameters are passed:
*     -  N is zero, or
*     -  incx zero, or
*     - the vector sizes along with the increments lead to
*       accessing outside of any of the buffers;
*   -  clblasInvalidMemObject if either  X, or  Y object is
*     Invalid, or an image object rather than the buffer one;
*   -  clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   -  clblasInvalidCommandQueue if the passed command queue is invalid;
*   -  clblasInvalidContext if a context a passed command queue belongs
*     to was released;
*   -  clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   -  clblasCompilerNotAvailable if a compiler is not available;
*   -  clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasCsscalNative(JNIEnv *env, jclass cls, jlong N, jfloat alpha, jobject X, jlong offx, jint incx, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    // alpha is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasCsscal");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasCsscal");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasCsscal(N=%ld, alpha=%f, X=%p, offx=%ld, incx=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, alpha, X, offx, incx, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_float alpha_native = 0.0f;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    N_native = (size_t)N;
    alpha_native = (cl_float)alpha;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasCsscal(N_native, alpha_native, X_native, offx_native, incx_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    // alpha is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* @example example_csscal.c
* Example of how to use the @ref clblasCsscal function.
*/
/**
* Scales a complex-double vector by a double constant.
*
*   - \f$ X \leftarrow \alpha X \f$
*
* @param N (in)         Number of elements in vector  X.
* @param alpha (in)     The constant factor for vector  X.
* @param X (out)        Buffer object storing vector  X.
* @param offx (in)      Offset of first element of vector  X in buffer object.
*                      Counted in elements.
* @param incx (in)      Increment for the elements of  X. Must not be zero.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasInvalidDevice if a target device does not support the
*     floating point arithmetic with double precision;
*   - the same error codes as the clblasCsscal() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasZdscalNative(JNIEnv *env, jclass cls, jlong N, jdouble alpha, jobject X, jlong offx, jint incx, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    // alpha is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasZdscal");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasZdscal");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasZdscal(N=%ld, alpha=%lf, X=%p, offx=%ld, incx=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, alpha, X, offx, incx, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_double alpha_native = 0.0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    N_native = (size_t)N;
    alpha_native = (cl_double)alpha;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasZdscal(N_native, alpha_native, X_native, offx_native, incx_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    // alpha is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Copies float elements from vector X to vector Y.
*
*   - \f$ Y \leftarrow X \f$
*
* @param N (in)         Number of elements in vector  X.
* @param X (in)         Buffer object storing vector  X.
* @param offx (in)      Offset of first element of vector  X in buffer object.
*                      Counted in elements.
* @param incx (in)      Increment for the elements of  X. Must not be zero.
* @param Y (out)        Buffer object storing the vector  Y.
* @param offy (in)      Offset of first element of vector  Y in buffer object.
*                      Counted in elements.
* @param incy (in)      Increment for the elements of  Y. Must not be zero.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasNotInitialized if clblasSetup() was not called;
*   -  clblasInvalidValue if invalid parameters are passed:
*     -  N is zero, or
*     - either  incx or  incy is zero, or
*     - the vector sizes along with the increments lead to
*       accessing outside of any of the buffers;
*   -  clblasInvalidMemObject if either  X, or  Y object is
*     Invalid, or an image object rather than the buffer one;
*   -  clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   -  clblasInvalidCommandQueue if the passed command queue is invalid;
*   -  clblasInvalidContext if a context a passed command queue belongs
*     to was released;
*   -  clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   -  clblasCompilerNotAvailable if a compiler is not available;
*   -  clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasScopyNative(JNIEnv *env, jclass cls, jlong N, jobject X, jlong offx, jint incx, jobject Y, jlong offy, jint incy, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasScopy");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (Y == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasScopy");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasScopy");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasScopy(N=%ld, X=%p, offx=%ld, incx=%d, Y=%p, offy=%ld, incy=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, X, offx, incx, Y, offy, incy, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    N_native = (size_t)N;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasScopy(N_native, X_native, offx_native, incx_native, Y_native, offy_native, incy_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* @example example_scopy.c
* Example of how to use the @ref clblasScopy function.
*/
/**
* Copies double elements from vector X to vector Y.
*
*   - \f$ Y \leftarrow X \f$
*
* @param N (in)         Number of elements in vector  X.
* @param X (in)         Buffer object storing vector  X.
* @param offx (in)      Offset of first element of vector  X in buffer object.
*                      Counted in elements.
* @param incx (in)      Increment for the elements of  X. Must not be zero.
* @param Y (out)        Buffer object storing the vector  Y.
* @param offy (in)      Offset of first element of vector  Y in buffer object.
*                      Counted in elements.
* @param incy (in)      Increment for the elements of  Y. Must not be zero.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasInvalidDevice if a target device does not support the
*     floating point arithmetic with double precision;
*   - the same error codes as the clblasScopy() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasDcopyNative(JNIEnv *env, jclass cls, jlong N, jobject X, jlong offx, jint incx, jobject Y, jlong offy, jint incy, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasDcopy");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (Y == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasDcopy");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasDcopy");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasDcopy(N=%ld, X=%p, offx=%ld, incx=%d, Y=%p, offy=%ld, incy=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, X, offx, incx, Y, offy, incy, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    N_native = (size_t)N;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasDcopy(N_native, X_native, offx_native, incx_native, Y_native, offy_native, incy_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Copies complex-float elements from vector X to vector Y.
*
*   - \f$ Y \leftarrow X \f$
*
* @param N (in)         Number of elements in vector  X.
* @param X (in)         Buffer object storing vector  X.
* @param offx (in)      Offset of first element of vector  X in buffer object.
*                      Counted in elements.
* @param incx (in)      Increment for the elements of  X. Must not be zero.
* @param Y (out)        Buffer object storing the vector  Y.
* @param offy (in)      Offset of first element of vector  Y in buffer object.
*                      Counted in elements.
* @param incy (in)      Increment for the elements of  Y. Must not be zero.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   - the same error codes as the clblasScopy() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasCcopyNative(JNIEnv *env, jclass cls, jlong N, jobject X, jlong offx, jint incx, jobject Y, jlong offy, jint incy, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasCcopy");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (Y == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasCcopy");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasCcopy");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasCcopy(N=%ld, X=%p, offx=%ld, incx=%d, Y=%p, offy=%ld, incy=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, X, offx, incx, Y, offy, incy, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    N_native = (size_t)N;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasCcopy(N_native, X_native, offx_native, incx_native, Y_native, offy_native, incy_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Copies complex-double elements from vector X to vector Y.
*
*   - \f$ Y \leftarrow X \f$
*
* @param N (in)         Number of elements in vector  X.
* @param X (in)         Buffer object storing vector  X.
* @param offx (in)      Offset of first element of vector  X in buffer object.
*                      Counted in elements.
* @param incx (in)      Increment for the elements of  X. Must not be zero.
* @param Y (out)        Buffer object storing the vector  Y.
* @param offy (in)      Offset of first element of vector  Y in buffer object.
*                      Counted in elements.
* @param incy (in)      Increment for the elements of  Y. Must not be zero.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   - the same error codes as the clblasDcopy() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasZcopyNative(JNIEnv *env, jclass cls, jlong N, jobject X, jlong offx, jint incx, jobject Y, jlong offy, jint incy, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasZcopy");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (Y == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasZcopy");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasZcopy");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasZcopy(N=%ld, X=%p, offx=%ld, incx=%d, Y=%p, offy=%ld, incy=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, X, offx, incx, Y, offy, incy, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    N_native = (size_t)N;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasZcopy(N_native, X_native, offx_native, incx_native, Y_native, offy_native, incy_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Scale vector X of float elements and add to Y.
*
*   - \f$ Y \leftarrow \alpha X + Y \f$
*
* @param N (in)         Number of elements in vector  X.
* @param alpha (in)     The constant factor for vector  X.
* @param X (in)         Buffer object storing vector  X.
* @param offx (in)      Offset of first element of vector  X in buffer object.
*                      Counted in elements.
* @param incx (in)      Increment for the elements of  X. Must not be zero.
* @param Y (out)        Buffer object storing the vector  Y.
* @param offy (in)      Offset of first element of vector  Y in buffer object.
*                      Counted in elements.
* @param incy (in)      Increment for the elements of  Y. Must not be zero.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasNotInitialized if clblasSetup() was not called;
*   -  clblasInvalidValue if invalid parameters are passed:
*     -  N is zero, or
*     - either  incx or  incy is zero, or
*     - the vector sizes along with the increments lead to
*       accessing outside of any of the buffers;
*   -  clblasInvalidMemObject if either  X, or  Y object is
*     Invalid, or an image object rather than the buffer one;
*   -  clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   -  clblasInvalidCommandQueue if the passed command queue is invalid;
*   -  clblasInvalidContext if a context a passed command queue belongs
*     to was released;
*   -  clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   -  clblasCompilerNotAvailable if a compiler is not available;
*   -  clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasSaxpyNative(JNIEnv *env, jclass cls, jlong N, jfloat alpha, jobject X, jlong offx, jint incx, jobject Y, jlong offy, jint incy, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    // alpha is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasSaxpy");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (Y == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasSaxpy");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasSaxpy");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasSaxpy(N=%ld, alpha=%f, X=%p, offx=%ld, incx=%d, Y=%p, offy=%ld, incy=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, alpha, X, offx, incx, Y, offy, incy, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_float alpha_native = 0.0f;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    N_native = (size_t)N;
    alpha_native = (cl_float)alpha;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasSaxpy(N_native, alpha_native, X_native, offx_native, incx_native, Y_native, offy_native, incy_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    // alpha is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* @example example_saxpy.c
* Example of how to use the @ref clblasSaxpy function.
*/
/**
* Scale vector X of double elements and add to Y.
*
*   - \f$ Y \leftarrow \alpha X + Y \f$
*
* @param N (in)         Number of elements in vector  X.
* @param alpha (in)     The constant factor for vector  X.
* @param X (in)         Buffer object storing vector  X.
* @param offx (in)      Offset of first element of vector  X in buffer object.
*                      Counted in elements.
* @param incx (in)      Increment for the elements of  X. Must not be zero.
* @param Y (out)        Buffer object storing the vector  Y.
* @param offy (in)      Offset of first element of vector  Y in buffer object.
*                      Counted in elements.
* @param incy (in)      Increment for the elements of  Y. Must not be zero.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasInvalidDevice if a target device does not support the
*     floating point arithmetic with double precision;
*   - the same error codes as the clblasSaxpy() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasDaxpyNative(JNIEnv *env, jclass cls, jlong N, jdouble alpha, jobject X, jlong offx, jint incx, jobject Y, jlong offy, jint incy, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    // alpha is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasDaxpy");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (Y == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasDaxpy");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasDaxpy");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasDaxpy(N=%ld, alpha=%lf, X=%p, offx=%ld, incx=%d, Y=%p, offy=%ld, incy=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, alpha, X, offx, incx, Y, offy, incy, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_double alpha_native = 0.0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    N_native = (size_t)N;
    alpha_native = (cl_double)alpha;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasDaxpy(N_native, alpha_native, X_native, offx_native, incx_native, Y_native, offy_native, incy_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    // alpha is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Scale vector X of complex-float elements and add to Y.
*
*   - \f$ Y \leftarrow \alpha X + Y \f$
*
* @param N (in)         Number of elements in vector  X.
* @param alpha (in)     The constant factor for vector  X.
* @param X (in)         Buffer object storing vector  X.
* @param offx (in)      Offset of first element of vector  X in buffer object.
*                      Counted in elements.
* @param incx (in)      Increment for the elements of  X. Must not be zero.
* @param Y (out)        Buffer object storing the vector  Y.
* @param offy (in)      Offset of first element of vector  Y in buffer object.
*                      Counted in elements.
* @param incy (in)      Increment for the elements of  Y. Must not be zero.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   - the same error codes as the clblasSaxpy() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasCaxpyNative(JNIEnv *env, jclass cls, jlong N, jfloatArray alpha, jobject X, jlong offx, jint incx, jobject Y, jlong offy, jint incy, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    if (alpha == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'alpha' is null for clblasCaxpy");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasCaxpy");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (Y == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasCaxpy");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasCaxpy");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasCaxpy(N=%ld, alpha=%p, X=%p, offx=%ld, incx=%d, Y=%p, offy=%ld, incy=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, alpha, X, offx, incx, Y, offy, incy, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_float2 alpha_native;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    N_native = (size_t)N;
    if (!initNative(env, alpha, alpha_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasCaxpy(N_native, alpha_native, X_native, offx_native, incx_native, Y_native, offy_native, incy_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    if (!releaseNative(env, alpha_native, alpha, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Scale vector X of double-complex elements and add to Y.
*
*   - \f$ Y \leftarrow \alpha X + Y \f$
*
* @param N (in)         Number of elements in vector  X.
* @param alpha (in)     The constant factor for vector  X.
* @param X (in)         Buffer object storing vector  X.
* @param offx (in)      Offset of first element of vector  X in buffer object.
*                      Counted in elements.
* @param incx (in)      Increment for the elements of  X. Must not be zero.
* @param Y (out)        Buffer object storing the vector  Y.
* @param offy (in)      Offset of first element of vector  Y in buffer object.
*                      Counted in elements.
* @param incy (in)      Increment for the elements of  Y. Must not be zero.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   - the same error codes as the clblasDaxpy() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasZaxpyNative(JNIEnv *env, jclass cls, jlong N, jdoubleArray alpha, jobject X, jlong offx, jint incx, jobject Y, jlong offy, jint incy, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    if (alpha == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'alpha' is null for clblasZaxpy");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasZaxpy");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (Y == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasZaxpy");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasZaxpy");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasZaxpy(N=%ld, alpha=%p, X=%p, offx=%ld, incx=%d, Y=%p, offy=%ld, incy=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, alpha, X, offx, incx, Y, offy, incy, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_double2 alpha_native;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    N_native = (size_t)N;
    if (!initNative(env, alpha, alpha_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasZaxpy(N_native, alpha_native, X_native, offx_native, incx_native, Y_native, offy_native, incy_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    if (!releaseNative(env, alpha_native, alpha, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* dot product of two vectors containing float elements.
*
* @param N (in)             Number of elements in vector  X.
* @param dotProduct (out)   Buffer object that will contain the dot-product value
* @param offDP (in)         Offset to dot-product in  dotProduct buffer object.
*                          Counted in elements.
* @param X (in)             Buffer object storing vector  X.
* @param offx (in)          Offset of first element of vector  X in buffer object.
*                          Counted in elements.
* @param incx (in)          Increment for the elements of  X. Must not be zero.
* @param Y (in)             Buffer object storing the vector  Y.
* @param offy (in)          Offset of first element of vector  Y in buffer object.
*                          Counted in elements.
* @param incy (in)          Increment for the elements of  Y. Must not be zero.
* @param scratchBuff	Temporary (in) cl_mem scratch buffer object of minimum size N
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasNotInitialized if clblasSetup() was not called;
*   -  clblasInvalidValue if invalid parameters are passed:
*     -  N is zero, or
*     - either  incx or  incy is zero, or
*     - the vector sizes along with the increments lead to
*       accessing outside of any of the buffers;
*   -  clblasInvalidMemObject if either  X,  Y or  dotProduct object is
*     Invalid, or an image object rather than the buffer one;
*   -  clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   -  clblasInvalidCommandQueue if the passed command queue is invalid;
*   -  clblasInvalidContext if a context a passed command queue belongs
*     to was released;
*   -  clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   -  clblasCompilerNotAvailable if a compiler is not available;
*   -  clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasSdotNative(JNIEnv *env, jclass cls, jlong N, jobject dotProduct, jlong offDP, jobject X, jlong offx, jint incx, jobject Y, jlong offy, jint incy, jobject scratchBuff, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    if (dotProduct == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'dotProduct' is null for clblasSdot");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offDP is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasSdot");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (Y == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasSdot");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    if (scratchBuff == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'scratchBuff' is null for clblasSdot");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasSdot");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasSdot(N=%ld, dotProduct=%p, offDP=%ld, X=%p, offx=%ld, incx=%d, Y=%p, offy=%ld, incy=%d, scratchBuff=%p, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, dotProduct, offDP, X, offx, incx, Y, offy, incy, scratchBuff, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_mem dotProduct_native = nullptr;
    size_t offDP_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_mem scratchBuff_native = nullptr;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    N_native = (size_t)N;
    if (!initNative(env, dotProduct, dotProduct_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offDP_native = (size_t)offDP;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    if (!initNative(env, scratchBuff, scratchBuff_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasSdot(N_native, dotProduct_native, offDP_native, X_native, offx_native, incx_native, Y_native, offy_native, incy_native, scratchBuff_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    // dotProduct is a read-only native pointer
    // offDP is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // scratchBuff is a read-only native pointer
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* @example example_sdot.c
* Example of how to use the @ref clblasSdot function.
*/
/**
* dot product of two vectors containing double elements.
*
* @param N (in)             Number of elements in vector  X.
* @param dotProduct (out)   Buffer object that will contain the dot-product value
* @param offDP (in)         Offset to dot-product in  dotProduct buffer object.
*                          Counted in elements.
* @param X (in)             Buffer object storing vector  X.
* @param offx (in)          Offset of first element of vector  X in buffer object.
*                          Counted in elements.
* @param incx (in)          Increment for the elements of  X. Must not be zero.
* @param Y (in)             Buffer object storing the vector  Y.
* @param offy (in)          Offset of first element of vector  Y in buffer object.
*                          Counted in elements.
* @param incy (in)          Increment for the elements of  Y. Must not be zero.
* @param scratchBuff	Temporary (in) cl_mem scratch buffer object of minimum size N
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasInvalidDevice if a target device does not support the
*     floating point arithmetic with double precision;
*   - the same error codes as the clblasSdot() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasDdotNative(JNIEnv *env, jclass cls, jlong N, jobject dotProduct, jlong offDP, jobject X, jlong offx, jint incx, jobject Y, jlong offy, jint incy, jobject scratchBuff, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    if (dotProduct == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'dotProduct' is null for clblasDdot");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offDP is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasDdot");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (Y == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasDdot");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    if (scratchBuff == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'scratchBuff' is null for clblasDdot");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasDdot");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasDdot(N=%ld, dotProduct=%p, offDP=%ld, X=%p, offx=%ld, incx=%d, Y=%p, offy=%ld, incy=%d, scratchBuff=%p, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, dotProduct, offDP, X, offx, incx, Y, offy, incy, scratchBuff, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_mem dotProduct_native = nullptr;
    size_t offDP_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_mem scratchBuff_native = nullptr;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    N_native = (size_t)N;
    if (!initNative(env, dotProduct, dotProduct_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offDP_native = (size_t)offDP;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    if (!initNative(env, scratchBuff, scratchBuff_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasDdot(N_native, dotProduct_native, offDP_native, X_native, offx_native, incx_native, Y_native, offy_native, incy_native, scratchBuff_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    // dotProduct is a read-only native pointer
    // offDP is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // scratchBuff is a read-only native pointer
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* dot product of two vectors containing float-complex elements.
*
* @param N (in)             Number of elements in vector  X.
* @param dotProduct (out)   Buffer object that will contain the dot-product value
* @param offDP (in)         Offset to dot-product in  dotProduct buffer object.
*                          Counted in elements.
* @param X (in)             Buffer object storing vector  X.
* @param offx (in)          Offset of first element of vector  X in buffer object.
*                          Counted in elements.
* @param incx (in)          Increment for the elements of  X. Must not be zero.
* @param Y (in)             Buffer object storing the vector  Y.
* @param offy (in)          Offset of first element of vector  Y in buffer object.
*                          Counted in elements.
* @param incy (in)          Increment for the elements of  Y. Must not be zero.
* @param scratchBuff (in)   Temporary cl_mem scratch buffer object of minimum size N
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   - the same error codes as the clblasSdot() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasCdotuNative(JNIEnv *env, jclass cls, jlong N, jobject dotProduct, jlong offDP, jobject X, jlong offx, jint incx, jobject Y, jlong offy, jint incy, jobject scratchBuff, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    if (dotProduct == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'dotProduct' is null for clblasCdotu");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offDP is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasCdotu");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (Y == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasCdotu");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    if (scratchBuff == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'scratchBuff' is null for clblasCdotu");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasCdotu");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasCdotu(N=%ld, dotProduct=%p, offDP=%ld, X=%p, offx=%ld, incx=%d, Y=%p, offy=%ld, incy=%d, scratchBuff=%p, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, dotProduct, offDP, X, offx, incx, Y, offy, incy, scratchBuff, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_mem dotProduct_native = nullptr;
    size_t offDP_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_mem scratchBuff_native = nullptr;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    N_native = (size_t)N;
    if (!initNative(env, dotProduct, dotProduct_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offDP_native = (size_t)offDP;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    if (!initNative(env, scratchBuff, scratchBuff_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasCdotu(N_native, dotProduct_native, offDP_native, X_native, offx_native, incx_native, Y_native, offy_native, incy_native, scratchBuff_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    // dotProduct is a read-only native pointer
    // offDP is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // scratchBuff is a read-only native pointer
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* dot product of two vectors containing double-complex elements.
*
* @param N (in)             Number of elements in vector  X.
* @param dotProduct (out)   Buffer object that will contain the dot-product value
* @param offDP (in)         Offset to dot-product in  dotProduct buffer object.
*                          Counted in elements.
* @param X (in)             Buffer object storing vector  X.
* @param offx (in)          Offset of first element of vector  X in buffer object.
*                          Counted in elements.
* @param incx (in)          Increment for the elements of  X. Must not be zero.
* @param Y (in)             Buffer object storing the vector  Y.
* @param offy (in)          Offset of first element of vector  Y in buffer object.
*                          Counted in elements.
* @param incy (in)          Increment for the elements of  Y. Must not be zero.
* @param scratchBuff (in)   Temporary cl_mem scratch buffer object of minimum size N
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasInvalidDevice if a target device does not support the
*     floating point arithmetic with double precision;
*   - the same error codes as the clblasSdot() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasZdotuNative(JNIEnv *env, jclass cls, jlong N, jobject dotProduct, jlong offDP, jobject X, jlong offx, jint incx, jobject Y, jlong offy, jint incy, jobject scratchBuff, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    if (dotProduct == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'dotProduct' is null for clblasZdotu");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offDP is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasZdotu");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (Y == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasZdotu");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    if (scratchBuff == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'scratchBuff' is null for clblasZdotu");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasZdotu");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasZdotu(N=%ld, dotProduct=%p, offDP=%ld, X=%p, offx=%ld, incx=%d, Y=%p, offy=%ld, incy=%d, scratchBuff=%p, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, dotProduct, offDP, X, offx, incx, Y, offy, incy, scratchBuff, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_mem dotProduct_native = nullptr;
    size_t offDP_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_mem scratchBuff_native = nullptr;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    N_native = (size_t)N;
    if (!initNative(env, dotProduct, dotProduct_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offDP_native = (size_t)offDP;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    if (!initNative(env, scratchBuff, scratchBuff_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasZdotu(N_native, dotProduct_native, offDP_native, X_native, offx_native, incx_native, Y_native, offy_native, incy_native, scratchBuff_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    // dotProduct is a read-only native pointer
    // offDP is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // scratchBuff is a read-only native pointer
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* dot product of two vectors containing float-complex elements conjugating the first vector.
*
* @param N (in)             Number of elements in vector  X.
* @param dotProduct (out)   Buffer object that will contain the dot-product value
* @param offDP (in)         Offset to dot-product in  dotProduct buffer object.
*                          Counted in elements.
* @param X (in)             Buffer object storing vector  X.
* @param offx (in)          Offset of first element of vector  X in buffer object.
*                          Counted in elements.
* @param incx (in)          Increment for the elements of  X. Must not be zero.
* @param Y (in)             Buffer object storing the vector  Y.
* @param offy (in)          Offset of first element of vector  Y in buffer object.
*                          Counted in elements.
* @param incy (in)          Increment for the elements of  Y. Must not be zero.
* @param scratchBuff (in)   Temporary cl_mem scratch buffer object of minimum size N
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   - the same error codes as the clblasSdot() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasCdotcNative(JNIEnv *env, jclass cls, jlong N, jobject dotProduct, jlong offDP, jobject X, jlong offx, jint incx, jobject Y, jlong offy, jint incy, jobject scratchBuff, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    if (dotProduct == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'dotProduct' is null for clblasCdotc");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offDP is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasCdotc");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (Y == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasCdotc");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    if (scratchBuff == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'scratchBuff' is null for clblasCdotc");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasCdotc");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasCdotc(N=%ld, dotProduct=%p, offDP=%ld, X=%p, offx=%ld, incx=%d, Y=%p, offy=%ld, incy=%d, scratchBuff=%p, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, dotProduct, offDP, X, offx, incx, Y, offy, incy, scratchBuff, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_mem dotProduct_native = nullptr;
    size_t offDP_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_mem scratchBuff_native = nullptr;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    N_native = (size_t)N;
    if (!initNative(env, dotProduct, dotProduct_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offDP_native = (size_t)offDP;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    if (!initNative(env, scratchBuff, scratchBuff_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasCdotc(N_native, dotProduct_native, offDP_native, X_native, offx_native, incx_native, Y_native, offy_native, incy_native, scratchBuff_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    // dotProduct is a read-only native pointer
    // offDP is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // scratchBuff is a read-only native pointer
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* dot product of two vectors containing double-complex elements conjugating the first vector.
*
* @param N (in)             Number of elements in vector  X.
* @param dotProduct (out)   Buffer object that will contain the dot-product value
* @param offDP (in)         Offset to dot-product in  dotProduct buffer object.
*                          Counted in elements.
* @param X (in)             Buffer object storing vector  X.
* @param offx (in)          Offset of first element of vector  X in buffer object.
*                          Counted in elements.
* @param incx (in)          Increment for the elements of  X. Must not be zero.
* @param Y (in)             Buffer object storing the vector  Y.
* @param offy (in)          Offset of first element of vector  Y in buffer object.
*                          Counted in elements.
* @param incy (in)          Increment for the elements of  Y. Must not be zero.
* @param scratchBuff (in)   Temporary cl_mem scratch buffer object of minimum size N
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasInvalidDevice if a target device does not support the
*     floating point arithmetic with double precision;
*   - the same error codes as the clblasSdot() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasZdotcNative(JNIEnv *env, jclass cls, jlong N, jobject dotProduct, jlong offDP, jobject X, jlong offx, jint incx, jobject Y, jlong offy, jint incy, jobject scratchBuff, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    if (dotProduct == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'dotProduct' is null for clblasZdotc");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offDP is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasZdotc");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (Y == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasZdotc");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    if (scratchBuff == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'scratchBuff' is null for clblasZdotc");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasZdotc");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasZdotc(N=%ld, dotProduct=%p, offDP=%ld, X=%p, offx=%ld, incx=%d, Y=%p, offy=%ld, incy=%d, scratchBuff=%p, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, dotProduct, offDP, X, offx, incx, Y, offy, incy, scratchBuff, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_mem dotProduct_native = nullptr;
    size_t offDP_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_mem scratchBuff_native = nullptr;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    N_native = (size_t)N;
    if (!initNative(env, dotProduct, dotProduct_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offDP_native = (size_t)offDP;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    if (!initNative(env, scratchBuff, scratchBuff_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasZdotc(N_native, dotProduct_native, offDP_native, X_native, offx_native, incx_native, Y_native, offy_native, incy_native, scratchBuff_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    // dotProduct is a read-only native pointer
    // offDP is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // scratchBuff is a read-only native pointer
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* construct givens plane rotation on float elements.
*
* @param SA (out)           Buffer object that contains SA
* @param offSA (in)         Offset to SA in  SA buffer object.
*                          Counted in elements.
* @param SB (out)           Buffer object that contains SB
* @param offSB (in)         Offset to SB in  SB buffer object.
*                          Counted in elements.
* @param C (out)            Buffer object that contains C
* @param offC (in)          Offset to C in  C buffer object.
*                          Counted in elements.
* @param S (out)            Buffer object that contains S
* @param offS (in)          Offset to S in  S buffer object.
*                          Counted in elements.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasNotInitialized if clblasSetup() was not called;
*   -  clblasInvalidMemObject if either  SA,  SB,  C or  S object is
*     Invalid, or an image object rather than the buffer one;
*   -  clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   -  clblasInvalidCommandQueue if the passed command queue is invalid;
*   -  clblasInvalidContext if a context a passed command queue belongs
*     to was released;
*   -  clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   -  clblasCompilerNotAvailable if a compiler is not available;
*   -  clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasSrotgNative(JNIEnv *env, jclass cls, jobject SA, jlong offSA, jobject SB, jlong offSB, jobject C, jlong offC, jobject S, jlong offS, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    if (SA == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'SA' is null for clblasSrotg");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offSA is primitive
    if (SB == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'SB' is null for clblasSrotg");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offSB is primitive
    if (C == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'C' is null for clblasSrotg");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offC is primitive
    if (S == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'S' is null for clblasSrotg");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offS is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasSrotg");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasSrotg(SA=%p, offSA=%ld, SB=%p, offSB=%ld, C=%p, offC=%ld, S=%p, offS=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        SA, offSA, SB, offSB, C, offC, S, offS, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    cl_mem SA_native = nullptr;
    size_t offSA_native = 0;
    cl_mem SB_native = nullptr;
    size_t offSB_native = 0;
    cl_mem C_native = nullptr;
    size_t offC_native = 0;
    cl_mem S_native = nullptr;
    size_t offS_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    if (!initNative(env, SA, SA_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offSA_native = (size_t)offSA;
    if (!initNative(env, SB, SB_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offSB_native = (size_t)offSB;
    if (!initNative(env, C, C_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offC_native = (size_t)offC;
    if (!initNative(env, S, S_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offS_native = (size_t)offS;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasSrotg(SA_native, offSA_native, SB_native, offSB_native, C_native, offC_native, S_native, offS_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // SA is a read-only native pointer
    // offSA is primitive
    // SB is a read-only native pointer
    // offSB is primitive
    // C is a read-only native pointer
    // offC is primitive
    // S is a read-only native pointer
    // offS is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* @example example_srotg.c
* Example of how to use the @ref clblasSrotg function.
*/
/**
* construct givens plane rotation on double elements.
*
* @param DA (out)           Buffer object that contains DA
* @param offDA (in)         Offset to DA in  DA buffer object.
*                          Counted in elements.
* @param DB (out)           Buffer object that contains DB
* @param offDB (in)         Offset to DB in  DB buffer object.
*                          Counted in elements.
* @param C (out)            Buffer object that contains C
* @param offC (in)          Offset to C in  C buffer object.
*                          Counted in elements.
* @param S (out)            Buffer object that contains S
* @param offS (in)          Offset to S in  S buffer object.
*                          Counted in elements.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasInvalidDevice if a target device does not support the
*     floating point arithmetic with double precision;
*   - the same error codes as the clblasSrotg() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasDrotgNative(JNIEnv *env, jclass cls, jobject DA, jlong offDA, jobject DB, jlong offDB, jobject C, jlong offC, jobject S, jlong offS, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    if (DA == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'DA' is null for clblasDrotg");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offDA is primitive
    if (DB == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'DB' is null for clblasDrotg");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offDB is primitive
    if (C == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'C' is null for clblasDrotg");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offC is primitive
    if (S == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'S' is null for clblasDrotg");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offS is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasDrotg");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasDrotg(DA=%p, offDA=%ld, DB=%p, offDB=%ld, C=%p, offC=%ld, S=%p, offS=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        DA, offDA, DB, offDB, C, offC, S, offS, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    cl_mem DA_native = nullptr;
    size_t offDA_native = 0;
    cl_mem DB_native = nullptr;
    size_t offDB_native = 0;
    cl_mem C_native = nullptr;
    size_t offC_native = 0;
    cl_mem S_native = nullptr;
    size_t offS_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    if (!initNative(env, DA, DA_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offDA_native = (size_t)offDA;
    if (!initNative(env, DB, DB_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offDB_native = (size_t)offDB;
    if (!initNative(env, C, C_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offC_native = (size_t)offC;
    if (!initNative(env, S, S_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offS_native = (size_t)offS;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasDrotg(DA_native, offDA_native, DB_native, offDB_native, C_native, offC_native, S_native, offS_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // DA is a read-only native pointer
    // offDA is primitive
    // DB is a read-only native pointer
    // offDB is primitive
    // C is a read-only native pointer
    // offC is primitive
    // S is a read-only native pointer
    // offS is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* construct givens plane rotation on float-complex elements.
*
* @param CA (out)           Buffer object that contains CA
* @param offCA (in)         Offset to CA in  CA buffer object.
*                          Counted in elements.
* @param CB (out)           Buffer object that contains CB
* @param offCB (in)         Offset to CB in  CB buffer object.
*                          Counted in elements.
* @param C (out)            Buffer object that contains C. C is real.
* @param offC (in)          Offset to C in  C buffer object.
*                          Counted in elements.
* @param S (out)            Buffer object that contains S
* @param offS (in)          Offset to S in  S buffer object.
*                          Counted in elements.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   - the same error codes as the clblasSrotg() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasCrotgNative(JNIEnv *env, jclass cls, jobject CA, jlong offCA, jobject CB, jlong offCB, jobject C, jlong offC, jobject S, jlong offS, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    if (CA == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'CA' is null for clblasCrotg");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offCA is primitive
    if (CB == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'CB' is null for clblasCrotg");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offCB is primitive
    if (C == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'C' is null for clblasCrotg");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offC is primitive
    if (S == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'S' is null for clblasCrotg");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offS is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasCrotg");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasCrotg(CA=%p, offCA=%ld, CB=%p, offCB=%ld, C=%p, offC=%ld, S=%p, offS=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        CA, offCA, CB, offCB, C, offC, S, offS, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    cl_mem CA_native = nullptr;
    size_t offCA_native = 0;
    cl_mem CB_native = nullptr;
    size_t offCB_native = 0;
    cl_mem C_native = nullptr;
    size_t offC_native = 0;
    cl_mem S_native = nullptr;
    size_t offS_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    if (!initNative(env, CA, CA_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offCA_native = (size_t)offCA;
    if (!initNative(env, CB, CB_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offCB_native = (size_t)offCB;
    if (!initNative(env, C, C_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offC_native = (size_t)offC;
    if (!initNative(env, S, S_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offS_native = (size_t)offS;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasCrotg(CA_native, offCA_native, CB_native, offCB_native, C_native, offC_native, S_native, offS_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // CA is a read-only native pointer
    // offCA is primitive
    // CB is a read-only native pointer
    // offCB is primitive
    // C is a read-only native pointer
    // offC is primitive
    // S is a read-only native pointer
    // offS is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* construct givens plane rotation on double-complex elements.
*
* @param CA (out)           Buffer object that contains CA
* @param offCA (in)         Offset to CA in  CA buffer object.
*                          Counted in elements.
* @param CB (out)           Buffer object that contains CB
* @param offCB (in)         Offset to CB in  CB buffer object.
*                          Counted in elements.
* @param C (out)            Buffer object that contains C. C is real.
* @param offC (in)          Offset to C in  C buffer object.
*                          Counted in elements.
* @param S (out)            Buffer object that contains S
* @param offS (in)          Offset to S in  S buffer object.
*                          Counted in elements.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   - the same error codes as the clblasDrotg() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasZrotgNative(JNIEnv *env, jclass cls, jobject CA, jlong offCA, jobject CB, jlong offCB, jobject C, jlong offC, jobject S, jlong offS, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    if (CA == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'CA' is null for clblasZrotg");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offCA is primitive
    if (CB == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'CB' is null for clblasZrotg");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offCB is primitive
    if (C == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'C' is null for clblasZrotg");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offC is primitive
    if (S == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'S' is null for clblasZrotg");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offS is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasZrotg");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasZrotg(CA=%p, offCA=%ld, CB=%p, offCB=%ld, C=%p, offC=%ld, S=%p, offS=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        CA, offCA, CB, offCB, C, offC, S, offS, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    cl_mem CA_native = nullptr;
    size_t offCA_native = 0;
    cl_mem CB_native = nullptr;
    size_t offCB_native = 0;
    cl_mem C_native = nullptr;
    size_t offC_native = 0;
    cl_mem S_native = nullptr;
    size_t offS_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    if (!initNative(env, CA, CA_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offCA_native = (size_t)offCA;
    if (!initNative(env, CB, CB_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offCB_native = (size_t)offCB;
    if (!initNative(env, C, C_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offC_native = (size_t)offC;
    if (!initNative(env, S, S_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offS_native = (size_t)offS;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasZrotg(CA_native, offCA_native, CB_native, offCB_native, C_native, offC_native, S_native, offS_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // CA is a read-only native pointer
    // offCA is primitive
    // CB is a read-only native pointer
    // offCB is primitive
    // C is a read-only native pointer
    // offC is primitive
    // S is a read-only native pointer
    // offS is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* construct the modified givens rotation on float elements.
*
* @param SD1 (out)          Buffer object that contains SD1
* @param offSD1 (in)        Offset to SD1 in  SD1 buffer object.
*                          Counted in elements.
* @param SD2 (out)          Buffer object that contains SD2
* @param offSD2 (in)        Offset to SD2 in  SD2 buffer object.
*                          Counted in elements.
* @param SX1 (out)          Buffer object that contains SX1
* @param offSX1 (in)        Offset to SX1 in  SX1 buffer object.
*                          Counted in elements.
* @param SY1 (in)           Buffer object that contains SY1
* @param offSY1 (in)        Offset to SY1 in  SY1 buffer object.
*                          Counted in elements.
* @param SPARAM (out)       Buffer object that contains SPARAM array of minimum length 5
SPARAM(0) = SFLAG
SPARAM(1) = SH11
SPARAM(2) = SH21
SPARAM(3) = SH12
SPARAM(4) = SH22

* @param offSparam (in)     Offset to SPARAM in  SPARAM buffer object.
*                          Counted in elements.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasNotInitialized if clblasSetup() was not called;
*   -  clblasInvalidMemObject if either  SX1,  SY1,  SD1,  SD2 or  SPARAM object is
*     Invalid, or an image object rather than the buffer one;
*   -  clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   -  clblasInvalidCommandQueue if the passed command queue is invalid;
*   -  clblasInvalidContext if a context a passed command queue belongs
*     to was released;
*   -  clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   -  clblasCompilerNotAvailable if a compiler is not available;
*   -  clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasSrotmgNative(JNIEnv *env, jclass cls, jobject SD1, jlong offSD1, jobject SD2, jlong offSD2, jobject SX1, jlong offSX1, jobject SY1, jlong offSY1, jobject SPARAM, jlong offSparam, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    if (SD1 == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'SD1' is null for clblasSrotmg");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offSD1 is primitive
    if (SD2 == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'SD2' is null for clblasSrotmg");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offSD2 is primitive
    if (SX1 == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'SX1' is null for clblasSrotmg");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offSX1 is primitive
    if (SY1 == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'SY1' is null for clblasSrotmg");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offSY1 is primitive
    if (SPARAM == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'SPARAM' is null for clblasSrotmg");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offSparam is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasSrotmg");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasSrotmg(SD1=%p, offSD1=%ld, SD2=%p, offSD2=%ld, SX1=%p, offSX1=%ld, SY1=%p, offSY1=%ld, SPARAM=%p, offSparam=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        SD1, offSD1, SD2, offSD2, SX1, offSX1, SY1, offSY1, SPARAM, offSparam, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    cl_mem SD1_native = nullptr;
    size_t offSD1_native = 0;
    cl_mem SD2_native = nullptr;
    size_t offSD2_native = 0;
    cl_mem SX1_native = nullptr;
    size_t offSX1_native = 0;
    cl_mem SY1_native = nullptr;
    size_t offSY1_native = 0;
    cl_mem SPARAM_native = nullptr;
    size_t offSparam_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    if (!initNative(env, SD1, SD1_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offSD1_native = (size_t)offSD1;
    if (!initNative(env, SD2, SD2_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offSD2_native = (size_t)offSD2;
    if (!initNative(env, SX1, SX1_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offSX1_native = (size_t)offSX1;
    if (!initNative(env, SY1, SY1_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offSY1_native = (size_t)offSY1;
    if (!initNative(env, SPARAM, SPARAM_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offSparam_native = (size_t)offSparam;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasSrotmg(SD1_native, offSD1_native, SD2_native, offSD2_native, SX1_native, offSX1_native, SY1_native, offSY1_native, SPARAM_native, offSparam_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // SD1 is a read-only native pointer
    // offSD1 is primitive
    // SD2 is a read-only native pointer
    // offSD2 is primitive
    // SX1 is a read-only native pointer
    // offSX1 is primitive
    // SY1 is a read-only native pointer
    // offSY1 is primitive
    // SPARAM is a read-only native pointer
    // offSparam is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* @example example_srotmg.c
* Example of how to use the @ref clblasSrotmg function.
*/
/**
* construct the modified givens rotation on double elements.
*
* @param DD1 (out)          Buffer object that contains DD1
* @param offDD1 (in)        Offset to DD1 in  DD1 buffer object.
*                          Counted in elements.
* @param DD2 (out)          Buffer object that contains DD2
* @param offDD2 (in)        Offset to DD2 in  DD2 buffer object.
*                          Counted in elements.
* @param DX1 (out)          Buffer object that contains DX1
* @param offDX1 (in)        Offset to DX1 in  DX1 buffer object.
*                          Counted in elements.
* @param DY1 (in)           Buffer object that contains DY1
* @param offDY1 (in)        Offset to DY1 in  DY1 buffer object.
*                          Counted in elements.
* @param DPARAM (out)       Buffer object that contains DPARAM array of minimum length 5
DPARAM(0) = DFLAG
DPARAM(1) = DH11
DPARAM(2) = DH21
DPARAM(3) = DH12
DPARAM(4) = DH22

* @param offDparam (in)     Offset to DPARAM in  DPARAM buffer object.
*                          Counted in elements.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasInvalidDevice if a target device does not support the
*     floating point arithmetic with double precision;
*   - the same error codes as the clblasSrotmg() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasDrotmgNative(JNIEnv *env, jclass cls, jobject DD1, jlong offDD1, jobject DD2, jlong offDD2, jobject DX1, jlong offDX1, jobject DY1, jlong offDY1, jobject DPARAM, jlong offDparam, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    if (DD1 == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'DD1' is null for clblasDrotmg");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offDD1 is primitive
    if (DD2 == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'DD2' is null for clblasDrotmg");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offDD2 is primitive
    if (DX1 == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'DX1' is null for clblasDrotmg");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offDX1 is primitive
    if (DY1 == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'DY1' is null for clblasDrotmg");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offDY1 is primitive
    if (DPARAM == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'DPARAM' is null for clblasDrotmg");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offDparam is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasDrotmg");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasDrotmg(DD1=%p, offDD1=%ld, DD2=%p, offDD2=%ld, DX1=%p, offDX1=%ld, DY1=%p, offDY1=%ld, DPARAM=%p, offDparam=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        DD1, offDD1, DD2, offDD2, DX1, offDX1, DY1, offDY1, DPARAM, offDparam, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    cl_mem DD1_native = nullptr;
    size_t offDD1_native = 0;
    cl_mem DD2_native = nullptr;
    size_t offDD2_native = 0;
    cl_mem DX1_native = nullptr;
    size_t offDX1_native = 0;
    cl_mem DY1_native = nullptr;
    size_t offDY1_native = 0;
    cl_mem DPARAM_native = nullptr;
    size_t offDparam_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    if (!initNative(env, DD1, DD1_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offDD1_native = (size_t)offDD1;
    if (!initNative(env, DD2, DD2_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offDD2_native = (size_t)offDD2;
    if (!initNative(env, DX1, DX1_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offDX1_native = (size_t)offDX1;
    if (!initNative(env, DY1, DY1_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offDY1_native = (size_t)offDY1;
    if (!initNative(env, DPARAM, DPARAM_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offDparam_native = (size_t)offDparam;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasDrotmg(DD1_native, offDD1_native, DD2_native, offDD2_native, DX1_native, offDX1_native, DY1_native, offDY1_native, DPARAM_native, offDparam_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // DD1 is a read-only native pointer
    // offDD1 is primitive
    // DD2 is a read-only native pointer
    // offDD2 is primitive
    // DX1 is a read-only native pointer
    // offDX1 is primitive
    // DY1 is a read-only native pointer
    // offDY1 is primitive
    // DPARAM is a read-only native pointer
    // offDparam is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* applies a plane rotation for float elements.
*
* @param N (in)         Number of elements in vector  X and  Y.
* @param X (out)        Buffer object storing vector  X.
* @param offx (in)      Offset of first element of vector  X in buffer object.
*                      Counted in elements.
* @param incx (in)      Increment for the elements of  X. Must not be zero.
* @param Y (out)        Buffer object storing the vector  Y.
* @param offy (in)      Offset of first element of vector  Y in buffer object.
*                      Counted in elements.
* @param incy (in)      Increment for the elements of  Y. Must not be zero.
* @param C (in)         C specifies the cosine, cos.
* @param S (in)         S specifies the sine, sin.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasNotInitialized if clblasSetup() was not called;
*   -  clblasInvalidValue if invalid parameters are passed:
*     -  N is zero, or
*     - either  incx or  incy is zero, or
*     - the vector sizes along with the increments lead to
*       accessing outside of any of the buffers;
*   -  clblasInvalidMemObject if either  X, or  Y object is
*     Invalid, or an image object rather than the buffer one;
*   -  clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   -  clblasInvalidCommandQueue if the passed command queue is invalid;
*   -  clblasInvalidContext if a context a passed command queue belongs
*     to was released;
*   -  clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   -  clblasCompilerNotAvailable if a compiler is not available;
*   -  clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasSrotNative(JNIEnv *env, jclass cls, jlong N, jobject X, jlong offx, jint incx, jobject Y, jlong offy, jint incy, jfloat C, jfloat S, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasSrot");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (Y == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasSrot");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    // C is primitive
    // S is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasSrot");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasSrot(N=%ld, X=%p, offx=%ld, incx=%d, Y=%p, offy=%ld, incy=%d, C=%f, S=%f, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, X, offx, incx, Y, offy, incy, C, S, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_float C_native = 0.0f;
    cl_float S_native = 0.0f;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    N_native = (size_t)N;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    C_native = (cl_float)C;
    S_native = (cl_float)S;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasSrot(N_native, X_native, offx_native, incx_native, Y_native, offy_native, incy_native, C_native, S_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // C is primitive
    // S is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* @example example_srot.c
* Example of how to use the @ref clblasSrot function.
*/
/**
* applies a plane rotation for double elements.
*
* @param N (in)         Number of elements in vector  X and  Y.
* @param X (out)        Buffer object storing vector  X.
* @param offx (in)      Offset of first element of vector  X in buffer object.
*                      Counted in elements.
* @param incx (in)      Increment for the elements of  X. Must not be zero.
* @param Y (out)        Buffer object storing the vector  Y.
* @param offy (in)      Offset of first element of vector  Y in buffer object.
*                      Counted in elements.
* @param incy (in)      Increment for the elements of  Y. Must not be zero.
* @param C (in)         C specifies the cosine, cos.
* @param S (in)         S specifies the sine, sin.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasInvalidDevice if a target device does not support the
*     floating point arithmetic with double precision;
*   - the same error codes as the clblasSrot() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasDrotNative(JNIEnv *env, jclass cls, jlong N, jobject X, jlong offx, jint incx, jobject Y, jlong offy, jint incy, jdouble C, jdouble S, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasDrot");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (Y == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasDrot");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    // C is primitive
    // S is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasDrot");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasDrot(N=%ld, X=%p, offx=%ld, incx=%d, Y=%p, offy=%ld, incy=%d, C=%lf, S=%lf, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, X, offx, incx, Y, offy, incy, C, S, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_double C_native = 0.0;
    cl_double S_native = 0.0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    N_native = (size_t)N;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    C_native = (cl_double)C;
    S_native = (cl_double)S;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasDrot(N_native, X_native, offx_native, incx_native, Y_native, offy_native, incy_native, C_native, S_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // C is primitive
    // S is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* applies a plane rotation for float-complex elements.
*
* @param N (in)         Number of elements in vector  X and  Y.
* @param X (out)        Buffer object storing vector  X.
* @param offx (in)      Offset of first element of vector  X in buffer object.
*                      Counted in elements.
* @param incx (in)      Increment for the elements of  X. Must not be zero.
* @param Y (out)        Buffer object storing the vector  Y.
* @param offy (in)      Offset of first element of vector  Y in buffer object.
*                      Counted in elements.
* @param incy (in)      Increment for the elements of  Y. Must not be zero.
* @param C (in)         C specifies the cosine, cos. This number is real
* @param S (in)         S specifies the sine, sin. This number is real
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   - the same error codes as the clblasSrot() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasCsrotNative(JNIEnv *env, jclass cls, jlong N, jobject X, jlong offx, jint incx, jobject Y, jlong offy, jint incy, jfloat C, jfloat S, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasCsrot");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (Y == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasCsrot");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    // C is primitive
    // S is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasCsrot");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasCsrot(N=%ld, X=%p, offx=%ld, incx=%d, Y=%p, offy=%ld, incy=%d, C=%f, S=%f, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, X, offx, incx, Y, offy, incy, C, S, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_float C_native = 0.0f;
    cl_float S_native = 0.0f;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    N_native = (size_t)N;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    C_native = (cl_float)C;
    S_native = (cl_float)S;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasCsrot(N_native, X_native, offx_native, incx_native, Y_native, offy_native, incy_native, C_native, S_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // C is primitive
    // S is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* applies a plane rotation for double-complex elements.
*
* @param N (in)         Number of elements in vector  X and  Y.
* @param X (out)        Buffer object storing vector  X.
* @param offx (in)      Offset of first element of vector  X in buffer object.
*                      Counted in elements.
* @param incx (in)      Increment for the elements of  X. Must not be zero.
* @param Y (out)        Buffer object storing the vector  Y.
* @param offy (in)      Offset of first element of vector  Y in buffer object.
*                      Counted in elements.
* @param incy (in)      Increment for the elements of  Y. Must not be zero.
* @param C (in)         C specifies the cosine, cos. This number is real
* @param S (in)         S specifies the sine, sin. This number is real
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasInvalidDevice if a target device does not support the
*     floating point arithmetic with double precision;
*   - the same error codes as the clblasSrot() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasZdrotNative(JNIEnv *env, jclass cls, jlong N, jobject X, jlong offx, jint incx, jobject Y, jlong offy, jint incy, jdouble C, jdouble S, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasZdrot");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (Y == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasZdrot");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    // C is primitive
    // S is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasZdrot");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasZdrot(N=%ld, X=%p, offx=%ld, incx=%d, Y=%p, offy=%ld, incy=%d, C=%lf, S=%lf, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, X, offx, incx, Y, offy, incy, C, S, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_double C_native = 0.0;
    cl_double S_native = 0.0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    N_native = (size_t)N;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    C_native = (cl_double)C;
    S_native = (cl_double)S;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasZdrot(N_native, X_native, offx_native, incx_native, Y_native, offy_native, incy_native, C_native, S_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // C is primitive
    // S is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* modified givens rotation for float elements.
*
* @param N (in)         Number of elements in vector  X and  Y.
* @param X (out)        Buffer object storing vector  X.
* @param offx (in)      Offset of first element of vector  X in buffer object.
*                      Counted in elements.
* @param incx (in)      Increment for the elements of  X. Must not be zero.
* @param Y (out)        Buffer object storing the vector  Y.
* @param offy (in)      Offset of first element of vector  Y in buffer object.
*                      Counted in elements.
* @param incy (in)      Increment for the elements of  Y. Must not be zero.
* @param SPARAM (in)    Buffer object that contains SPARAM array of minimum length 5
*                      SPARAM(1)=SFLAG
*                      SPARAM(2)=SH11
*                      SPARAM(3)=SH21
*                      SPARAM(4)=SH12
*                      SPARAM(5)=SH22
* @param offSparam (in) Offset of first element of array  SPARAM in buffer object.
*                      Counted in elements.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasNotInitialized if clblasSetup() was not called;
*   -  clblasInvalidValue if invalid parameters are passed:
*     -  N is zero, or
*     - either  incx or  incy is zero, or
*     - the vector sizes along with the increments lead to
*       accessing outside of any of the buffers;
*   -  clblasInvalidMemObject if either  X,  Y or  SPARAM object is
*     Invalid, or an image object rather than the buffer one;
*   -  clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   -  clblasInvalidCommandQueue if the passed command queue is invalid;
*   -  clblasInvalidContext if a context a passed command queue belongs
*     to was released;
*   -  clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   -  clblasCompilerNotAvailable if a compiler is not available;
*   -  clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasSrotmNative(JNIEnv *env, jclass cls, jlong N, jobject X, jlong offx, jint incx, jobject Y, jlong offy, jint incy, jobject SPARAM, jlong offSparam, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasSrotm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (Y == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasSrotm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    if (SPARAM == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'SPARAM' is null for clblasSrotm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offSparam is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasSrotm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasSrotm(N=%ld, X=%p, offx=%ld, incx=%d, Y=%p, offy=%ld, incy=%d, SPARAM=%p, offSparam=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, X, offx, incx, Y, offy, incy, SPARAM, offSparam, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_mem SPARAM_native = nullptr;
    size_t offSparam_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    N_native = (size_t)N;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    if (!initNative(env, SPARAM, SPARAM_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offSparam_native = (size_t)offSparam;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasSrotm(N_native, X_native, offx_native, incx_native, Y_native, offy_native, incy_native, SPARAM_native, offSparam_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // SPARAM is a read-only native pointer
    // offSparam is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* @example example_srotm.c
* Example of how to use the @ref clblasSrotm function.
*/
/**
* modified givens rotation for double elements.
*
* @param N (in)         Number of elements in vector  X and  Y.
* @param X (out)        Buffer object storing vector  X.
* @param offx (in)      Offset of first element of vector  X in buffer object.
*                      Counted in elements.
* @param incx (in)      Increment for the elements of  X. Must not be zero.
* @param Y (out)        Buffer object storing the vector  Y.
* @param offy (in)      Offset of first element of vector  Y in buffer object.
*                      Counted in elements.
* @param incy (in)      Increment for the elements of  Y. Must not be zero.
* @param DPARAM (in)    Buffer object that contains SPARAM array of minimum length 5
*                      DPARAM(1)=DFLAG
*                      DPARAM(2)=DH11
*                      DPARAM(3)=DH21
*                      DPARAM(4)=DH12
*                      DPARAM(5)=DH22
* @param offDparam (in) Offset of first element of array  DPARAM in buffer object.
*                      Counted in elements.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasInvalidDevice if a target device does not support the
*     floating point arithmetic with double precision;
*   - the same error codes as the clblasSrotm() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasDrotmNative(JNIEnv *env, jclass cls, jlong N, jobject X, jlong offx, jint incx, jobject Y, jlong offy, jint incy, jobject DPARAM, jlong offDparam, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasDrotm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (Y == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasDrotm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    if (DPARAM == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'DPARAM' is null for clblasDrotm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offDparam is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasDrotm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasDrotm(N=%ld, X=%p, offx=%ld, incx=%d, Y=%p, offy=%ld, incy=%d, DPARAM=%p, offDparam=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, X, offx, incx, Y, offy, incy, DPARAM, offDparam, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_mem DPARAM_native = nullptr;
    size_t offDparam_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    N_native = (size_t)N;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    if (!initNative(env, DPARAM, DPARAM_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offDparam_native = (size_t)offDparam;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasDrotm(N_native, X_native, offx_native, incx_native, Y_native, offy_native, incy_native, DPARAM_native, offDparam_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // DPARAM is a read-only native pointer
    // offDparam is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* computes the euclidean norm of vector containing float elements.
*
*  NRM2 = sqrt( X' * X )
*
* @param N (in)             Number of elements in vector  X.
* @param NRM2 (out)         Buffer object that will contain the NRM2 value
* @param offNRM2 (in)       Offset to NRM2 value in  NRM2 buffer object.
*                          Counted in elements.
* @param X (in)             Buffer object storing vector  X.
* @param offx (in)          Offset of first element of vector  X in buffer object.
*                          Counted in elements.
* @param incx (in)          Increment for the elements of  X. Must not be zero.
* @param scratchBuff	Temporary (in) cl_mem scratch buffer object that can hold minimum of (2*N) elements
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasNotInitialized if clblasSetup() was not called;
*   -  clblasInvalidValue if invalid parameters are passed:
*     -  N is zero, or
*     - either  incx is zero, or
*     - the vector sizes along with the increments lead to
*       accessing outside of any of the buffers;
*   -  clblasInvalidMemObject if any of  X or  NRM2 or  scratchBuff object is
*     Invalid, or an image object rather than the buffer one;
*   -  clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   -  clblasInvalidCommandQueue if the passed command queue is invalid;
*   -  clblasInvalidContext if a context a passed command queue belongs
*     to was released;
*   -  clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   -  clblasCompilerNotAvailable if a compiler is not available;
*   -  clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasSnrm2Native(JNIEnv *env, jclass cls, jlong N, jobject NRM2, jlong offNRM2, jobject X, jlong offx, jint incx, jobject scratchBuff, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    if (NRM2 == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'NRM2' is null for clblasSnrm2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offNRM2 is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasSnrm2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (scratchBuff == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'scratchBuff' is null for clblasSnrm2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasSnrm2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasSnrm2(N=%ld, NRM2=%p, offNRM2=%ld, X=%p, offx=%ld, incx=%d, scratchBuff=%p, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, NRM2, offNRM2, X, offx, incx, scratchBuff, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_mem NRM2_native = nullptr;
    size_t offNRM2_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem scratchBuff_native = nullptr;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    N_native = (size_t)N;
    if (!initNative(env, NRM2, NRM2_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offNRM2_native = (size_t)offNRM2;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, scratchBuff, scratchBuff_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasSnrm2(N_native, NRM2_native, offNRM2_native, X_native, offx_native, incx_native, scratchBuff_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    // NRM2 is a read-only native pointer
    // offNRM2 is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // scratchBuff is a read-only native pointer
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* @example example_snrm2.c
* Example of how to use the @ref clblasSnrm2 function.
*/
/**
* computes the euclidean norm of vector containing double elements.
*
*  NRM2 = sqrt( X' * X )
*
* @param N (in)             Number of elements in vector  X.
* @param NRM2 (out)         Buffer object that will contain the NRM2 value
* @param offNRM2 (in)       Offset to NRM2 value in  NRM2 buffer object.
*                          Counted in elements.
* @param X (in)             Buffer object storing vector  X.
* @param offx (in)          Offset of first element of vector  X in buffer object.
*                          Counted in elements.
* @param incx (in)          Increment for the elements of  X. Must not be zero.
* @param scratchBuff	Temporary (in) cl_mem scratch buffer object that can hold minimum of (2*N) elements
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasInvalidDevice if a target device does not support the
*     floating point arithmetic with double precision;
*   - the same error codes as the clblasSnrm2() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasDnrm2Native(JNIEnv *env, jclass cls, jlong N, jobject NRM2, jlong offNRM2, jobject X, jlong offx, jint incx, jobject scratchBuff, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    if (NRM2 == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'NRM2' is null for clblasDnrm2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offNRM2 is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasDnrm2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (scratchBuff == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'scratchBuff' is null for clblasDnrm2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasDnrm2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasDnrm2(N=%ld, NRM2=%p, offNRM2=%ld, X=%p, offx=%ld, incx=%d, scratchBuff=%p, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, NRM2, offNRM2, X, offx, incx, scratchBuff, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_mem NRM2_native = nullptr;
    size_t offNRM2_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem scratchBuff_native = nullptr;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    N_native = (size_t)N;
    if (!initNative(env, NRM2, NRM2_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offNRM2_native = (size_t)offNRM2;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, scratchBuff, scratchBuff_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasDnrm2(N_native, NRM2_native, offNRM2_native, X_native, offx_native, incx_native, scratchBuff_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    // NRM2 is a read-only native pointer
    // offNRM2 is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // scratchBuff is a read-only native pointer
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* computes the euclidean norm of vector containing float-complex elements.
*
*  NRM2 = sqrt( X**H * X )
*
* @param N (in)             Number of elements in vector  X.
* @param NRM2 (out)         Buffer object that will contain the NRM2 value.
*                          Note that the answer of Scnrm2 is a real value.
* @param offNRM2 (in)       Offset to NRM2 value in  NRM2 buffer object.
*                          Counted in elements.
* @param X (in)             Buffer object storing vector  X.
* @param offx (in)          Offset of first element of vector  X in buffer object.
*                          Counted in elements.
* @param incx (in)          Increment for the elements of  X. Must not be zero.
* @param scratchBuff	Temporary (in) cl_mem scratch buffer object that can hold minimum of (2*N) elements
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   - the same error codes as the clblasSnrm2() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasScnrm2Native(JNIEnv *env, jclass cls, jlong N, jobject NRM2, jlong offNRM2, jobject X, jlong offx, jint incx, jobject scratchBuff, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    if (NRM2 == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'NRM2' is null for clblasScnrm2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offNRM2 is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasScnrm2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (scratchBuff == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'scratchBuff' is null for clblasScnrm2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasScnrm2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasScnrm2(N=%ld, NRM2=%p, offNRM2=%ld, X=%p, offx=%ld, incx=%d, scratchBuff=%p, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, NRM2, offNRM2, X, offx, incx, scratchBuff, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_mem NRM2_native = nullptr;
    size_t offNRM2_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem scratchBuff_native = nullptr;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    N_native = (size_t)N;
    if (!initNative(env, NRM2, NRM2_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offNRM2_native = (size_t)offNRM2;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, scratchBuff, scratchBuff_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasScnrm2(N_native, NRM2_native, offNRM2_native, X_native, offx_native, incx_native, scratchBuff_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    // NRM2 is a read-only native pointer
    // offNRM2 is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // scratchBuff is a read-only native pointer
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* computes the euclidean norm of vector containing double-complex elements.
*
*  NRM2 = sqrt( X**H * X )
*
* @param N (in)             Number of elements in vector  X.
* @param NRM2 (out)         Buffer object that will contain the NRM2 value.
*                          Note that the answer of Dznrm2 is a real value.
* @param offNRM2 (in)       Offset to NRM2 value in  NRM2 buffer object.
*                          Counted in elements.
* @param X (in)             Buffer object storing vector  X.
* @param offx (in)          Offset of first element of vector  X in buffer object.
*                          Counted in elements.
* @param incx (in)          Increment for the elements of  X. Must not be zero.
* @param scratchBuff	Temporary (in) cl_mem scratch buffer object that can hold minimum of (2*N) elements
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasInvalidDevice if a target device does not support the
*     floating point arithmetic with double precision;
*   - the same error codes as the clblasSnrm2() function otherwise.
*     executable.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasDznrm2Native(JNIEnv *env, jclass cls, jlong N, jobject NRM2, jlong offNRM2, jobject X, jlong offx, jint incx, jobject scratchBuff, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    if (NRM2 == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'NRM2' is null for clblasDznrm2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offNRM2 is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasDznrm2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (scratchBuff == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'scratchBuff' is null for clblasDznrm2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasDznrm2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasDznrm2(N=%ld, NRM2=%p, offNRM2=%ld, X=%p, offx=%ld, incx=%d, scratchBuff=%p, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, NRM2, offNRM2, X, offx, incx, scratchBuff, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_mem NRM2_native = nullptr;
    size_t offNRM2_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem scratchBuff_native = nullptr;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    N_native = (size_t)N;
    if (!initNative(env, NRM2, NRM2_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offNRM2_native = (size_t)offNRM2;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, scratchBuff, scratchBuff_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasDznrm2(N_native, NRM2_native, offNRM2_native, X_native, offx_native, incx_native, scratchBuff_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    // NRM2 is a read-only native pointer
    // offNRM2 is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // scratchBuff is a read-only native pointer
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* index of max absolute value in a float array.
*
* @param N (in)             Number of elements in vector  X.
* @param iMax (out)         Buffer object storing the index of first absolute max.
*                          The index will be of type unsigned int
* @param offiMax (in)       Offset for storing index in the buffer iMax
*                          Counted in elements.
* @param X (in)             Buffer object storing vector  X.
* @param offx (in)          Offset of first element of vector  X in buffer object.
*                          Counted in elements.
* @param incx (in)          Increment for the elements of  X. Must not be zero.
* @param scratchBuff (in)   Temprory cl_mem object to store intermediate results
It should be able to hold minimum of (2*N) elements
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasNotInitialized if clblasSetup() was not called;
*   -  clblasInvalidValue if invalid parameters are passed:
*     -  N is zero, or
*     - either  incx is zero, or
*     - the vector sizes along with the increments lead to
*       accessing outside of any of the buffers;
*   -  clblasInvalidMemObject if any of  iMax  X or  scratchBuff object is
*     Invalid, or an image object rather than the buffer one;
*   -  clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   -  clblasInvalidCommandQueue if the passed command queue is invalid;
*   -  clblasInvalidContext if the context, the passed command queue belongs
*     to was released;
*   -  clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   -  clblasCompilerNotAvailable if a compiler is not available;
*   -  clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasiSamaxNative(JNIEnv *env, jclass cls, jlong N, jobject iMax, jlong offiMax, jobject X, jlong offx, jint incx, jobject scratchBuff, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    if (iMax == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'iMax' is null for clblasiSamax");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offiMax is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasiSamax");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (scratchBuff == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'scratchBuff' is null for clblasiSamax");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasiSamax");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasiSamax(N=%ld, iMax=%p, offiMax=%ld, X=%p, offx=%ld, incx=%d, scratchBuff=%p, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, iMax, offiMax, X, offx, incx, scratchBuff, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_mem iMax_native = nullptr;
    size_t offiMax_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem scratchBuff_native = nullptr;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    N_native = (size_t)N;
    if (!initNative(env, iMax, iMax_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offiMax_native = (size_t)offiMax;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, scratchBuff, scratchBuff_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasiSamax(N_native, iMax_native, offiMax_native, X_native, offx_native, incx_native, scratchBuff_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    // iMax is a read-only native pointer
    // offiMax is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // scratchBuff is a read-only native pointer
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* @example example_isamax.c
* Example of how to use the @ref clblasiSamax function.
*/
/**
* index of max absolute value in a double array.
*
* @param N (in)             Number of elements in vector  X.
* @param iMax (out)         Buffer object storing the index of first absolute max.
*                          The index will be of type unsigned int
* @param offiMax (in)       Offset for storing index in the buffer iMax
*                          Counted in elements.
* @param X (in)             Buffer object storing vector  X.
* @param offx (in)          Offset of first element of vector  X in buffer object.
*                          Counted in elements.
* @param incx (in)          Increment for the elements of  X. Must not be zero.
* @param scratchBuff (in)   Temprory cl_mem object to store intermediate results
It should be able to hold minimum of (2*N) elements
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasInvalidDevice if a target device does not support the
*     floating point arithmetic with double precision;
*   - the same error codes as the clblasiSamax() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasiDamaxNative(JNIEnv *env, jclass cls, jlong N, jobject iMax, jlong offiMax, jobject X, jlong offx, jint incx, jobject scratchBuff, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    if (iMax == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'iMax' is null for clblasiDamax");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offiMax is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasiDamax");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (scratchBuff == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'scratchBuff' is null for clblasiDamax");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasiDamax");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasiDamax(N=%ld, iMax=%p, offiMax=%ld, X=%p, offx=%ld, incx=%d, scratchBuff=%p, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, iMax, offiMax, X, offx, incx, scratchBuff, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_mem iMax_native = nullptr;
    size_t offiMax_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem scratchBuff_native = nullptr;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    N_native = (size_t)N;
    if (!initNative(env, iMax, iMax_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offiMax_native = (size_t)offiMax;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, scratchBuff, scratchBuff_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasiDamax(N_native, iMax_native, offiMax_native, X_native, offx_native, incx_native, scratchBuff_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    // iMax is a read-only native pointer
    // offiMax is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // scratchBuff is a read-only native pointer
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* index of max absolute value in a complex float array.
*
* @param N (in)             Number of elements in vector  X.
* @param iMax (out)         Buffer object storing the index of first absolute max.
*                          The index will be of type unsigned int
* @param offiMax (in)       Offset for storing index in the buffer iMax
*                          Counted in elements.
* @param X (in)             Buffer object storing vector  X.
* @param offx (in)          Offset of first element of vector  X in buffer object.
*                          Counted in elements.
* @param incx (in)          Increment for the elements of  X. Must not be zero.
* @param scratchBuff (in)   Temprory cl_mem object to store intermediate results
It should be able to hold minimum of (2*N) elements
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   - the same error codes as the clblasiSamax() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasiCamaxNative(JNIEnv *env, jclass cls, jlong N, jobject iMax, jlong offiMax, jobject X, jlong offx, jint incx, jobject scratchBuff, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    if (iMax == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'iMax' is null for clblasiCamax");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offiMax is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasiCamax");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (scratchBuff == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'scratchBuff' is null for clblasiCamax");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasiCamax");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasiCamax(N=%ld, iMax=%p, offiMax=%ld, X=%p, offx=%ld, incx=%d, scratchBuff=%p, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, iMax, offiMax, X, offx, incx, scratchBuff, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_mem iMax_native = nullptr;
    size_t offiMax_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem scratchBuff_native = nullptr;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    N_native = (size_t)N;
    if (!initNative(env, iMax, iMax_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offiMax_native = (size_t)offiMax;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, scratchBuff, scratchBuff_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasiCamax(N_native, iMax_native, offiMax_native, X_native, offx_native, incx_native, scratchBuff_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    // iMax is a read-only native pointer
    // offiMax is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // scratchBuff is a read-only native pointer
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* index of max absolute value in a complex double array.
*
* @param N (in)             Number of elements in vector  X.
* @param iMax (out)         Buffer object storing the index of first absolute max.
*                          The index will be of type unsigned int
* @param offiMax (in)       Offset for storing index in the buffer iMax
*                          Counted in elements.
* @param X (in)             Buffer object storing vector  X.
* @param offx (in)          Offset of first element of vector  X in buffer object.
*                          Counted in elements.
* @param incx (in)          Increment for the elements of  X. Must not be zero.
* @param scratchBuff (in)   Temprory cl_mem object to store intermediate results
It should be able to hold minimum of (2*N) elements
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
* @return
*   -  clblasSuccess on success;
*   -  clblasInvalidDevice if a target device does not support the
*     floating point arithmetic with double precision;
*   - the same error codes as the clblasiSamax() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasiZamaxNative(JNIEnv *env, jclass cls, jlong N, jobject iMax, jlong offiMax, jobject X, jlong offx, jint incx, jobject scratchBuff, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    if (iMax == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'iMax' is null for clblasiZamax");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offiMax is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasiZamax");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (scratchBuff == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'scratchBuff' is null for clblasiZamax");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasiZamax");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasiZamax(N=%ld, iMax=%p, offiMax=%ld, X=%p, offx=%ld, incx=%d, scratchBuff=%p, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, iMax, offiMax, X, offx, incx, scratchBuff, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_mem iMax_native = nullptr;
    size_t offiMax_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem scratchBuff_native = nullptr;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    N_native = (size_t)N;
    if (!initNative(env, iMax, iMax_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offiMax_native = (size_t)offiMax;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, scratchBuff, scratchBuff_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasiZamax(N_native, iMax_native, offiMax_native, X_native, offx_native, incx_native, scratchBuff_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    // iMax is a read-only native pointer
    // offiMax is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // scratchBuff is a read-only native pointer
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* absolute sum of values of a vector containing float elements.
*
* @param N (in)             Number of elements in vector  X.
* @param asum (out)         Buffer object that will contain the absoule sum value
* @param offAsum (in)       Offset to absolute sum in  asum buffer object.
*                          Counted in elements.
* @param X (in)             Buffer object storing vector  X.
* @param offx (in)          Offset of first element of vector  X in buffer object.
*                          Counted in elements.
* @param incx (in)          Increment for the elements of  X. Must not be zero.
* @param scratchBuff (in)   Temporary cl_mem scratch buffer object of minimum size N
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasNotInitialized if clblasSetup() was not called;
*   -  clblasInvalidValue if invalid parameters are passed:
*     -  N is zero, or
*     - either  incx is zero, or
*     - the vector sizes along with the increments lead to
*       accessing outside of any of the buffers;
*   -  clblasInvalidMemObject if any of  X or  asum or  scratchBuff object is
*     Invalid, or an image object rather than the buffer one;
*   -  clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   -  clblasInvalidCommandQueue if the passed command queue is invalid;
*   -  clblasInvalidContext if a context a passed command queue belongs
*     to was released;
*   -  clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   -  clblasCompilerNotAvailable if a compiler is not available;
*   -  clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasSasumNative(JNIEnv *env, jclass cls, jlong N, jobject asum, jlong offAsum, jobject X, jlong offx, jint incx, jobject scratchBuff, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    if (asum == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'asum' is null for clblasSasum");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offAsum is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasSasum");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (scratchBuff == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'scratchBuff' is null for clblasSasum");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasSasum");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasSasum(N=%ld, asum=%p, offAsum=%ld, X=%p, offx=%ld, incx=%d, scratchBuff=%p, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, asum, offAsum, X, offx, incx, scratchBuff, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_mem asum_native = nullptr;
    size_t offAsum_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem scratchBuff_native = nullptr;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    N_native = (size_t)N;
    if (!initNative(env, asum, asum_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offAsum_native = (size_t)offAsum;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, scratchBuff, scratchBuff_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasSasum(N_native, asum_native, offAsum_native, X_native, offx_native, incx_native, scratchBuff_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    // asum is a read-only native pointer
    // offAsum is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // scratchBuff is a read-only native pointer
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* @example example_sasum.c
* Example of how to use the @ref clblasSasum function.
*/
/**
* absolute sum of values of a vector containing double elements.
*
* @param N (in)             Number of elements in vector  X.
* @param asum (out)         Buffer object that will contain the absoulte sum value
* @param offAsum (in)       Offset to absoule sum in  asum buffer object.
*                          Counted in elements.
* @param X (in)             Buffer object storing vector  X.
* @param offx (in)          Offset of first element of vector  X in buffer object.
*                          Counted in elements.
* @param incx (in)          Increment for the elements of  X. Must not be zero.
* @param scratchBuff (in)   Temporary cl_mem scratch buffer object of minimum size N
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasInvalidDevice if a target device does not support the
*     floating point arithmetic with double precision;
*   - the same error codes as the clblasSasum() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasDasumNative(JNIEnv *env, jclass cls, jlong N, jobject asum, jlong offAsum, jobject X, jlong offx, jint incx, jobject scratchBuff, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    if (asum == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'asum' is null for clblasDasum");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offAsum is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasDasum");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (scratchBuff == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'scratchBuff' is null for clblasDasum");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasDasum");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasDasum(N=%ld, asum=%p, offAsum=%ld, X=%p, offx=%ld, incx=%d, scratchBuff=%p, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, asum, offAsum, X, offx, incx, scratchBuff, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_mem asum_native = nullptr;
    size_t offAsum_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem scratchBuff_native = nullptr;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    N_native = (size_t)N;
    if (!initNative(env, asum, asum_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offAsum_native = (size_t)offAsum;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, scratchBuff, scratchBuff_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasDasum(N_native, asum_native, offAsum_native, X_native, offx_native, incx_native, scratchBuff_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    // asum is a read-only native pointer
    // offAsum is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // scratchBuff is a read-only native pointer
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* absolute sum of values of a vector containing float-complex elements.
*
* @param N (in)             Number of elements in vector  X.
* @param asum (out)         Buffer object that will contain the absolute sum value
* @param offAsum (in)       Offset to absolute sum in  asum buffer object.
*                          Counted in elements.
* @param X (in)             Buffer object storing vector  X.
* @param offx (in)          Offset of first element of vector  X in buffer object.
*                          Counted in elements.
* @param incx (in)          Increment for the elements of  X. Must not be zero.
* @param scratchBuff (in)   Temporary cl_mem scratch buffer object of minimum size N
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   - the same error codes as the clblasSasum() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasScasumNative(JNIEnv *env, jclass cls, jlong N, jobject asum, jlong offAsum, jobject X, jlong offx, jint incx, jobject scratchBuff, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    if (asum == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'asum' is null for clblasScasum");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offAsum is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasScasum");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (scratchBuff == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'scratchBuff' is null for clblasScasum");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasScasum");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasScasum(N=%ld, asum=%p, offAsum=%ld, X=%p, offx=%ld, incx=%d, scratchBuff=%p, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, asum, offAsum, X, offx, incx, scratchBuff, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_mem asum_native = nullptr;
    size_t offAsum_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem scratchBuff_native = nullptr;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    N_native = (size_t)N;
    if (!initNative(env, asum, asum_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offAsum_native = (size_t)offAsum;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, scratchBuff, scratchBuff_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasScasum(N_native, asum_native, offAsum_native, X_native, offx_native, incx_native, scratchBuff_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    // asum is a read-only native pointer
    // offAsum is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // scratchBuff is a read-only native pointer
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* absolute sum of values of a vector containing double-complex elements.
*
* @param N (in)             Number of elements in vector  X.
* @param asum (out)         Buffer object that will contain the absolute sum value
* @param offAsum (in)       Offset to absolute sum in  asum buffer object.
*                          Counted in elements.
* @param X (in)             Buffer object storing vector  X.
* @param offx (in)          Offset of first element of vector  X in buffer object.
*                          Counted in elements.
* @param incx (in)          Increment for the elements of  X. Must not be zero.
* @param scratchBuff (in)   Temporary cl_mem scratch buffer object of minimum size N
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasInvalidDevice if a target device does not support the
*     floating point arithmetic with double precision;
*   - the same error codes as the clblasSasum() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasDzasumNative(JNIEnv *env, jclass cls, jlong N, jobject asum, jlong offAsum, jobject X, jlong offx, jint incx, jobject scratchBuff, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    if (asum == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'asum' is null for clblasDzasum");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offAsum is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasDzasum");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (scratchBuff == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'scratchBuff' is null for clblasDzasum");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasDzasum");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasDzasum(N=%ld, asum=%p, offAsum=%ld, X=%p, offx=%ld, incx=%d, scratchBuff=%p, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, asum, offAsum, X, offx, incx, scratchBuff, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_mem asum_native = nullptr;
    size_t offAsum_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem scratchBuff_native = nullptr;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    N_native = (size_t)N;
    if (!initNative(env, asum, asum_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offAsum_native = (size_t)offAsum;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, scratchBuff, scratchBuff_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasDzasum(N_native, asum_native, offAsum_native, X_native, offx_native, incx_native, scratchBuff_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    // asum is a read-only native pointer
    // offAsum is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // scratchBuff is a read-only native pointer
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Matrix-vector product with a general rectangular matrix and.
*        float elements. Extended version.
*
* Matrix-vector products:
*   - \f$ y \leftarrow \alpha A x + eta y \f$
*   - \f$ y \leftarrow \alpha A^T x + eta y \f$
*
* @param order (in)     Row/column order.
* @param transA (in)    How matrix  A is to be transposed.
* @param M (in)         Number of rows in matrix  A.
* @param N (in)         Number of columns in matrix  A.
* @param alpha (in)     The factor of matrix  A.
* @param A (in)         Buffer object storing matrix  A.
* @param offA (in)      Offset of the first element of the matrix  A in
*                      the buffer object. Counted in elements.
* @param lda (in)       Leading dimension of matrix  A. It cannot be less
*                      than  N when the  order parameter is set to
*                       clblasRowMajor,\n or less than  M when the
*                      parameter is set to  clblasColumnMajor.
* @param x (in)         Buffer object storing vector  x.
* @param offx (in)      Offset of first element of vector  x in buffer object.
*                      Counted in elements.
* @param incx (in)      Increment for the elements of  x. It cannot be zero.
* @param beta (in)      The factor of the vector  y.
* @param y (out)        Buffer object storing the vector  y.
* @param offy (in)      Offset of first element of vector  y in buffer object.
*                      Counted in elements.
* @param incy (in)      Increment for the elements of  y. It cannot be zero.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasInvalidValue if  offA exceeds the size of  A buffer
*     object;
*   - the same error codes as the clblasSgemv() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasSgemvNative(JNIEnv *env, jclass cls, jint order, jint transA, jlong M, jlong N, jfloat alpha, jobject A, jlong offA, jlong lda, jobject x, jlong offx, jint incx, jfloat beta, jobject y, jlong offy, jint incy, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // transA is primitive
    // M is primitive
    // N is primitive
    // alpha is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasSgemv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // lda is primitive
    if (x == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'x' is null for clblasSgemv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    // beta is primitive
    if (y == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'y' is null for clblasSgemv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasSgemv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasSgemv(order=%d, transA=%d, M=%ld, N=%ld, alpha=%f, A=%p, offA=%ld, lda=%ld, x=%p, offx=%ld, incx=%d, beta=%f, y=%p, offy=%ld, incy=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, transA, M, N, alpha, A, offA, lda, x, offx, incx, beta, y, offy, incy, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasTranspose transA_native;
    size_t M_native = 0;
    size_t N_native = 0;
    cl_float alpha_native = 0.0f;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    size_t lda_native = 0;
    cl_mem x_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_float beta_native = 0.0f;
    cl_mem y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    transA_native = (clblasTranspose)transA;
    M_native = (size_t)M;
    N_native = (size_t)N;
    alpha_native = (cl_float)alpha;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    lda_native = (size_t)lda;
    if (!initNative(env, x, x_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    beta_native = (cl_float)beta;
    if (!initNative(env, y, y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasSgemv(order_native, transA_native, M_native, N_native, alpha_native, A_native, offA_native, lda_native, x_native, offx_native, incx_native, beta_native, y_native, offy_native, incy_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // transA is primitive
    // M is primitive
    // N is primitive
    // alpha is primitive
    // A is a read-only native pointer
    // offA is primitive
    // lda is primitive
    // x is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // beta is primitive
    // y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* @example example_sgemv.c
* This is an example of how to use the @ref clblasSgemvEx function.
*/
/**
* Matrix-vector product with a general rectangular matrix and.
*        double elements. Extended version.
*
* Matrix-vector products:
*   - \f$ y \leftarrow \alpha A x + eta y \f$
*   - \f$ y \leftarrow \alpha A^T x + eta y \f$
*
* @param order (in)     Row/column order.
* @param transA (in)    How matrix  A is to be transposed.
* @param M (in)         Number of rows in matrix  A.
* @param N (in)         Number of columns in matrix  A.
* @param alpha (in)     The factor of matrix  A.
* @param A (in)         Buffer object storing matrix  A.
* @param offA (in)      Offset of the first element of  A in the buffer
*                      object. Counted in elements.
* @param lda (in)       Leading dimension of matrix  A. For a detailed description,
*                      see clblasSgemv().
* @param x (in)         Buffer object storing vector  x.
* @param offx (in)      Offset of first element of vector  x in buffer object.
*                      Counted in elements.
* @param incx (in)      Increment for the elements of  x. It cannot be zero.
* @param beta (in)      The factor of the vector  y.
* @param y (out)        Buffer object storing the vector  y.
* @param offy (in)      Offset of first element of vector  y in buffer object.
*                      Counted in elements.
* @param incy (in)      Increment for the elements of  y. It cannot be zero.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasInvalidDevice if a target device does not support the
*     floating point arithmetic with double precision;
*   -  clblasInvalidValue if  offA exceeds the size of  A buffer
*     object;
*   - the same error codes as the clblasSgemv() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasDgemvNative(JNIEnv *env, jclass cls, jint order, jint transA, jlong M, jlong N, jdouble alpha, jobject A, jlong offA, jlong lda, jobject x, jlong offx, jint incx, jdouble beta, jobject y, jlong offy, jint incy, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // transA is primitive
    // M is primitive
    // N is primitive
    // alpha is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasDgemv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // lda is primitive
    if (x == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'x' is null for clblasDgemv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    // beta is primitive
    if (y == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'y' is null for clblasDgemv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasDgemv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasDgemv(order=%d, transA=%d, M=%ld, N=%ld, alpha=%lf, A=%p, offA=%ld, lda=%ld, x=%p, offx=%ld, incx=%d, beta=%lf, y=%p, offy=%ld, incy=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, transA, M, N, alpha, A, offA, lda, x, offx, incx, beta, y, offy, incy, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasTranspose transA_native;
    size_t M_native = 0;
    size_t N_native = 0;
    cl_double alpha_native = 0.0;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    size_t lda_native = 0;
    cl_mem x_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_double beta_native = 0.0;
    cl_mem y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    transA_native = (clblasTranspose)transA;
    M_native = (size_t)M;
    N_native = (size_t)N;
    alpha_native = (cl_double)alpha;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    lda_native = (size_t)lda;
    if (!initNative(env, x, x_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    beta_native = (cl_double)beta;
    if (!initNative(env, y, y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasDgemv(order_native, transA_native, M_native, N_native, alpha_native, A_native, offA_native, lda_native, x_native, offx_native, incx_native, beta_native, y_native, offy_native, incy_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // transA is primitive
    // M is primitive
    // N is primitive
    // alpha is primitive
    // A is a read-only native pointer
    // offA is primitive
    // lda is primitive
    // x is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // beta is primitive
    // y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Matrix-vector product with a general rectangular matrix and.
*        float complex elements. Extended version.
*
* Matrix-vector products:
*   - \f$ y \leftarrow \alpha A x + eta y \f$
*   - \f$ y \leftarrow \alpha A^T x + eta y \f$
*
* @param order (in)     Row/column order.
* @param transA (in)    How matrix  A is to be transposed.
* @param M (in)         Number of rows in matrix  A.
* @param N (in)         Number of columns in matrix  A.
* @param alpha (in)     The factor of matrix  A.
* @param A (in)         Buffer object storing matrix  A.
* @param offA (in)      Offset of the first element of the matrix  A in
*                      the buffer object. Counted in elements
* @param lda (in)       Leading dimension of matrix  A. For a detailed description,
*                      see clblasSgemv().
* @param x (in)         Buffer object storing vector  x.
* @param offx (in)      Offset of first element of vector  x in buffer object.
*                      Counted in elements.
* @param incx (in)      Increment for the elements of  x. It cannot be zero.
* @param beta (in)      The factor of the vector  y.
* @param y (out)        Buffer object storing the vector  y.
* @param offy (in)      Offset of first element of vector  y in buffer object.
*                      Counted in elements.
* @param incy (in)      Increment for the elements of  y. It cannot be zero.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasInvalidValue if  offA exceeds the size of  A buffer
*     object;
*   - the same error codes as the clblasSgemv() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasCgemvNative(JNIEnv *env, jclass cls, jint order, jint transA, jlong M, jlong N, jfloatArray alpha, jobject A, jlong offA, jlong lda, jobject x, jlong offx, jint incx, jfloatArray beta, jobject y, jlong offy, jint incy, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // transA is primitive
    // M is primitive
    // N is primitive
    if (alpha == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'alpha' is null for clblasCgemv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasCgemv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // lda is primitive
    if (x == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'x' is null for clblasCgemv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (beta == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'beta' is null for clblasCgemv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (y == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'y' is null for clblasCgemv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasCgemv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasCgemv(order=%d, transA=%d, M=%ld, N=%ld, alpha=%p, A=%p, offA=%ld, lda=%ld, x=%p, offx=%ld, incx=%d, beta=%p, y=%p, offy=%ld, incy=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, transA, M, N, alpha, A, offA, lda, x, offx, incx, beta, y, offy, incy, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasTranspose transA_native;
    size_t M_native = 0;
    size_t N_native = 0;
    FloatComplex alpha_native;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    size_t lda_native = 0;
    cl_mem x_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    FloatComplex beta_native;
    cl_mem y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    transA_native = (clblasTranspose)transA;
    M_native = (size_t)M;
    N_native = (size_t)N;
    if (!initNative(env, alpha, alpha_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    lda_native = (size_t)lda;
    if (!initNative(env, x, x_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, beta, beta_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, y, y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasCgemv(order_native, transA_native, M_native, N_native, alpha_native, A_native, offA_native, lda_native, x_native, offx_native, incx_native, beta_native, y_native, offy_native, incy_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // transA is primitive
    // M is primitive
    // N is primitive
    if (!releaseNative(env, alpha_native, alpha, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // A is a read-only native pointer
    // offA is primitive
    // lda is primitive
    // x is a read-only native pointer
    // offx is primitive
    // incx is primitive
    if (!releaseNative(env, beta_native, beta, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Matrix-vector product with a general rectangular matrix and.
*        double complex elements. Extended version.
*
* Matrix-vector products:
*   - \f$ y \leftarrow \alpha A x + eta y \f$
*   - \f$ y \leftarrow \alpha A^T x + eta y \f$
*
* @param order (in)     Row/column order.
* @param transA (in)    How matrix  A is to be transposed.
* @param M (in)         Number of rows in matrix  A.
* @param N (in)         Number of columns in matrix  A.
* @param alpha (in)     The factor of matrix  A.
* @param A (in)         Buffer object storing matrix  A.
* @param offA (in)      Offset of the first element of the matrix  A in
*                      the buffer object. Counted in elements.
* @param lda (in)       Leading dimension of matrix  A. For a detailed description,
*                      see clblasSgemv().
* @param x (in)         Buffer object storing vector  x.
* @param offx (in)      Offset of first element of vector  x in buffer object.
*                      Counted in elements.
* @param incx (in)      Increment for the elements of  x. It cannot be zero.
* @param beta (in)      The factor of the vector  y.
* @param y (out)        Buffer object storing the vector  y.
* @param offy (in)      Offset of first element of vector  y in buffer object.
*                      Counted in elements.
* @param incy (in)      Increment for the elements of  y. It cannot be zero.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasInvalidDevice if a target device does not support the
*     floating point arithmetic with double precision;
*   -  clblasInvalidValue if  offA exceeds the size of  A buffer
*     object;
*   - the same error codes as the clblasSgemv() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasZgemvNative(JNIEnv *env, jclass cls, jint order, jint transA, jlong M, jlong N, jdoubleArray alpha, jobject A, jlong offA, jlong lda, jobject x, jlong offx, jint incx, jdoubleArray beta, jobject y, jlong offy, jint incy, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // transA is primitive
    // M is primitive
    // N is primitive
    if (alpha == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'alpha' is null for clblasZgemv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasZgemv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // lda is primitive
    if (x == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'x' is null for clblasZgemv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (beta == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'beta' is null for clblasZgemv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (y == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'y' is null for clblasZgemv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasZgemv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasZgemv(order=%d, transA=%d, M=%ld, N=%ld, alpha=%p, A=%p, offA=%ld, lda=%ld, x=%p, offx=%ld, incx=%d, beta=%p, y=%p, offy=%ld, incy=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, transA, M, N, alpha, A, offA, lda, x, offx, incx, beta, y, offy, incy, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasTranspose transA_native;
    size_t M_native = 0;
    size_t N_native = 0;
    DoubleComplex alpha_native;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    size_t lda_native = 0;
    cl_mem x_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    DoubleComplex beta_native;
    cl_mem y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    transA_native = (clblasTranspose)transA;
    M_native = (size_t)M;
    N_native = (size_t)N;
    if (!initNative(env, alpha, alpha_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    lda_native = (size_t)lda;
    if (!initNative(env, x, x_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, beta, beta_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, y, y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasZgemv(order_native, transA_native, M_native, N_native, alpha_native, A_native, offA_native, lda_native, x_native, offx_native, incx_native, beta_native, y_native, offy_native, incy_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // transA is primitive
    // M is primitive
    // N is primitive
    if (!releaseNative(env, alpha_native, alpha, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // A is a read-only native pointer
    // offA is primitive
    // lda is primitive
    // x is a read-only native pointer
    // offx is primitive
    // incx is primitive
    if (!releaseNative(env, beta_native, beta, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Matrix-vector product with a symmetric matrix and float elements..
*
*
* Matrix-vector products:
* - \f$ y \leftarrow \alpha A x + eta y \f$
*
* @param order (in)     Row/columns order.
* @param uplo (in)      The triangle in matrix being referenced.
* @param N (in)         Number of rows and columns in matrix  A.
* @param alpha (in)     The factor of matrix  A.
* @param A (in)         Buffer object storing matrix  A.
* @param offA (in)      Offset of the first element of the matrix  A in
*                      the buffer object. Counted in elements.
* @param lda (in)       Leading dimension of matrix  A. It cannot less
*                      than  N.
* @param x (in)         Buffer object storing vector  x.
* @param offx (in)      Offset of first element of vector  x in buffer object.
*                      Counted in elements.
* @param incx (in)      Increment for the elements of vector  x. It cannot be zero.
* @param beta (in)      The factor of vector  y.
* @param y (out)        Buffer object storing vector  y.
* @param offy (in)      Offset of first element of vector  y in buffer object.
*                      Counted in elements.
* @param incy (in)      Increment for the elements of vector  y. It cannot be zero.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasInvalidValue if  offA exceeds the size of  A buffer
*     object;
*   - the same error codes as the clblasSgemv() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasSsymvNative(JNIEnv *env, jclass cls, jint order, jint uplo, jlong N, jfloat alpha, jobject A, jlong offA, jlong lda, jobject x, jlong offx, jint incx, jfloat beta, jobject y, jlong offy, jint incy, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // N is primitive
    // alpha is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasSsymv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // lda is primitive
    if (x == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'x' is null for clblasSsymv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    // beta is primitive
    if (y == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'y' is null for clblasSsymv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasSsymv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasSsymv(order=%d, uplo=%d, N=%ld, alpha=%f, A=%p, offA=%ld, lda=%ld, x=%p, offx=%ld, incx=%d, beta=%f, y=%p, offy=%ld, incy=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, N, alpha, A, offA, lda, x, offx, incx, beta, y, offy, incy, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    size_t N_native = 0;
    cl_float alpha_native = 0.0f;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    size_t lda_native = 0;
    cl_mem x_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_float beta_native = 0.0f;
    cl_mem y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    N_native = (size_t)N;
    alpha_native = (cl_float)alpha;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    lda_native = (size_t)lda;
    if (!initNative(env, x, x_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    beta_native = (cl_float)beta;
    if (!initNative(env, y, y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasSsymv(order_native, uplo_native, N_native, alpha_native, A_native, offA_native, lda_native, x_native, offx_native, incx_native, beta_native, y_native, offy_native, incy_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // N is primitive
    // alpha is primitive
    // A is a read-only native pointer
    // offA is primitive
    // lda is primitive
    // x is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // beta is primitive
    // y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* @example example_ssymv.c
* This is an example of how to use the @ref clblasSsymv function.
*/
/**
* Matrix-vector product with a symmetric matrix and double elements..
*
*
* Matrix-vector products:
* - \f$ y \leftarrow \alpha A x + eta y \f$
*
* @param order (in)     Row/columns order.
* @param uplo (in)      The triangle in matrix being referenced.
* @param N (in)         Number of rows and columns in matrix  A.
* @param alpha (in)     The factor of matrix  A.
* @param A (in)         Buffer object storing matrix  A.
* @param offA (in)      Offset of the first element of the matrix  A in
*                      the buffer object. Counted in elements.
* @param lda (in)       Leading dimension of matrix  A. It cannot less
*                      than  N.
* @param x (in)         Buffer object storing vector  x.
* @param offx (in)      Offset of first element of vector  x in buffer object.
*                      Counted in elements.
* @param incx (in)      Increment for the elements of vector  x. It cannot be zero.
* @param beta (in)      The factor of vector  y.
* @param y (out)        Buffer object storing vector  y.
* @param offy (in)      Offset of first element of vector  y in buffer object.
*                      Counted in elements.
* @param incy (in)      Increment for the elements of vector  y. It cannot be zero.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasInvalidDevice if a target device does not support floating
*     point arithmetic with double precision;
*   -  clblasInvalidValue if  offA exceeds the size of  A buffer
*     object;
*   - the same error codes as the clblasSsymv() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasDsymvNative(JNIEnv *env, jclass cls, jint order, jint uplo, jlong N, jdouble alpha, jobject A, jlong offA, jlong lda, jobject x, jlong offx, jint incx, jdouble beta, jobject y, jlong offy, jint incy, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // N is primitive
    // alpha is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasDsymv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // lda is primitive
    if (x == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'x' is null for clblasDsymv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    // beta is primitive
    if (y == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'y' is null for clblasDsymv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasDsymv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasDsymv(order=%d, uplo=%d, N=%ld, alpha=%lf, A=%p, offA=%ld, lda=%ld, x=%p, offx=%ld, incx=%d, beta=%lf, y=%p, offy=%ld, incy=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, N, alpha, A, offA, lda, x, offx, incx, beta, y, offy, incy, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    size_t N_native = 0;
    cl_double alpha_native = 0.0;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    size_t lda_native = 0;
    cl_mem x_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_double beta_native = 0.0;
    cl_mem y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    N_native = (size_t)N;
    alpha_native = (cl_double)alpha;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    lda_native = (size_t)lda;
    if (!initNative(env, x, x_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    beta_native = (cl_double)beta;
    if (!initNative(env, y, y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasDsymv(order_native, uplo_native, N_native, alpha_native, A_native, offA_native, lda_native, x_native, offx_native, incx_native, beta_native, y_native, offy_native, incy_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // N is primitive
    // alpha is primitive
    // A is a read-only native pointer
    // offA is primitive
    // lda is primitive
    // x is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // beta is primitive
    // y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Matrix-vector product with a hermitian matrix and float-complex elements..
*
* Matrix-vector products:
* - \f$ Y \leftarrow \alpha A X + eta Y \f$
*
* @param order (in)     Row/columns order.
* @param uplo (in)      The triangle in matrix being referenced.
* @param N (in)         Number of rows and columns in matrix  A.
* @param alpha (in)     The factor of matrix  A.
* @param A (in)         Buffer object storing matrix  A.
* @param offa		Offset (in) in number of elements for first element in matrix  A.
* @param lda (in)       Leading dimension of matrix  A. It cannot less
*                      than  N.
* @param X (in)         Buffer object storing vector  X.
* @param offx (in)      Offset of first element of vector  X in buffer object.
*                      Counted in elements.
* @param incx (in)      Increment for the elements of vector  X. It cannot be zero.
* @param beta (in)      The factor of vector  Y.
* @param Y (out)        Buffer object storing vector  Y.
* @param offy (in)      Offset of first element of vector  Y in buffer object.
*                      Counted in elements.
* @param incy (in)      Increment for the elements of vector  Y. It cannot be zero.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasNotInitialized if clblasSetup() was not called;
*   -  clblasInvalidValue if invalid parameters are passed:
*     -  N is zero, or
*     - either  incx or  incy is zero, or
*     - any of the leading dimensions is invalid;
*     - the matrix sizes or the vector sizes along with the increments lead to
*       accessing outsize of any of the buffers;
*   -  clblasInvalidMemObject if either  A,  X, or  Y object is
*     invalid, or an image object rather than the buffer one;
*   -  clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   -  clblasInvalidCommandQueue if the passed command queue is invalid;
*   -  clblasInvalidContext if a context a passed command queue belongs to
*     was released;
*   -  clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   -  clblasCompilerNotAvailable if a compiler is not available;
*   -  clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasChemvNative(JNIEnv *env, jclass cls, jint order, jint uplo, jlong N, jfloatArray alpha, jobject A, jlong offa, jlong lda, jobject X, jlong offx, jint incx, jfloatArray beta, jobject Y, jlong offy, jint incy, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // N is primitive
    if (alpha == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'alpha' is null for clblasChemv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasChemv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasChemv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (beta == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'beta' is null for clblasChemv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (Y == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasChemv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasChemv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasChemv(order=%d, uplo=%d, N=%ld, alpha=%p, A=%p, offa=%ld, lda=%ld, X=%p, offx=%ld, incx=%d, beta=%p, Y=%p, offy=%ld, incy=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, N, alpha, A, offa, lda, X, offx, incx, beta, Y, offy, incy, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    size_t N_native = 0;
    FloatComplex alpha_native;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    FloatComplex beta_native;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    N_native = (size_t)N;
    if (!initNative(env, alpha, alpha_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, beta, beta_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasChemv(order_native, uplo_native, N_native, alpha_native, A_native, offa_native, lda_native, X_native, offx_native, incx_native, beta_native, Y_native, offy_native, incy_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // N is primitive
    if (!releaseNative(env, alpha_native, alpha, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    if (!releaseNative(env, beta_native, beta, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Matrix-vector product with a hermitian matrix and double-complex elements..
*
* Matrix-vector products:
* - \f$ Y \leftarrow \alpha A X + eta Y \f$
*
* @param order (in)     Row/columns order.
* @param uplo (in)      The triangle in matrix being referenced.
* @param N (in)         Number of rows and columns in matrix  A.
* @param alpha (in)     The factor of matrix  A.
* @param A (in)         Buffer object storing matrix  A.
* @param offa		Offset (in) in number of elements for first element in matrix  A.
* @param lda (in)       Leading dimension of matrix  A. It cannot less
*                      than  N.
* @param X (in)         Buffer object storing vector  X.
* @param offx (in)      Offset of first element of vector  X in buffer object.
*                      Counted in elements.
* @param incx (in)      Increment for the elements of vector  X. It cannot be zero.
* @param beta (in)      The factor of vector  Y.
* @param Y (out)        Buffer object storing vector  Y.
* @param offy (in)      Offset of first element of vector  Y in buffer object.
*                      Counted in elements.
* @param incy (in)      Increment for the elements of vector  Y. It cannot be zero.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasInvalidDevice if a target device does not support floating
*     point arithmetic with double precision;
*   - the same error codes as the clblasChemv() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasZhemvNative(JNIEnv *env, jclass cls, jint order, jint uplo, jlong N, jdoubleArray alpha, jobject A, jlong offa, jlong lda, jobject X, jlong offx, jint incx, jdoubleArray beta, jobject Y, jlong offy, jint incy, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // N is primitive
    if (alpha == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'alpha' is null for clblasZhemv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasZhemv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasZhemv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (beta == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'beta' is null for clblasZhemv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (Y == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasZhemv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasZhemv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasZhemv(order=%d, uplo=%d, N=%ld, alpha=%p, A=%p, offa=%ld, lda=%ld, X=%p, offx=%ld, incx=%d, beta=%p, Y=%p, offy=%ld, incy=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, N, alpha, A, offa, lda, X, offx, incx, beta, Y, offy, incy, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    size_t N_native = 0;
    DoubleComplex alpha_native;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    DoubleComplex beta_native;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    N_native = (size_t)N;
    if (!initNative(env, alpha, alpha_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, beta, beta_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasZhemv(order_native, uplo_native, N_native, alpha_native, A_native, offa_native, lda_native, X_native, offx_native, incx_native, beta_native, Y_native, offy_native, incy_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // N is primitive
    if (!releaseNative(env, alpha_native, alpha, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    if (!releaseNative(env, beta_native, beta, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* @example example_zhemv.cpp
* Example of how to use the @ref clblasZhemv function.
*/
/**
* Matrix-vector product with a triangular matrix and.
* float elements.
*
* Matrix-vector products:
*   - \f$ X \leftarrow  A X \f$
*   - \f$ X \leftarrow  A^T X \f$
*
* @param order				Row/column (in) order.
* @param uplo				The (in) triangle in matrix being referenced.
* @param trans				How (in) matrix  A is to be transposed.
* @param diag				Specify (in) whether matrix  A is unit triangular.
* @param N					Number (in) of rows/columns in matrix  A.
* @param A					Buffer (in) object storing matrix  A.
* @param offa				Offset (in) in number of elements for first element in matrix  A.
* @param lda				Leading (in) dimension of matrix  A. It cannot be less
*								than  N
* @param X				Buffer (out) object storing vector  X.
* @param offx				Offset (in) in number of elements for first element in vector  X.
* @param incx				Increment (in) for the elements of  X. Must not be zero.
* @param scratchBuff		Temporary (in) cl_mem scratch buffer object which can hold a
*								minimum of (1 + (N-1)*abs(incx)) elements
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasNotInitialized if clblasSetup() was not called;
*   -  clblasInvalidValue if invalid parameters are passed:
*     - either  N or  incx is zero, or
*     - the leading dimension is invalid;
*   -  clblasInvalidMemObject if either  A or  X object is
*     Invalid, or an image object rather than the buffer one;
*   -  clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   -  clblasInvalidCommandQueue if the passed command queue is invalid;
*   -  clblasInvalidContext if a context a passed command queue belongs
*     to was released;
*   -  clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   -  clblasCompilerNotAvailable if a compiler is not available;
*   -  clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasStrmvNative(JNIEnv *env, jclass cls, jint order, jint uplo, jint trans, jint diag, jlong N, jobject A, jlong offa, jlong lda, jobject X, jlong offx, jint incx, jobject scratchBuff, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasStrmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasStrmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (scratchBuff == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'scratchBuff' is null for clblasStrmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasStrmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasStrmv(order=%d, uplo=%d, trans=%d, diag=%d, N=%ld, A=%p, offa=%ld, lda=%ld, X=%p, offx=%ld, incx=%d, scratchBuff=%p, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, trans, diag, N, A, offa, lda, X, offx, incx, scratchBuff, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    clblasTranspose trans_native;
    clblasDiag diag_native;
    size_t N_native = 0;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem scratchBuff_native = nullptr;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    trans_native = (clblasTranspose)trans;
    diag_native = (clblasDiag)diag;
    N_native = (size_t)N;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, scratchBuff, scratchBuff_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasStrmv(order_native, uplo_native, trans_native, diag_native, N_native, A_native, offa_native, lda_native, X_native, offx_native, incx_native, scratchBuff_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // scratchBuff is a read-only native pointer
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* @example example_strmv.c
* Example of how to use the @ref clblasStrmv function.
*/
/**
* Matrix-vector product with a triangular matrix and.
* double elements.
*
* Matrix-vector products:
*   - \f$ X \leftarrow  A X \f$
*   - \f$ X \leftarrow  A^T X \f$
*
* @param order				Row/column (in) order.
* @param uplo				The (in) triangle in matrix being referenced.
* @param trans				How (in) matrix  A is to be transposed.
* @param diag				Specify (in) whether matrix  A is unit triangular.
* @param N					Number (in) of rows/columns in matrix  A.
* @param A					Buffer (in) object storing matrix  A.
* @param offa				Offset (in) in number of elements for first element in matrix  A.
* @param lda				Leading (in) dimension of matrix  A. It cannot be less
*								than  N
* @param X				Buffer (out) object storing vector  X.
* @param offx				Offset (in) in number of elements for first element in vector  X.
* @param incx				Increment (in) for the elements of  X. Must not be zero.
* @param scratchBuff		Temporary (in) cl_mem scratch buffer object which can hold a
*								minimum of (1 + (N-1)*abs(incx)) elements
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasInvalidDevice if a target device does not support floating
*     point arithmetic with double precision;
*   - the same error codes as the clblasStrmv() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasDtrmvNative(JNIEnv *env, jclass cls, jint order, jint uplo, jint trans, jint diag, jlong N, jobject A, jlong offa, jlong lda, jobject X, jlong offx, jint incx, jobject scratchBuff, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasDtrmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasDtrmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (scratchBuff == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'scratchBuff' is null for clblasDtrmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasDtrmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasDtrmv(order=%d, uplo=%d, trans=%d, diag=%d, N=%ld, A=%p, offa=%ld, lda=%ld, X=%p, offx=%ld, incx=%d, scratchBuff=%p, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, trans, diag, N, A, offa, lda, X, offx, incx, scratchBuff, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    clblasTranspose trans_native;
    clblasDiag diag_native;
    size_t N_native = 0;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem scratchBuff_native = nullptr;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    trans_native = (clblasTranspose)trans;
    diag_native = (clblasDiag)diag;
    N_native = (size_t)N;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, scratchBuff, scratchBuff_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasDtrmv(order_native, uplo_native, trans_native, diag_native, N_native, A_native, offa_native, lda_native, X_native, offx_native, incx_native, scratchBuff_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // scratchBuff is a read-only native pointer
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Matrix-vector product with a triangular matrix and.
* float complex elements.
*
* Matrix-vector products:
*   - \f$ X \leftarrow  A X \f$
*   - \f$ X \leftarrow  A^T X \f$
*
* @param order				Row/column (in) order.
* @param uplo				The (in) triangle in matrix being referenced.
* @param trans				How (in) matrix  A is to be transposed.
* @param diag				Specify (in) whether matrix  A is unit triangular.
* @param N					Number (in) of rows/columns in matrix  A.
* @param A					Buffer (in) object storing matrix  A.
* @param offa				Offset (in) in number of elements for first element in matrix  A.
* @param lda				Leading (in) dimension of matrix  A. It cannot be less
*								than  N
* @param X				Buffer (out) object storing vector  X.
* @param offx				Offset (in) in number of elements for first element in vector  X.
* @param incx				Increment (in) for the elements of  X. Must not be zero.
* @param scratchBuff		Temporary (in) cl_mem scratch buffer object which can hold a
*								minimum of (1 + (N-1)*abs(incx)) elements
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return The same result as the clblasStrmv() function.
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasCtrmvNative(JNIEnv *env, jclass cls, jint order, jint uplo, jint trans, jint diag, jlong N, jobject A, jlong offa, jlong lda, jobject X, jlong offx, jint incx, jobject scratchBuff, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasCtrmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasCtrmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (scratchBuff == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'scratchBuff' is null for clblasCtrmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasCtrmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasCtrmv(order=%d, uplo=%d, trans=%d, diag=%d, N=%ld, A=%p, offa=%ld, lda=%ld, X=%p, offx=%ld, incx=%d, scratchBuff=%p, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, trans, diag, N, A, offa, lda, X, offx, incx, scratchBuff, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    clblasTranspose trans_native;
    clblasDiag diag_native;
    size_t N_native = 0;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem scratchBuff_native = nullptr;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    trans_native = (clblasTranspose)trans;
    diag_native = (clblasDiag)diag;
    N_native = (size_t)N;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, scratchBuff, scratchBuff_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasCtrmv(order_native, uplo_native, trans_native, diag_native, N_native, A_native, offa_native, lda_native, X_native, offx_native, incx_native, scratchBuff_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // scratchBuff is a read-only native pointer
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Matrix-vector product with a triangular matrix and.
* double complex elements.
*
* Matrix-vector products:
*   - \f$ X \leftarrow  A X \f$
*   - \f$ X \leftarrow  A^T X \f$
*
* @param order				Row/column (in) order.
* @param uplo				The (in) triangle in matrix being referenced.
* @param trans				How (in) matrix  A is to be transposed.
* @param diag				Specify (in) whether matrix  A is unit triangular.
* @param N					Number (in) of rows/columns in matrix  A.
* @param A					Buffer (in) object storing matrix  A.
* @param offa				Offset (in) in number of elements for first element in matrix  A.
* @param lda				Leading (in) dimension of matrix  A. It cannot be less
*								than  N
* @param X				Buffer (out) object storing vector  X.
* @param offx				Offset (in) in number of elements for first element in vector  X.
* @param incx				Increment (in) for the elements of  X. Must not be zero.
* @param scratchBuff		Temporary (in) cl_mem scratch buffer object which can hold a
*								minimum of (1 + (N-1)*abs(incx)) elements
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return The same result as the clblasDtrmv() function.
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasZtrmvNative(JNIEnv *env, jclass cls, jint order, jint uplo, jint trans, jint diag, jlong N, jobject A, jlong offa, jlong lda, jobject X, jlong offx, jint incx, jobject scratchBuff, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasZtrmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasZtrmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (scratchBuff == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'scratchBuff' is null for clblasZtrmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasZtrmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasZtrmv(order=%d, uplo=%d, trans=%d, diag=%d, N=%ld, A=%p, offa=%ld, lda=%ld, X=%p, offx=%ld, incx=%d, scratchBuff=%p, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, trans, diag, N, A, offa, lda, X, offx, incx, scratchBuff, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    clblasTranspose trans_native;
    clblasDiag diag_native;
    size_t N_native = 0;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem scratchBuff_native = nullptr;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    trans_native = (clblasTranspose)trans;
    diag_native = (clblasDiag)diag;
    N_native = (size_t)N;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, scratchBuff, scratchBuff_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasZtrmv(order_native, uplo_native, trans_native, diag_native, N_native, A_native, offa_native, lda_native, X_native, offx_native, incx_native, scratchBuff_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // scratchBuff is a read-only native pointer
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* solving triangular matrix problems with float elements..
*
* Matrix-vector products:
*   - \f$ A X \leftarrow  X \f$
*   - \f$ A^T X \leftarrow  X \f$
*
* @param order				Row/column (in) order.
* @param uplo				The (in) triangle in matrix being referenced.
* @param trans				How (in) matrix  A is to be transposed.
* @param diag				Specify (in) whether matrix  A is unit triangular.
* @param N					Number (in) of rows/columns in matrix  A.
* @param A					Buffer (in) object storing matrix  A.
* @param offa				Offset (in) in number of elements for first element in matrix  A.
* @param lda				Leading (in) dimension of matrix  A. It cannot be less
*								than  N
* @param X				Buffer (out) object storing vector  X.
* @param offx				Offset (in) in number of elements for first element in vector  X.
* @param incx				Increment (in) for the elements of  X. Must not be zero.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasNotInitialized if clblasSetup() was not called;
*   -  clblasInvalidValue if invalid parameters are passed:
*     - either  N or  incx is zero, or
*     - the leading dimension is invalid;
*   -  clblasInvalidMemObject if either  A or  X object is
*     Invalid, or an image object rather than the buffer one;
*   -  clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   -  clblasInvalidCommandQueue if the passed command queue is invalid;
*   -  clblasInvalidContext if a context a passed command queue belongs
*     to was released;
*   -  clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   -  clblasCompilerNotAvailable if a compiler is not available;
*   -  clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasStrsvNative(JNIEnv *env, jclass cls, jint order, jint uplo, jint trans, jint diag, jlong N, jobject A, jlong offa, jlong lda, jobject X, jlong offx, jint incx, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasStrsv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasStrsv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasStrsv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasStrsv(order=%d, uplo=%d, trans=%d, diag=%d, N=%ld, A=%p, offa=%ld, lda=%ld, X=%p, offx=%ld, incx=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, trans, diag, N, A, offa, lda, X, offx, incx, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    clblasTranspose trans_native;
    clblasDiag diag_native;
    size_t N_native = 0;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    trans_native = (clblasTranspose)trans;
    diag_native = (clblasDiag)diag;
    N_native = (size_t)N;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasStrsv(order_native, uplo_native, trans_native, diag_native, N_native, A_native, offa_native, lda_native, X_native, offx_native, incx_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* @example example_strsv.c
* Example of how to use the @ref clblasStrsv function.
*/
/**
* solving triangular matrix problems with double elements..
*
* Matrix-vector products:
*   - \f$ A X \leftarrow  X \f$
*   - \f$ A^T X \leftarrow  X \f$
*
* @param order				Row/column (in) order.
* @param uplo				The (in) triangle in matrix being referenced.
* @param trans				How (in) matrix  A is to be transposed.
* @param diag				Specify (in) whether matrix  A is unit triangular.
* @param N					Number (in) of rows/columns in matrix  A.
* @param A					Buffer (in) object storing matrix  A.
* @param offa				Offset (in) in number of elements for first element in matrix  A.
* @param lda				Leading (in) dimension of matrix  A. It cannot be less
*								than  N
* @param X				Buffer (out) object storing vector  X.
* @param offx				Offset (in) in number of elements for first element in vector  X.
* @param incx				Increment (in) for the elements of  X. Must not be zero.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasInvalidDevice if a target device does not support floating
*     point arithmetic with double precision;
*   - the same error codes as the clblasStrsv() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasDtrsvNative(JNIEnv *env, jclass cls, jint order, jint uplo, jint trans, jint diag, jlong N, jobject A, jlong offa, jlong lda, jobject X, jlong offx, jint incx, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasDtrsv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasDtrsv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasDtrsv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasDtrsv(order=%d, uplo=%d, trans=%d, diag=%d, N=%ld, A=%p, offa=%ld, lda=%ld, X=%p, offx=%ld, incx=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, trans, diag, N, A, offa, lda, X, offx, incx, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    clblasTranspose trans_native;
    clblasDiag diag_native;
    size_t N_native = 0;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    trans_native = (clblasTranspose)trans;
    diag_native = (clblasDiag)diag;
    N_native = (size_t)N;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasDtrsv(order_native, uplo_native, trans_native, diag_native, N_native, A_native, offa_native, lda_native, X_native, offx_native, incx_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* solving triangular matrix problems with float-complex elements..
*
* Matrix-vector products:
*   - \f$ A X \leftarrow  X \f$
*   - \f$ A^T X \leftarrow  X \f$
*
* @param order				Row/column (in) order.
* @param uplo				The (in) triangle in matrix being referenced.
* @param trans				How (in) matrix  A is to be transposed.
* @param diag				Specify (in) whether matrix  A is unit triangular.
* @param N					Number (in) of rows/columns in matrix  A.
* @param A					Buffer (in) object storing matrix  A.
* @param offa				Offset (in) in number of elements for first element in matrix  A.
* @param lda				Leading (in) dimension of matrix  A. It cannot be less
*								than  N
* @param X				Buffer (out) object storing vector  X.
* @param offx				Offset (in) in number of elements for first element in vector  X.
* @param incx				Increment (in) for the elements of  X. Must not be zero.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return The same result as the clblasStrsv() function.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasCtrsvNative(JNIEnv *env, jclass cls, jint order, jint uplo, jint trans, jint diag, jlong N, jobject A, jlong offa, jlong lda, jobject X, jlong offx, jint incx, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasCtrsv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasCtrsv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasCtrsv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasCtrsv(order=%d, uplo=%d, trans=%d, diag=%d, N=%ld, A=%p, offa=%ld, lda=%ld, X=%p, offx=%ld, incx=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, trans, diag, N, A, offa, lda, X, offx, incx, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    clblasTranspose trans_native;
    clblasDiag diag_native;
    size_t N_native = 0;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    trans_native = (clblasTranspose)trans;
    diag_native = (clblasDiag)diag;
    N_native = (size_t)N;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasCtrsv(order_native, uplo_native, trans_native, diag_native, N_native, A_native, offa_native, lda_native, X_native, offx_native, incx_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* solving triangular matrix problems with double-complex elements..
*
* Matrix-vector products:
*   - \f$ A X \leftarrow  X \f$
*   - \f$ A^T X \leftarrow  X \f$
*
* @param order				Row/column (in) order.
* @param uplo				The (in) triangle in matrix being referenced.
* @param trans				How (in) matrix  A is to be transposed.
* @param diag				Specify (in) whether matrix  A is unit triangular.
* @param N					Number (in) of rows/columns in matrix  A.
* @param A					Buffer (in) object storing matrix  A.
* @param offa				Offset (in) in number of elements for first element in matrix  A.
* @param lda				Leading (in) dimension of matrix  A. It cannot be less
*								than  N
* @param X				Buffer (out) object storing vector  X.
* @param offx				Offset (in) in number of elements for first element in vector  X.
* @param incx				Increment (in) for the elements of  X. Must not be zero.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return The same result as the clblasDtrsv() function.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasZtrsvNative(JNIEnv *env, jclass cls, jint order, jint uplo, jint trans, jint diag, jlong N, jobject A, jlong offa, jlong lda, jobject X, jlong offx, jint incx, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasZtrsv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasZtrsv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasZtrsv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasZtrsv(order=%d, uplo=%d, trans=%d, diag=%d, N=%ld, A=%p, offa=%ld, lda=%ld, X=%p, offx=%ld, incx=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, trans, diag, N, A, offa, lda, X, offx, incx, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    clblasTranspose trans_native;
    clblasDiag diag_native;
    size_t N_native = 0;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    trans_native = (clblasTranspose)trans;
    diag_native = (clblasDiag)diag;
    N_native = (size_t)N;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasZtrsv(order_native, uplo_native, trans_native, diag_native, N_native, A_native, offa_native, lda_native, X_native, offx_native, incx_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* vector-vector product with float elements and.
* performs the rank 1 operation A
*
* Vector-vector products:
*   - \f$ A \leftarrow \alpha X Y^T + A \f$
*
* @param order (in)     Row/column order.
* @param M (in)         Number of rows in matrix  A.
* @param N (in)         Number of columns in matrix  A.
* @param alpha (in)     specifies the scalar alpha.
* @param X (in)         Buffer object storing vector  X.
* @param offx (in)      Offset in number of elements for the first element in vector  X.
* @param incx (in)      Increment for the elements of  X. Must not be zero.
* @param Y (in)         Buffer object storing vector  Y.
* @param offy (in)      Offset in number of elements for the first element in vector  Y.
* @param incy (in)      Increment for the elements of  Y. Must not be zero.
* @param A (out) 		Buffer object storing matrix  A. On exit, A is
*				        overwritten by the updated matrix.
* @param offa (in)      Offset in number of elements for the first element in matrix  A.
* @param lda (in)       Leading dimension of matrix  A. It cannot be less
*                      than  N when the  order parameter is set to
*                       clblasRowMajor,\n or less than  M when the
*                      parameter is set to  clblasColumnMajor.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasNotInitialized if clblasSetup() was not called;
*   -  clblasInvalidValue if invalid parameters are passed:
*     -  M,  N or
*	   - either  incx or  incy is zero, or
*     - a leading dimension is invalid;
*   -  clblasInvalidMemObject if A, X, or Y object is invalid,
*     or an image object rather than the buffer one;
*   -  clblasOutOfResources if you use image-based function implementation
*     and no suitable scratch image available;
*   -  clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   -  clblasInvalidCommandQueue if the passed command queue is invalid;
*   -  clblasInvalidContext if a context a passed command queue belongs to
*     was released;
*   -  clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   -  clblasCompilerNotAvailable if a compiler is not available;
*   -  clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasSgerNative(JNIEnv *env, jclass cls, jint order, jlong M, jlong N, jfloat alpha, jobject X, jlong offx, jint incx, jobject Y, jlong offy, jint incy, jobject A, jlong offa, jlong lda, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // M is primitive
    // N is primitive
    // alpha is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasSger");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (Y == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasSger");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasSger");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasSger");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasSger(order=%d, M=%ld, N=%ld, alpha=%f, X=%p, offx=%ld, incx=%d, Y=%p, offy=%ld, incy=%d, A=%p, offa=%ld, lda=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, M, N, alpha, X, offx, incx, Y, offy, incy, A, offa, lda, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    size_t M_native = 0;
    size_t N_native = 0;
    cl_float alpha_native = 0.0f;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    M_native = (size_t)M;
    N_native = (size_t)N;
    alpha_native = (cl_float)alpha;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasSger(order_native, M_native, N_native, alpha_native, X_native, offx_native, incx_native, Y_native, offy_native, incy_native, A_native, offa_native, lda_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // M is primitive
    // N is primitive
    // alpha is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* @example example_sger.c
* Example of how to use the @ref clblasSger function.
*/
/**
* vector-vector product with double elements and.
* performs the rank 1 operation A
*
* Vector-vector products:
*   - \f$ A \leftarrow \alpha X Y^T + A \f$
*
* @param order (in)     Row/column order.
* @param M (in)         Number of rows in matrix  A.
* @param N (in)         Number of columns in matrix  A.
* @param alpha (in)     specifies the scalar alpha.
* @param X (in)         Buffer object storing vector  X.
* @param offx (in)      Offset in number of elements for the first element in vector  X.
* @param incx (in)      Increment for the elements of  X. Must not be zero.
* @param Y (in)         Buffer object storing vector  Y.
* @param offy (in)      Offset in number of elements for the first element in vector  Y.
* @param incy (in)      Increment for the elements of  Y. Must not be zero.
* @param A (out) 		Buffer object storing matrix  A. On exit, A is
*				        overwritten by the updated matrix.
* @param offa (in)      Offset in number of elements for the first element in matrix  A.
* @param lda (in)       Leading dimension of matrix  A. It cannot be less
*                      than  N when the  order parameter is set to
*                       clblasRowMajor,\n or less than  M when the
*                      parameter is set to  clblasColumnMajor.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasInvalidDevice if a target device does not support floating
*     point arithmetic with double precision;
*   - the same error codes as the clblasSger() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasDgerNative(JNIEnv *env, jclass cls, jint order, jlong M, jlong N, jdouble alpha, jobject X, jlong offx, jint incx, jobject Y, jlong offy, jint incy, jobject A, jlong offa, jlong lda, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // M is primitive
    // N is primitive
    // alpha is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasDger");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (Y == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasDger");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasDger");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasDger");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasDger(order=%d, M=%ld, N=%ld, alpha=%lf, X=%p, offx=%ld, incx=%d, Y=%p, offy=%ld, incy=%d, A=%p, offa=%ld, lda=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, M, N, alpha, X, offx, incx, Y, offy, incy, A, offa, lda, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    size_t M_native = 0;
    size_t N_native = 0;
    cl_double alpha_native = 0.0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    M_native = (size_t)M;
    N_native = (size_t)N;
    alpha_native = (cl_double)alpha;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasDger(order_native, M_native, N_native, alpha_native, X_native, offx_native, incx_native, Y_native, offy_native, incy_native, A_native, offa_native, lda_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // M is primitive
    // N is primitive
    // alpha is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* vector-vector product with float complex elements and.
* performs the rank 1 operation A
*
* Vector-vector products:
*   - \f$ A \leftarrow \alpha X Y^T + A \f$
*
* @param order (in)     Row/column order.
* @param M (in)         Number of rows in matrix  A.
* @param N (in)         Number of columns in matrix  A.
* @param alpha (in)     specifies the scalar alpha.
* @param X (in)         Buffer object storing vector  X.
* @param offx (in)      Offset in number of elements for the first element in vector  X.
* @param incx (in)      Increment for the elements of  X. Must not be zero.
* @param Y (in)         Buffer object storing vector  Y.
* @param offy (in)      Offset in number of elements for the first element in vector  Y.
* @param incy (in)      Increment for the elements of  Y. Must not be zero.
* @param A (out) 		Buffer object storing matrix  A. On exit, A is
*				        overwritten by the updated matrix.
* @param offa (in)      Offset in number of elements for the first element in matrix  A.
* @param lda (in)       Leading dimension of matrix  A. It cannot be less
*                      than  N when the  order parameter is set to
*                       clblasRowMajor,\n or less than  M when the
*                      parameter is set to  clblasColumnMajor.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasNotInitialized if clblasSetup() was not called;
*   -  clblasInvalidValue if invalid parameters are passed:
*     -  M,  N or
*	   - either  incx or  incy is zero, or
*     - a leading dimension is invalid;
*   -  clblasInvalidMemObject if A, X, or Y object is invalid,
*     or an image object rather than the buffer one;
*   -  clblasOutOfResources if you use image-based function implementation
*     and no suitable scratch image available;
*   -  clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   -  clblasInvalidCommandQueue if the passed command queue is invalid;
*   -  clblasInvalidContext if a context a passed command queue belongs to
*     was released;
*   -  clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   -  clblasCompilerNotAvailable if a compiler is not available;
*   -  clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasCgeruNative(JNIEnv *env, jclass cls, jint order, jlong M, jlong N, jfloatArray alpha, jobject X, jlong offx, jint incx, jobject Y, jlong offy, jint incy, jobject A, jlong offa, jlong lda, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // M is primitive
    // N is primitive
    if (alpha == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'alpha' is null for clblasCgeru");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasCgeru");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (Y == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasCgeru");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasCgeru");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasCgeru");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasCgeru(order=%d, M=%ld, N=%ld, alpha=%p, X=%p, offx=%ld, incx=%d, Y=%p, offy=%ld, incy=%d, A=%p, offa=%ld, lda=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, M, N, alpha, X, offx, incx, Y, offy, incy, A, offa, lda, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    size_t M_native = 0;
    size_t N_native = 0;
    cl_float2 alpha_native;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    M_native = (size_t)M;
    N_native = (size_t)N;
    if (!initNative(env, alpha, alpha_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasCgeru(order_native, M_native, N_native, alpha_native, X_native, offx_native, incx_native, Y_native, offy_native, incy_native, A_native, offa_native, lda_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // M is primitive
    // N is primitive
    if (!releaseNative(env, alpha_native, alpha, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* vector-vector product with double complex elements and.
* performs the rank 1 operation A
*
* Vector-vector products:
*   - \f$ A \leftarrow \alpha X Y^T + A \f$
*
* @param order (in)     Row/column order.
* @param M (in)         Number of rows in matrix  A.
* @param N (in)         Number of columns in matrix  A.
* @param alpha (in)     specifies the scalar alpha.
* @param X (in)         Buffer object storing vector  X.
* @param offx (in)      Offset in number of elements for the first element in vector  X.
* @param incx (in)      Increment for the elements of  X. Must not be zero.
* @param Y (in)         Buffer object storing vector  Y.
* @param offy (in)      Offset in number of elements for the first element in vector  Y.
* @param incy (in)      Increment for the elements of  Y. Must not be zero.
* @param A		 (out)   Buffer object storing matrix  A. On exit, A is
*				        overwritten by the updated matrix.
* @param offa (in)      Offset in number of elements for the first element in matrix  A.
* @param lda (in)       Leading dimension of matrix  A. It cannot be less
*                      than  N when the  order parameter is set to
*                       clblasRowMajor,\n or less than  M when the
*                      parameter is set to  clblasColumnMajor.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasInvalidDevice if a target device does not support floating
*     point arithmetic with double precision;
*   - the same error codes as the clblasCgeru() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasZgeruNative(JNIEnv *env, jclass cls, jint order, jlong M, jlong N, jdoubleArray alpha, jobject X, jlong offx, jint incx, jobject Y, jlong offy, jint incy, jobject A, jlong offa, jlong lda, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // M is primitive
    // N is primitive
    if (alpha == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'alpha' is null for clblasZgeru");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasZgeru");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (Y == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasZgeru");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasZgeru");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasZgeru");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasZgeru(order=%d, M=%ld, N=%ld, alpha=%p, X=%p, offx=%ld, incx=%d, Y=%p, offy=%ld, incy=%d, A=%p, offa=%ld, lda=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, M, N, alpha, X, offx, incx, Y, offy, incy, A, offa, lda, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    size_t M_native = 0;
    size_t N_native = 0;
    cl_double2 alpha_native;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    M_native = (size_t)M;
    N_native = (size_t)N;
    if (!initNative(env, alpha, alpha_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasZgeru(order_native, M_native, N_native, alpha_native, X_native, offx_native, incx_native, Y_native, offy_native, incy_native, A_native, offa_native, lda_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // M is primitive
    // N is primitive
    if (!releaseNative(env, alpha_native, alpha, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* vector-vector product with float complex elements and.
* performs the rank 1 operation A
*
* Vector-vector products:
*   - \f$ A \leftarrow \alpha X Y^H + A \f$
*
* @param order (in)     Row/column order.
* @param M (in)         Number of rows in matrix  A.
* @param N (in)         Number of columns in matrix  A.
* @param alpha (in)     specifies the scalar alpha.
* @param X (in)         Buffer object storing vector  X.
* @param offx (in)      Offset in number of elements for the first element in vector  X.
* @param incx (in)      Increment for the elements of  X. Must not be zero.
* @param Y (in)         Buffer object storing vector  Y.
* @param offy (in)      Offset in number of elements for the first element in vector  Y.
* @param incy (in)      Increment for the elements of  Y. Must not be zero.
* @param A (out) 	    Buffer object storing matrix  A. On exit, A is
*				        overwritten by the updated matrix.
* @param offa (in)      Offset in number of elements for the first element in matrix  A.
* @param lda (in)       Leading dimension of matrix  A. It cannot be less
*                      than  N when the  order parameter is set to
*                       clblasRowMajor,\n or less than  M when the
*                      parameter is set to  clblasColumnMajor.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasNotInitialized if clblasSetup() was not called;
*   -  clblasInvalidValue if invalid parameters are passed:
*     -  M,  N or
*	   - either  incx or  incy is zero, or
*     - a leading dimension is invalid;
*   -  clblasInvalidMemObject if A, X, or Y object is invalid,
*     or an image object rather than the buffer one;
*   -  clblasOutOfResources if you use image-based function implementation
*     and no suitable scratch image available;
*   -  clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   -  clblasInvalidCommandQueue if the passed command queue is invalid;
*   -  clblasInvalidContext if a context a passed command queue belongs to
*     was released;
*   -  clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   -  clblasCompilerNotAvailable if a compiler is not available;
*   -  clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasCgercNative(JNIEnv *env, jclass cls, jint order, jlong M, jlong N, jfloatArray alpha, jobject X, jlong offx, jint incx, jobject Y, jlong offy, jint incy, jobject A, jlong offa, jlong lda, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // M is primitive
    // N is primitive
    if (alpha == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'alpha' is null for clblasCgerc");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasCgerc");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (Y == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasCgerc");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasCgerc");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasCgerc");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasCgerc(order=%d, M=%ld, N=%ld, alpha=%p, X=%p, offx=%ld, incx=%d, Y=%p, offy=%ld, incy=%d, A=%p, offa=%ld, lda=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, M, N, alpha, X, offx, incx, Y, offy, incy, A, offa, lda, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    size_t M_native = 0;
    size_t N_native = 0;
    cl_float2 alpha_native;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    M_native = (size_t)M;
    N_native = (size_t)N;
    if (!initNative(env, alpha, alpha_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasCgerc(order_native, M_native, N_native, alpha_native, X_native, offx_native, incx_native, Y_native, offy_native, incy_native, A_native, offa_native, lda_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // M is primitive
    // N is primitive
    if (!releaseNative(env, alpha_native, alpha, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* vector-vector product with double complex elements and.
* performs the rank 1 operation A
*
* Vector-vector products:
*   - \f$ A \leftarrow \alpha X Y^H + A \f$
*
* @param order (in)     Row/column order.
* @param M (in)         Number of rows in matrix  A.
* @param N (in)         Number of columns in matrix  A.
* @param alpha (in)     specifies the scalar alpha.
* @param X (in)         Buffer object storing vector  X.
* @param offx (in)      Offset in number of elements for the first element in vector  X.
* @param incx (in)      Increment for the elements of  X. Must not be zero.
* @param Y (in)         Buffer object storing vector  Y.
* @param offy (in)      Offset in number of elements for the first element in vector  Y.
* @param incy (in)      Increment for the elements of  Y. Must not be zero.
* @param A		Buffer (out) object storing matrix  A. On exit, A is
*				        overwritten by the updated matrix.
* @param offa (in)      Offset in number of elements for the first element in matrix  A.
* @param lda (in)       Leading dimension of matrix  A. It cannot be less
*                      than  N when the  order parameter is set to
*                       clblasRowMajor,\n or less than  M when the
*                      parameter is set to  clblasColumnMajor.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasInvalidDevice if a target device does not support floating
*     point arithmetic with double precision;
*   - the same error codes as the clblasCgerc() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasZgercNative(JNIEnv *env, jclass cls, jint order, jlong M, jlong N, jdoubleArray alpha, jobject X, jlong offx, jint incx, jobject Y, jlong offy, jint incy, jobject A, jlong offa, jlong lda, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // M is primitive
    // N is primitive
    if (alpha == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'alpha' is null for clblasZgerc");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasZgerc");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (Y == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasZgerc");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasZgerc");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasZgerc");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasZgerc(order=%d, M=%ld, N=%ld, alpha=%p, X=%p, offx=%ld, incx=%d, Y=%p, offy=%ld, incy=%d, A=%p, offa=%ld, lda=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, M, N, alpha, X, offx, incx, Y, offy, incy, A, offa, lda, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    size_t M_native = 0;
    size_t N_native = 0;
    cl_double2 alpha_native;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    M_native = (size_t)M;
    N_native = (size_t)N;
    if (!initNative(env, alpha, alpha_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasZgerc(order_native, M_native, N_native, alpha_native, X_native, offx_native, incx_native, Y_native, offy_native, incy_native, A_native, offa_native, lda_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // M is primitive
    // N is primitive
    if (!releaseNative(env, alpha_native, alpha, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Symmetric rank 1 operation with a general triangular matrix and.
* float elements.
*
* Symmetric rank 1 operation:
*   - \f$ A \leftarrow \alpha x x^T + A \f$
*
* @param order (in)     Row/column order.
* @param uplo (in)      The triangle in matrix being referenced.
* @param N (in)         Number of columns in matrix  A.
* @param alpha (in)     The factor of matrix  A.
* @param X (in)         Buffer object storing vector  X.
* @param offx (in)      Offset of first element of vector  X in buffer object.
* @param incx (in)      Increment for the elements of  X. Must not be zero.
* @param A (out) 	    Buffer object storing matrix  A.
* @param offa (in)      Offset of first element of matrix  A in buffer object.
* @param lda (in)       Leading dimension of matrix  A. It cannot be less
*                      than  N.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasNotInitialized if clblasSetup() was not called;
*   -  clblasInvalidValue if invalid parameters are passed:
*     -  N is zero, or
*     - either  incx is zero, or
*     - the leading dimension is invalid;
*   -  clblasInvalidMemObject if either  A,  X object is
*     Invalid, or an image object rather than the buffer one;
*   -  clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   -  clblasInvalidCommandQueue if the passed command queue is invalid;
*   -  clblasInvalidContext if a context a passed command queue belongs
*     to was released;
*   -  clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   -  clblasCompilerNotAvailable if a compiler is not available;
*   -  clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasSsyrNative(JNIEnv *env, jclass cls, jint order, jint uplo, jlong N, jfloat alpha, jobject X, jlong offx, jint incx, jobject A, jlong offa, jlong lda, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // N is primitive
    // alpha is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasSsyr");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasSsyr");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasSsyr");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasSsyr(order=%d, uplo=%d, N=%ld, alpha=%f, X=%p, offx=%ld, incx=%d, A=%p, offa=%ld, lda=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, N, alpha, X, offx, incx, A, offa, lda, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    size_t N_native = 0;
    cl_float alpha_native = 0.0f;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    N_native = (size_t)N;
    alpha_native = (cl_float)alpha;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasSsyr(order_native, uplo_native, N_native, alpha_native, X_native, offx_native, incx_native, A_native, offa_native, lda_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // N is primitive
    // alpha is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Symmetric rank 1 operation with a general triangular matrix and.
* double elements.
*
* Symmetric rank 1 operation:
*   - \f$ A \leftarrow \alpha x x^T + A \f$
*
* @param order (in)     Row/column order.
* @param uplo (in)      The triangle in matrix being referenced.
* @param N (in)         Number of columns in matrix  A.
* @param alpha (in)     The factor of matrix  A.
* @param X (in)         Buffer object storing vector  X.
* @param offx (in)      Offset of first element of vector  X in buffer object.
* @param incx (in)      Increment for the elements of  X. Must not be zero.
* @param A		Buffer (out) object storing matrix  A.
* @param offa (in)      Offset of first element of matrix  A in buffer object.
* @param lda (in)       Leading dimension of matrix  A. It cannot be less
*                      than  N.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasInvalidDevice if a target device does not support floating
*     point arithmetic with double precision;
*   - the same error codes as the clblasSsyr() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasDsyrNative(JNIEnv *env, jclass cls, jint order, jint uplo, jlong N, jdouble alpha, jobject X, jlong offx, jint incx, jobject A, jlong offa, jlong lda, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // N is primitive
    // alpha is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasDsyr");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasDsyr");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasDsyr");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasDsyr(order=%d, uplo=%d, N=%ld, alpha=%lf, X=%p, offx=%ld, incx=%d, A=%p, offa=%ld, lda=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, N, alpha, X, offx, incx, A, offa, lda, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    size_t N_native = 0;
    cl_double alpha_native = 0.0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    N_native = (size_t)N;
    alpha_native = (cl_double)alpha;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasDsyr(order_native, uplo_native, N_native, alpha_native, X_native, offx_native, incx_native, A_native, offa_native, lda_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // N is primitive
    // alpha is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* hermitian rank 1 operation with a general triangular matrix and.
* float-complex elements.
*
* hermitian rank 1 operation:
*   - \f$ A \leftarrow \alpha X X^H + A \f$
*
* @param order (in)     Row/column order.
* @param uplo (in)      The triangle in matrix being referenced.
* @param N (in)         Number of columns in matrix  A.
* @param alpha (in)     The factor of matrix  A (a scalar float value)
* @param X (in)         Buffer object storing vector  X.
* @param offx (in)      Offset in number of elements for the first element in vector  X.
* @param incx (in)      Increment for the elements of  X. Must not be zero.
* @param A		Buffer (out) object storing matrix  A.
* @param offa (in)      Offset in number of elements for the first element in matrix  A.
* @param lda (in)       Leading dimension of matrix  A. It cannot be less
*                      than  N.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasNotInitialized if clblasSetup() was not called;
*   -  clblasInvalidValue if invalid parameters are passed:
*     -  N is zero, or
*     - either  incx is zero, or
*     - the leading dimension is invalid;
*   -  clblasInvalidMemObject if either  A,  X object is
*     Invalid, or an image object rather than the buffer one;
*   -  clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   -  clblasInvalidCommandQueue if the passed command queue is invalid;
*   -  clblasInvalidContext if a context a passed command queue belongs
*     to was released;
*   -  clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   -  clblasCompilerNotAvailable if a compiler is not available;
*   -  clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasCherNative(JNIEnv *env, jclass cls, jint order, jint uplo, jlong N, jfloat alpha, jobject X, jlong offx, jint incx, jobject A, jlong offa, jlong lda, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // N is primitive
    // alpha is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasCher");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasCher");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasCher");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasCher(order=%d, uplo=%d, N=%ld, alpha=%f, X=%p, offx=%ld, incx=%d, A=%p, offa=%ld, lda=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, N, alpha, X, offx, incx, A, offa, lda, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    size_t N_native = 0;
    cl_float alpha_native = 0.0f;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    N_native = (size_t)N;
    alpha_native = (cl_float)alpha;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasCher(order_native, uplo_native, N_native, alpha_native, X_native, offx_native, incx_native, A_native, offa_native, lda_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // N is primitive
    // alpha is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* @example example_cher.c
* Example of how to use the @ref clblasCher function.
*/
/**
* hermitian rank 1 operation with a general triangular matrix and.
* double-complex elements.
*
* hermitian rank 1 operation:
*   - \f$ A \leftarrow \alpha X X^H + A \f$
*
* @param order (in)     Row/column order.
* @param uplo (in)      The triangle in matrix being referenced.
* @param N (in)         Number of columns in matrix  A.
* @param alpha (in)     The factor of matrix  A (a scalar double value)
* @param X (in)         Buffer object storing vector  X.
* @param offx (in)      Offset in number of elements for the first element in vector  X.
* @param incx (in)      Increment for the elements of  X. Must not be zero.
* @param A		Buffer (out) object storing matrix  A.
* @param offa (in)      Offset in number of elements for the first element in matrix  A.
* @param lda (in)       Leading dimension of matrix  A. It cannot be less
*                      than  N.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasInvalidDevice if a target device does not support floating
*     point arithmetic with double precision;
*   - the same error codes as the clblasCher() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasZherNative(JNIEnv *env, jclass cls, jint order, jint uplo, jlong N, jdouble alpha, jobject X, jlong offx, jint incx, jobject A, jlong offa, jlong lda, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // N is primitive
    // alpha is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasZher");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasZher");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasZher");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasZher(order=%d, uplo=%d, N=%ld, alpha=%lf, X=%p, offx=%ld, incx=%d, A=%p, offa=%ld, lda=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, N, alpha, X, offx, incx, A, offa, lda, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    size_t N_native = 0;
    cl_double alpha_native = 0.0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    N_native = (size_t)N;
    alpha_native = (cl_double)alpha;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasZher(order_native, uplo_native, N_native, alpha_native, X_native, offx_native, incx_native, A_native, offa_native, lda_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // N is primitive
    // alpha is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Symmetric rank 2 operation with a general triangular matrix and.
* float elements.
*
* Symmetric rank 2 operation:
*   - \f$ A \leftarrow \alpha x y^T + \alpha y x^T + A \f$
*
* @param order (in)     Row/column order.
* @param uplo (in)      The triangle in matrix being referenced.
* @param N (in)         Number of columns in matrix  A.
* @param alpha (in)     The factor of matrix  A.
* @param X (in)         Buffer object storing vector  X.
* @param offx (in)      Offset of first element of vector  X in buffer object.
* @param incx (in)      Increment for the elements of  X. Must not be zero.
* @param Y (in)         Buffer object storing vector  Y.
* @param offy (in)      Offset of first element of vector  Y in buffer object.
* @param incy (in)      Increment for the elements of  Y. Must not be zero.
* @param A (out) 	    Buffer object storing matrix  A.
* @param offa (in)      Offset of first element of matrix  A in buffer object.
* @param lda (in)       Leading dimension of matrix  A. It cannot be less
*                      than  N.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasNotInitialized if clblasSetup() was not called;
*   -  clblasInvalidValue if invalid parameters are passed:
*     - either  N is zero, or
*     - either  incx or  incy is zero, or
*     - the leading dimension is invalid;
*   -  clblasInvalidMemObject if either  A,  X, or  Y object is
*     Invalid, or an image object rather than the buffer one;
*   -  clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   -  clblasInvalidCommandQueue if the passed command queue is invalid;
*   -  clblasInvalidContext if a context a passed command queue belongs
*     to was released;
*   -  clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   -  clblasCompilerNotAvailable if a compiler is not available;
*   -  clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasSsyr2Native(JNIEnv *env, jclass cls, jint order, jint uplo, jlong N, jfloat alpha, jobject X, jlong offx, jint incx, jobject Y, jlong offy, jint incy, jobject A, jlong offa, jlong lda, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // N is primitive
    // alpha is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasSsyr2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (Y == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasSsyr2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasSsyr2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasSsyr2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasSsyr2(order=%d, uplo=%d, N=%ld, alpha=%f, X=%p, offx=%ld, incx=%d, Y=%p, offy=%ld, incy=%d, A=%p, offa=%ld, lda=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, N, alpha, X, offx, incx, Y, offy, incy, A, offa, lda, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    size_t N_native = 0;
    cl_float alpha_native = 0.0f;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    N_native = (size_t)N;
    alpha_native = (cl_float)alpha;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasSsyr2(order_native, uplo_native, N_native, alpha_native, X_native, offx_native, incx_native, Y_native, offy_native, incy_native, A_native, offa_native, lda_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // N is primitive
    // alpha is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Symmetric rank 2 operation with a general triangular matrix and.
* double elements.
*
* Symmetric rank 2 operation:
*   - \f$ A \leftarrow \alpha x y^T + \alpha y x^T + A \f$
*
* @param order (in)     Row/column order.
* @param uplo (in)      The triangle in matrix being referenced.
* @param N (in)         Number of columns in matrix  A.
* @param alpha (in)     The factor of matrix  A.
* @param X (in)         Buffer object storing vector  X.
* @param offx (in)      Offset of first element of vector  X in buffer object.
* @param incx (in)      Increment for the elements of  X. Must not be zero.
* @param Y (in)         Buffer object storing vector  Y.
* @param offy (in)      Offset of first element of vector  Y in buffer object.
* @param incy (in)      Increment for the elements of  Y. Must not be zero.
* @param A (out) 	    Buffer object storing matrix  A.
* @param offa (in)      Offset of first element of matrix  A in buffer object.
* @param lda (in)       Leading dimension of matrix  A. It cannot be less
*                      than  N.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasNotInitialized if clblasSetup() was not called;
*   -  clblasInvalidValue if invalid parameters are passed:
*     - either  N is zero, or
*     - either  incx or  incy is zero, or
*     - the leading dimension is invalid;
*   -  clblasInvalidMemObject if either  A,  X, or  Y object is
*     Invalid, or an image object rather than the buffer one;
*   -  clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   -  clblasInvalidCommandQueue if the passed command queue is invalid;
*   -  clblasInvalidContext if a context a passed command queue belongs
*     to was released;
*   -  clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   -  clblasCompilerNotAvailable if a compiler is not available;
*   -  clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasDsyr2Native(JNIEnv *env, jclass cls, jint order, jint uplo, jlong N, jdouble alpha, jobject X, jlong offx, jint incx, jobject Y, jlong offy, jint incy, jobject A, jlong offa, jlong lda, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // N is primitive
    // alpha is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasDsyr2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (Y == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasDsyr2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasDsyr2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasDsyr2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasDsyr2(order=%d, uplo=%d, N=%ld, alpha=%lf, X=%p, offx=%ld, incx=%d, Y=%p, offy=%ld, incy=%d, A=%p, offa=%ld, lda=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, N, alpha, X, offx, incx, Y, offy, incy, A, offa, lda, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    size_t N_native = 0;
    cl_double alpha_native = 0.0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    N_native = (size_t)N;
    alpha_native = (cl_double)alpha;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasDsyr2(order_native, uplo_native, N_native, alpha_native, X_native, offx_native, incx_native, Y_native, offy_native, incy_native, A_native, offa_native, lda_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // N is primitive
    // alpha is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Hermitian rank 2 operation with a general triangular matrix and.
* float-compelx elements.
*
* Hermitian rank 2 operation:
*   - \f$ A \leftarrow \alpha X Y^H + \overline{ \alpha } Y X^H + A \f$
*
* @param order (in)     Row/column order.
* @param uplo (in)      The triangle in matrix being referenced.
* @param N (in)         Number of columns in matrix  A.
* @param alpha (in)     The factor of matrix  A.
* @param X (in)         Buffer object storing vector  X.
* @param offx (in)      Offset in number of elements for the first element in vector  X.
* @param incx (in)      Increment for the elements of  X. Must not be zero.
* @param Y (in)         Buffer object storing vector  Y.
* @param offy (in)      Offset in number of elements for the first element in vector  Y.
* @param incy (in)      Increment for the elements of  Y. Must not be zero.
* @param A		Buffer (out) object storing matrix  A.
* @param offa (in)      Offset in number of elements for the first element in matrix  A.
* @param lda (in)       Leading dimension of matrix  A. It cannot be less
*                      than  N.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasNotInitialized if clblasSetup() was not called;
*   -  clblasInvalidValue if invalid parameters are passed:
*     - either  N is zero, or
*     - either  incx or  incy is zero, or
*     - the leading dimension is invalid;
*   -  clblasInvalidMemObject if either  A,  X, or  Y object is
*     Invalid, or an image object rather than the buffer one;
*   -  clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   -  clblasInvalidCommandQueue if the passed command queue is invalid;
*   -  clblasInvalidContext if a context a passed command queue belongs
*     to was released;
*   -  clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   -  clblasCompilerNotAvailable if a compiler is not available;
*   -  clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasCher2Native(JNIEnv *env, jclass cls, jint order, jint uplo, jlong N, jfloatArray alpha, jobject X, jlong offx, jint incx, jobject Y, jlong offy, jint incy, jobject A, jlong offa, jlong lda, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // N is primitive
    if (alpha == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'alpha' is null for clblasCher2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasCher2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (Y == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasCher2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasCher2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasCher2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasCher2(order=%d, uplo=%d, N=%ld, alpha=%p, X=%p, offx=%ld, incx=%d, Y=%p, offy=%ld, incy=%d, A=%p, offa=%ld, lda=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, N, alpha, X, offx, incx, Y, offy, incy, A, offa, lda, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    size_t N_native = 0;
    cl_float2 alpha_native;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    N_native = (size_t)N;
    if (!initNative(env, alpha, alpha_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasCher2(order_native, uplo_native, N_native, alpha_native, X_native, offx_native, incx_native, Y_native, offy_native, incy_native, A_native, offa_native, lda_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // N is primitive
    if (!releaseNative(env, alpha_native, alpha, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Hermitian rank 2 operation with a general triangular matrix and.
* double-compelx elements.
*
* Hermitian rank 2 operation:
*   - \f$ A \leftarrow \alpha X Y^H + \overline{ \alpha } Y X^H + A \f$
*
* @param order (in)     Row/column order.
* @param uplo (in)      The triangle in matrix being referenced.
* @param N (in)         Number of columns in matrix  A.
* @param alpha (in)     The factor of matrix  A.
* @param X (in)         Buffer object storing vector  X.
* @param offx (in)      Offset in number of elements for the first element in vector  X.
* @param incx (in)      Increment for the elements of  X. Must not be zero.
* @param Y (in)         Buffer object storing vector  Y.
* @param offy (in)      Offset in number of elements for the first element in vector  Y.
* @param incy (in)      Increment for the elements of  Y. Must not be zero.
* @param A		Buffer (out) object storing matrix  A.
* @param offa (in)      Offset in number of elements for the first element in matrix  A.
* @param lda (in)       Leading dimension of matrix  A. It cannot be less
*                      than  N.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasInvalidDevice if a target device does not support floating
*     point arithmetic with double precision;
*   - the same error codes as the clblasCher2() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasZher2Native(JNIEnv *env, jclass cls, jint order, jint uplo, jlong N, jdoubleArray alpha, jobject X, jlong offx, jint incx, jobject Y, jlong offy, jint incy, jobject A, jlong offa, jlong lda, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // N is primitive
    if (alpha == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'alpha' is null for clblasZher2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasZher2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (Y == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasZher2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasZher2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasZher2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasZher2(order=%d, uplo=%d, N=%ld, alpha=%p, X=%p, offx=%ld, incx=%d, Y=%p, offy=%ld, incy=%d, A=%p, offa=%ld, lda=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, N, alpha, X, offx, incx, Y, offy, incy, A, offa, lda, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    size_t N_native = 0;
    cl_double2 alpha_native;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    N_native = (size_t)N;
    if (!initNative(env, alpha, alpha_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasZher2(order_native, uplo_native, N_native, alpha_native, X_native, offx_native, incx_native, Y_native, offy_native, incy_native, A_native, offa_native, lda_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // N is primitive
    if (!releaseNative(env, alpha_native, alpha, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* @example example_zher2.c
* Example of how to use the @ref clblasZher2 function.
*/
/**
* Matrix-vector product with a packed triangular matrix and.
* float elements.
*
* Matrix-vector products:
*   - \f$ X \leftarrow  A X \f$
*   - \f$ X \leftarrow  A^T X \f$
*
* @param order (in)     Row/column order.
* @param uplo				The (in) triangle in matrix being referenced.
* @param trans				How (in) matrix  AP is to be transposed.
* @param diag				Specify (in) whether matrix  AP is unit triangular.
* @param N					Number (in) of rows/columns in matrix  A.
* @param AP				Buffer (in) object storing matrix  AP in packed format.
* @param offa				Offset (in) in number of elements for first element in matrix  AP.
* @param X				Buffer (out) object storing vector  X.
* @param offx				Offset (in) in number of elements for first element in vector  X.
* @param incx				Increment (in) for the elements of  X. Must not be zero.
* @param scratchBuff		Temporary (in) cl_mem scratch buffer object which can hold a
*								minimum of (1 + (N-1)*abs(incx)) elements
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasNotInitialized if clblasSetup() was not called;
*   -  clblasInvalidValue if invalid parameters are passed:
*     - either  N or  incx is zero
*   -  clblasInvalidMemObject if either  AP or  X object is
*     Invalid, or an image object rather than the buffer one;
*   -  clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   -  clblasInvalidCommandQueue if the passed command queue is invalid;
*   -  clblasInvalidContext if a context a passed command queue belongs
*     to was released;
*   -  clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   -  clblasCompilerNotAvailable if a compiler is not available;
*   -  clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasStpmvNative(JNIEnv *env, jclass cls, jint order, jint uplo, jint trans, jint diag, jlong N, jobject AP, jlong offa, jobject X, jlong offx, jint incx, jobject scratchBuff, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    if (AP == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'AP' is null for clblasStpmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasStpmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (scratchBuff == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'scratchBuff' is null for clblasStpmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasStpmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasStpmv(order=%d, uplo=%d, trans=%d, diag=%d, N=%ld, AP=%p, offa=%ld, X=%p, offx=%ld, incx=%d, scratchBuff=%p, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, trans, diag, N, AP, offa, X, offx, incx, scratchBuff, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    clblasTranspose trans_native;
    clblasDiag diag_native;
    size_t N_native = 0;
    cl_mem AP_native = nullptr;
    size_t offa_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem scratchBuff_native = nullptr;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    trans_native = (clblasTranspose)trans;
    diag_native = (clblasDiag)diag;
    N_native = (size_t)N;
    if (!initNative(env, AP, AP_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, scratchBuff, scratchBuff_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasStpmv(order_native, uplo_native, trans_native, diag_native, N_native, AP_native, offa_native, X_native, offx_native, incx_native, scratchBuff_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    // AP is a read-only native pointer
    // offa is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // scratchBuff is a read-only native pointer
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* @example example_stpmv.c
* Example of how to use the @ref clblasStpmv function.
*/
/**
* Matrix-vector product with a packed triangular matrix and.
* double elements.
*
* Matrix-vector products:
*   - \f$ X \leftarrow  A X \f$
*   - \f$ X \leftarrow  A^T X \f$
*
* @param order (in)     Row/column order.
* @param uplo				The (in) triangle in matrix being referenced.
* @param trans				How (in) matrix  AP is to be transposed.
* @param diag				Specify (in) whether matrix  AP is unit triangular.
* @param N					Number (in) of rows/columns in matrix  AP.
* @param AP				Buffer (in) object storing matrix  AP in packed format.
* @param offa				Offset (in) in number of elements for first element in matrix  AP.
* @param X				Buffer (out) object storing vector  X.
* @param offx				Offset (in) in number of elements for first element in vector  X.
* @param incx				Increment (in) for the elements of  X. Must not be zero.
* @param scratchBuff		Temporary (in) cl_mem scratch buffer object which can hold a
*								minimum of (1 + (N-1)*abs(incx)) elements
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasInvalidDevice if a target device does not support floating
*     point arithmetic with double precision;
*   - the same error codes as the clblasStpmv() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasDtpmvNative(JNIEnv *env, jclass cls, jint order, jint uplo, jint trans, jint diag, jlong N, jobject AP, jlong offa, jobject X, jlong offx, jint incx, jobject scratchBuff, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    if (AP == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'AP' is null for clblasDtpmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasDtpmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (scratchBuff == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'scratchBuff' is null for clblasDtpmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasDtpmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasDtpmv(order=%d, uplo=%d, trans=%d, diag=%d, N=%ld, AP=%p, offa=%ld, X=%p, offx=%ld, incx=%d, scratchBuff=%p, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, trans, diag, N, AP, offa, X, offx, incx, scratchBuff, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    clblasTranspose trans_native;
    clblasDiag diag_native;
    size_t N_native = 0;
    cl_mem AP_native = nullptr;
    size_t offa_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem scratchBuff_native = nullptr;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    trans_native = (clblasTranspose)trans;
    diag_native = (clblasDiag)diag;
    N_native = (size_t)N;
    if (!initNative(env, AP, AP_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, scratchBuff, scratchBuff_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasDtpmv(order_native, uplo_native, trans_native, diag_native, N_native, AP_native, offa_native, X_native, offx_native, incx_native, scratchBuff_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    // AP is a read-only native pointer
    // offa is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // scratchBuff is a read-only native pointer
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Matrix-vector product with a packed triangular matrix and.
* float-complex elements.
*
* Matrix-vector products:
*   - \f$ X \leftarrow  A X \f$
*   - \f$ X \leftarrow  A^T X \f$
*
* @param order (in)     Row/column order.
* @param uplo				The (in) triangle in matrix being referenced.
* @param trans				How (in) matrix  AP is to be transposed.
* @param diag				Specify (in) whether matrix  AP is unit triangular.
* @param N					Number (in) of rows/columns in matrix  AP.
* @param AP				Buffer (in) object storing matrix  AP in packed format.
* @param offa				Offset (in) in number of elements for first element in matrix  AP.
* @param X				Buffer (out) object storing vector  X.
* @param offx				Offset (in) in number of elements for first element in vector  X.
* @param incx				Increment (in) for the elements of  X. Must not be zero.
* @param scratchBuff		Temporary (in) cl_mem scratch buffer object which can hold a
*								minimum of (1 + (N-1)*abs(incx)) elements
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return The same result as the clblasStpmv() function.
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasCtpmvNative(JNIEnv *env, jclass cls, jint order, jint uplo, jint trans, jint diag, jlong N, jobject AP, jlong offa, jobject X, jlong offx, jint incx, jobject scratchBuff, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    if (AP == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'AP' is null for clblasCtpmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasCtpmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (scratchBuff == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'scratchBuff' is null for clblasCtpmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasCtpmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasCtpmv(order=%d, uplo=%d, trans=%d, diag=%d, N=%ld, AP=%p, offa=%ld, X=%p, offx=%ld, incx=%d, scratchBuff=%p, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, trans, diag, N, AP, offa, X, offx, incx, scratchBuff, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    clblasTranspose trans_native;
    clblasDiag diag_native;
    size_t N_native = 0;
    cl_mem AP_native = nullptr;
    size_t offa_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem scratchBuff_native = nullptr;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    trans_native = (clblasTranspose)trans;
    diag_native = (clblasDiag)diag;
    N_native = (size_t)N;
    if (!initNative(env, AP, AP_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, scratchBuff, scratchBuff_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasCtpmv(order_native, uplo_native, trans_native, diag_native, N_native, AP_native, offa_native, X_native, offx_native, incx_native, scratchBuff_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    // AP is a read-only native pointer
    // offa is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // scratchBuff is a read-only native pointer
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Matrix-vector product with a packed triangular matrix and.
* double-complex elements.
*
* Matrix-vector products:
*   - \f$ X \leftarrow  A X \f$
*   - \f$ X \leftarrow  A^T X \f$
*
* @param order (in)     Row/column order.
* @param uplo				The (in) triangle in matrix being referenced.
* @param trans				How (in) matrix  AP is to be transposed.
* @param diag				Specify (in) whether matrix  AP is unit triangular.
* @param N					Number (in) of rows/columns in matrix  AP.
* @param AP				Buffer (in) object storing matrix  AP in packed format.
* @param offa				Offset (in) in number of elements for first element in matrix  AP.
* @param X				Buffer (out) object storing vector  X.
* @param offx				Offset (in) in number of elements for first element in vector  X.
* @param incx				Increment (in) for the elements of  X. Must not be zero.
* @param scratchBuff		Temporary (in) cl_mem scratch buffer object which can hold a
*								minimum of (1 + (N-1)*abs(incx)) elements
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return The same result as the clblasDtpmv() function.
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasZtpmvNative(JNIEnv *env, jclass cls, jint order, jint uplo, jint trans, jint diag, jlong N, jobject AP, jlong offa, jobject X, jlong offx, jint incx, jobject scratchBuff, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    if (AP == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'AP' is null for clblasZtpmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasZtpmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (scratchBuff == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'scratchBuff' is null for clblasZtpmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasZtpmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasZtpmv(order=%d, uplo=%d, trans=%d, diag=%d, N=%ld, AP=%p, offa=%ld, X=%p, offx=%ld, incx=%d, scratchBuff=%p, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, trans, diag, N, AP, offa, X, offx, incx, scratchBuff, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    clblasTranspose trans_native;
    clblasDiag diag_native;
    size_t N_native = 0;
    cl_mem AP_native = nullptr;
    size_t offa_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem scratchBuff_native = nullptr;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    trans_native = (clblasTranspose)trans;
    diag_native = (clblasDiag)diag;
    N_native = (size_t)N;
    if (!initNative(env, AP, AP_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, scratchBuff, scratchBuff_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasZtpmv(order_native, uplo_native, trans_native, diag_native, N_native, AP_native, offa_native, X_native, offx_native, incx_native, scratchBuff_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    // AP is a read-only native pointer
    // offa is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // scratchBuff is a read-only native pointer
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* solving triangular packed matrix problems with float elements..
*
* Matrix-vector products:
*   - \f$ A X \leftarrow  X \f$
*   - \f$ A^T X \leftarrow  X \f$
*
* @param order (in)     Row/column order.
* @param uplo (in)              The triangle in matrix being referenced.
* @param trans (in)             How matrix  A is to be transposed.
* @param diag (in)              Specify whether matrix  A is unit triangular.
* @param N (in)                 Number of rows/columns in matrix  A.
* @param A (in)                 Buffer object storing matrix in packed format. A.
* @param offa (in)              Offset in number of elements for first element in matrix  A.
* @param X (out)                Buffer object storing vector  X.
* @param offx (in)              Offset in number of elements for first element in vector  X.
* @param incx (in)              Increment for the elements of  X. Must not be zero.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasNotInitialized if clblasSetup() was not called;
*   -  clblasInvalidValue if invalid parameters are passed:
*     - either  N or  incx is zero, or
*     - the leading dimension is invalid;
*   -  clblasInvalidMemObject if either  A or  X object is
*     Invalid, or an image object rather than the buffer one;
*   -  clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   -  clblasInvalidCommandQueue if the passed command queue is invalid;
*   -  clblasInvalidContext if a context a passed command queue belongs
*     to was released;
*   -  clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   -  clblasCompilerNotAvailable if a compiler is not available;
*   -  clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasStpsvNative(JNIEnv *env, jclass cls, jint order, jint uplo, jint trans, jint diag, jlong N, jobject A, jlong offa, jobject X, jlong offx, jint incx, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasStpsv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasStpsv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasStpsv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasStpsv(order=%d, uplo=%d, trans=%d, diag=%d, N=%ld, A=%p, offa=%ld, X=%p, offx=%ld, incx=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, trans, diag, N, A, offa, X, offx, incx, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    clblasTranspose trans_native;
    clblasDiag diag_native;
    size_t N_native = 0;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    trans_native = (clblasTranspose)trans;
    diag_native = (clblasDiag)diag;
    N_native = (size_t)N;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasStpsv(order_native, uplo_native, trans_native, diag_native, N_native, A_native, offa_native, X_native, offx_native, incx_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    // A is a read-only native pointer
    // offa is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* @example example_stpsv.c
* Example of how to use the @ref clblasStpsv function.
*/
/**
* solving triangular packed matrix problems with double elements..
*
* Matrix-vector products:
*   - \f$ A X \leftarrow  X \f$
*   - \f$ A^T X \leftarrow  X \f$
*
* @param order (in)     Row/column order.
* @param uplo (in)              The triangle in matrix being referenced.
* @param trans (in)             How matrix  A is to be transposed.
* @param diag (in)              Specify whether matrix  A is unit triangular.
* @param N (in)                 Number of rows/columns in matrix  A.
* @param A (in)                 Buffer object storing matrix in packed format. A.
* @param offa (in)              Offset in number of elements for first element in matrix  A.
* @param X (out)                Buffer object storing vector  X.
* @param offx (in)              Offset in number of elements for first element in vector  X.
* @param incx (in)              Increment for the elements of  X. Must not be zero.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasNotInitialized if clblasSetup() was not called;
*   -  clblasInvalidValue if invalid parameters are passed:
*     - either  N or  incx is zero, or
*     - the leading dimension is invalid;
*   -  clblasInvalidMemObject if either  A or  X object is
*     Invalid, or an image object rather than the buffer one;
*   -  clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   -  clblasInvalidCommandQueue if the passed command queue is invalid;
*   -  clblasInvalidContext if a context a passed command queue belongs
*     to was released;
*   -  clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   -  clblasCompilerNotAvailable if a compiler is not available;
*   -  clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasDtpsvNative(JNIEnv *env, jclass cls, jint order, jint uplo, jint trans, jint diag, jlong N, jobject A, jlong offa, jobject X, jlong offx, jint incx, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasDtpsv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasDtpsv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasDtpsv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasDtpsv(order=%d, uplo=%d, trans=%d, diag=%d, N=%ld, A=%p, offa=%ld, X=%p, offx=%ld, incx=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, trans, diag, N, A, offa, X, offx, incx, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    clblasTranspose trans_native;
    clblasDiag diag_native;
    size_t N_native = 0;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    trans_native = (clblasTranspose)trans;
    diag_native = (clblasDiag)diag;
    N_native = (size_t)N;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasDtpsv(order_native, uplo_native, trans_native, diag_native, N_native, A_native, offa_native, X_native, offx_native, incx_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    // A is a read-only native pointer
    // offa is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* solving triangular packed matrix problems with float complex elements..
*
* Matrix-vector products:
*   - \f$ A X \leftarrow  X \f$
*   - \f$ A^T X \leftarrow  X \f$
*
* @param order (in)     Row/column order.
* @param uplo (in)              The triangle in matrix being referenced.
* @param trans (in)             How matrix  A is to be transposed.
* @param diag (in)              Specify whether matrix  A is unit triangular.
* @param N (in)                 Number of rows/columns in matrix  A.
* @param A (in)                 Buffer object storing matrix in packed format. A.
* @param offa (in)              Offset in number of elements for first element in matrix  A.
* @param X (out)                Buffer object storing vector  X.
* @param offx (in)              Offset in number of elements for first element in vector  X.
* @param incx (in)              Increment for the elements of  X. Must not be zero.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasNotInitialized if clblasSetup() was not called;
*   -  clblasInvalidValue if invalid parameters are passed:
*     - either  N or  incx is zero, or
*     - the leading dimension is invalid;
*   -  clblasInvalidMemObject if either  A or  X object is
*     Invalid, or an image object rather than the buffer one;
*   -  clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   -  clblasInvalidCommandQueue if the passed command queue is invalid;
*   -  clblasInvalidContext if a context a passed command queue belongs
*     to was released;
*   -  clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   -  clblasCompilerNotAvailable if a compiler is not available;
*   -  clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasCtpsvNative(JNIEnv *env, jclass cls, jint order, jint uplo, jint trans, jint diag, jlong N, jobject A, jlong offa, jobject X, jlong offx, jint incx, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasCtpsv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasCtpsv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasCtpsv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasCtpsv(order=%d, uplo=%d, trans=%d, diag=%d, N=%ld, A=%p, offa=%ld, X=%p, offx=%ld, incx=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, trans, diag, N, A, offa, X, offx, incx, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    clblasTranspose trans_native;
    clblasDiag diag_native;
    size_t N_native = 0;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    trans_native = (clblasTranspose)trans;
    diag_native = (clblasDiag)diag;
    N_native = (size_t)N;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasCtpsv(order_native, uplo_native, trans_native, diag_native, N_native, A_native, offa_native, X_native, offx_native, incx_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    // A is a read-only native pointer
    // offa is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* solving triangular packed matrix problems with double complex elements..
*
* Matrix-vector products:
*   - \f$ A X \leftarrow  X \f$
*   - \f$ A^T X \leftarrow  X \f$
*
* @param order (in)     Row/column order.
* @param uplo (in)              The triangle in matrix being referenced.
* @param trans (in)             How matrix  A is to be transposed.
* @param diag (in)              Specify whether matrix  A is unit triangular.
* @param N (in)                 Number of rows/columns in matrix  A.
* @param A (in)                 Buffer object storing matrix in packed format. A.
* @param offa (in)              Offset in number of elements for first element in matrix  A.
* @param X (out)                Buffer object storing vector  X.
* @param offx (in)              Offset in number of elements for first element in vector  X.
* @param incx (in)              Increment for the elements of  X. Must not be zero.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasNotInitialized if clblasSetup() was not called;
*   -  clblasInvalidValue if invalid parameters are passed:
*     - either  N or  incx is zero, or
*     - the leading dimension is invalid;
*   -  clblasInvalidMemObject if either  A or  X object is
*     Invalid, or an image object rather than the buffer one;
*   -  clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   -  clblasInvalidCommandQueue if the passed command queue is invalid;
*   -  clblasInvalidContext if a context a passed command queue belongs
*     to was released;
*   -  clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   -  clblasCompilerNotAvailable if a compiler is not available;
*   -  clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasZtpsvNative(JNIEnv *env, jclass cls, jint order, jint uplo, jint trans, jint diag, jlong N, jobject A, jlong offa, jobject X, jlong offx, jint incx, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasZtpsv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasZtpsv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasZtpsv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasZtpsv(order=%d, uplo=%d, trans=%d, diag=%d, N=%ld, A=%p, offa=%ld, X=%p, offx=%ld, incx=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, trans, diag, N, A, offa, X, offx, incx, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    clblasTranspose trans_native;
    clblasDiag diag_native;
    size_t N_native = 0;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    trans_native = (clblasTranspose)trans;
    diag_native = (clblasDiag)diag;
    N_native = (size_t)N;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasZtpsv(order_native, uplo_native, trans_native, diag_native, N_native, A_native, offa_native, X_native, offx_native, incx_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    // A is a read-only native pointer
    // offa is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Matrix-vector product with a symmetric packed-matrix and float elements..
*
* Matrix-vector products:
* - \f$ Y \leftarrow \alpha A X + eta Y \f$
*
* @param order (in)     Row/columns order.
* @param uplo (in)      The triangle in matrix being referenced.
* @param N (in)         Number of rows and columns in matrix  AP.
* @param alpha (in)     The factor of matrix  AP.
* @param AP (in)        Buffer object storing matrix  AP.
* @param offa		Offset (in) in number of elements for first element in matrix  AP.
* @param X (in)         Buffer object storing vector  X.
* @param offx (in)      Offset of first element of vector  X in buffer object.
*                      Counted in elements.
* @param incx (in)      Increment for the elements of vector  X. It cannot be zero.
* @param beta (in)      The factor of vector  Y.
* @param Y (out)        Buffer object storing vector  Y.
* @param offy (in)      Offset of first element of vector  Y in buffer object.
*                      Counted in elements.
* @param incy (in)      Increment for the elements of vector  Y. It cannot be zero.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasNotInitialized if clblasSetup() was not called;
*   -  clblasInvalidValue if invalid parameters are passed:
*     -  N is zero, or
*     - either  incx or  incy is zero, or
*     - the matrix sizes or the vector sizes along with the increments lead to
*       accessing outsize of any of the buffers;
*   -  clblasInvalidMemObject if either  AP,  X, or  Y object is
*     invalid, or an image object rather than the buffer one;
*   -  clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   -  clblasInvalidCommandQueue if the passed command queue is invalid;
*   -  clblasInvalidContext if a context a passed command queue belongs to
*     was released;
*   -  clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   -  clblasCompilerNotAvailable if a compiler is not available;
*   -  clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasSspmvNative(JNIEnv *env, jclass cls, jint order, jint uplo, jlong N, jfloat alpha, jobject AP, jlong offa, jobject X, jlong offx, jint incx, jfloat beta, jobject Y, jlong offy, jint incy, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // N is primitive
    // alpha is primitive
    if (AP == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'AP' is null for clblasSspmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasSspmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    // beta is primitive
    if (Y == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasSspmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasSspmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasSspmv(order=%d, uplo=%d, N=%ld, alpha=%f, AP=%p, offa=%ld, X=%p, offx=%ld, incx=%d, beta=%f, Y=%p, offy=%ld, incy=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, N, alpha, AP, offa, X, offx, incx, beta, Y, offy, incy, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    size_t N_native = 0;
    cl_float alpha_native = 0.0f;
    cl_mem AP_native = nullptr;
    size_t offa_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_float beta_native = 0.0f;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    N_native = (size_t)N;
    alpha_native = (cl_float)alpha;
    if (!initNative(env, AP, AP_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    beta_native = (cl_float)beta;
    if (!initNative(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasSspmv(order_native, uplo_native, N_native, alpha_native, AP_native, offa_native, X_native, offx_native, incx_native, beta_native, Y_native, offy_native, incy_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // N is primitive
    // alpha is primitive
    // AP is a read-only native pointer
    // offa is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // beta is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* @example example_sspmv.c
* This is an example of how to use the @ref clblasSspmv function.
*/
/**
* Matrix-vector product with a symmetric packed-matrix and double elements..
*
* Matrix-vector products:
* - \f$ Y \leftarrow \alpha A X + eta Y \f$
*
* @param order (in)     Row/columns order.
* @param uplo (in)      The triangle in matrix being referenced.
* @param N (in)         Number of rows and columns in matrix  AP.
* @param alpha (in)     The factor of matrix  AP.
* @param AP (in)        Buffer object storing matrix  AP.
* @param offa		Offset (in) in number of elements for first element in matrix  AP.
* @param X (in)         Buffer object storing vector  X.
* @param offx (in)      Offset of first element of vector  X in buffer object.
*                      Counted in elements.
* @param incx (in)      Increment for the elements of vector  X. It cannot be zero.
* @param beta (in)      The factor of vector  Y.
* @param Y (out)        Buffer object storing vector  Y.
* @param offy (in)      Offset of first element of vector  Y in buffer object.
*                      Counted in elements.
* @param incy (in)      Increment for the elements of vector  Y. It cannot be zero.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasInvalidDevice if a target device does not support floating
*     point arithmetic with double precision;
*   - the same error codes as the clblasSspmv() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasDspmvNative(JNIEnv *env, jclass cls, jint order, jint uplo, jlong N, jdouble alpha, jobject AP, jlong offa, jobject X, jlong offx, jint incx, jdouble beta, jobject Y, jlong offy, jint incy, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // N is primitive
    // alpha is primitive
    if (AP == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'AP' is null for clblasDspmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasDspmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    // beta is primitive
    if (Y == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasDspmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasDspmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasDspmv(order=%d, uplo=%d, N=%ld, alpha=%lf, AP=%p, offa=%ld, X=%p, offx=%ld, incx=%d, beta=%lf, Y=%p, offy=%ld, incy=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, N, alpha, AP, offa, X, offx, incx, beta, Y, offy, incy, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    size_t N_native = 0;
    cl_double alpha_native = 0.0;
    cl_mem AP_native = nullptr;
    size_t offa_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_double beta_native = 0.0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    N_native = (size_t)N;
    alpha_native = (cl_double)alpha;
    if (!initNative(env, AP, AP_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    beta_native = (cl_double)beta;
    if (!initNative(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasDspmv(order_native, uplo_native, N_native, alpha_native, AP_native, offa_native, X_native, offx_native, incx_native, beta_native, Y_native, offy_native, incy_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // N is primitive
    // alpha is primitive
    // AP is a read-only native pointer
    // offa is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // beta is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Matrix-vector product with a packed hermitian matrix and float-complex elements..
*
* Matrix-vector products:
* - \f$ Y \leftarrow \alpha A X + eta Y \f$
*
* @param order (in)     Row/columns order.
* @param uplo (in)      The triangle in matrix being referenced.
* @param N (in)         Number of rows and columns in matrix  AP.
* @param alpha (in)     The factor of matrix  AP.
* @param AP (in)        Buffer object storing packed matrix  AP.
* @param offa		Offset (in) in number of elements for first element in matrix  AP.
* @param X (in)         Buffer object storing vector  X.
* @param offx (in)      Offset of first element of vector  X in buffer object.
*                      Counted in elements.
* @param incx (in)      Increment for the elements of vector  X. It cannot be zero.
* @param beta (in)      The factor of vector  Y.
* @param Y (out)        Buffer object storing vector  Y.
* @param offy (in)      Offset of first element of vector  Y in buffer object.
*                      Counted in elements.
* @param incy (in)      Increment for the elements of vector  Y. It cannot be zero.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasNotInitialized if clblasSetup() was not called;
*   -  clblasInvalidValue if invalid parameters are passed:
*     -  N is zero, or
*     - either  incx or  incy is zero, or
*     - the matrix sizes or the vector sizes along with the increments lead to
*       accessing outsize of any of the buffers;
*   -  clblasInvalidMemObject if either  AP,  X, or  Y object is
*     invalid, or an image object rather than the buffer one;
*   -  clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   -  clblasInvalidCommandQueue if the passed command queue is invalid;
*   -  clblasInvalidContext if a context a passed command queue belongs to
*     was released;
*   -  clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   -  clblasCompilerNotAvailable if a compiler is not available;
*   -  clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasChpmvNative(JNIEnv *env, jclass cls, jint order, jint uplo, jlong N, jfloatArray alpha, jobject AP, jlong offa, jobject X, jlong offx, jint incx, jfloatArray beta, jobject Y, jlong offy, jint incy, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // N is primitive
    if (alpha == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'alpha' is null for clblasChpmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (AP == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'AP' is null for clblasChpmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasChpmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (beta == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'beta' is null for clblasChpmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (Y == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasChpmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasChpmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasChpmv(order=%d, uplo=%d, N=%ld, alpha=%p, AP=%p, offa=%ld, X=%p, offx=%ld, incx=%d, beta=%p, Y=%p, offy=%ld, incy=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, N, alpha, AP, offa, X, offx, incx, beta, Y, offy, incy, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    size_t N_native = 0;
    cl_float2 alpha_native;
    cl_mem AP_native = nullptr;
    size_t offa_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_float2 beta_native;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    N_native = (size_t)N;
    if (!initNative(env, alpha, alpha_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, AP, AP_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, beta, beta_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasChpmv(order_native, uplo_native, N_native, alpha_native, AP_native, offa_native, X_native, offx_native, incx_native, beta_native, Y_native, offy_native, incy_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // N is primitive
    if (!releaseNative(env, alpha_native, alpha, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // AP is a read-only native pointer
    // offa is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    if (!releaseNative(env, beta_native, beta, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* @example example_chpmv.c
* This is an example of how to use the @ref clblasChpmv function.
*/
/**
* Matrix-vector product with a packed hermitian matrix and double-complex elements..
*
* Matrix-vector products:
* - \f$ Y \leftarrow \alpha A X + eta Y \f$
*
* @param order (in)     Row/columns order.
* @param uplo (in)      The triangle in matrix being referenced.
* @param N (in)         Number of rows and columns in matrix  AP.
* @param alpha (in)     The factor of matrix  AP.
* @param AP (in)        Buffer object storing packed matrix  AP.
* @param offa		Offset (in) in number of elements for first element in matrix  AP.
* @param X (in)         Buffer object storing vector  X.
* @param offx (in)      Offset of first element of vector  X in buffer object.
*                      Counted in elements.
* @param incx (in)      Increment for the elements of vector  X. It cannot be zero.
* @param beta (in)      The factor of vector  Y.
* @param Y (out)        Buffer object storing vector  Y.
* @param offy (in)      Offset of first element of vector  Y in buffer object.
*                      Counted in elements.
* @param incy (in)      Increment for the elements of vector  Y. It cannot be zero.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasInvalidDevice if a target device does not support floating
*     point arithmetic with double precision;
*   - the same error codes as the clblasChpmv() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasZhpmvNative(JNIEnv *env, jclass cls, jint order, jint uplo, jlong N, jdoubleArray alpha, jobject AP, jlong offa, jobject X, jlong offx, jint incx, jdoubleArray beta, jobject Y, jlong offy, jint incy, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // N is primitive
    if (alpha == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'alpha' is null for clblasZhpmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (AP == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'AP' is null for clblasZhpmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasZhpmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (beta == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'beta' is null for clblasZhpmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (Y == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasZhpmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasZhpmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasZhpmv(order=%d, uplo=%d, N=%ld, alpha=%p, AP=%p, offa=%ld, X=%p, offx=%ld, incx=%d, beta=%p, Y=%p, offy=%ld, incy=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, N, alpha, AP, offa, X, offx, incx, beta, Y, offy, incy, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    size_t N_native = 0;
    cl_double2 alpha_native;
    cl_mem AP_native = nullptr;
    size_t offa_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_double2 beta_native;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    N_native = (size_t)N;
    if (!initNative(env, alpha, alpha_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, AP, AP_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, beta, beta_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasZhpmv(order_native, uplo_native, N_native, alpha_native, AP_native, offa_native, X_native, offx_native, incx_native, beta_native, Y_native, offy_native, incy_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // N is primitive
    if (!releaseNative(env, alpha_native, alpha, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // AP is a read-only native pointer
    // offa is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    if (!releaseNative(env, beta_native, beta, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Symmetric rank 1 operation with a general triangular packed-matrix and.
* float elements.
*
* Symmetric rank 1 operation:
*   - \f$ A \leftarrow \alpha X X^T + A \f$
*
* @param order (in)     Row/column order.
* @param uplo (in)      The triangle in matrix being referenced.
* @param N (in)         Number of columns in matrix  A.
* @param alpha (in)     The factor of matrix  A.
* @param X (in)         Buffer object storing vector  X.
* @param offx (in)      Offset of first element of vector  X in buffer object.
* @param incx (in)      Increment for the elements of  X. Must not be zero.
* @param AP (out) 	    Buffer object storing packed-matrix  AP.
* @param offa (in)      Offset of first element of matrix  AP in buffer object.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasNotInitialized if clblasSetup() was not called;
*   -  clblasInvalidValue if invalid parameters are passed:
*     -  N is zero, or
*     - either  incx is zero
*   -  clblasInvalidMemObject if either  AP,  X object is
*     Invalid, or an image object rather than the buffer one;
*   -  clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   -  clblasInvalidCommandQueue if the passed command queue is invalid;
*   -  clblasInvalidContext if a context a passed command queue belongs
*     to was released;
*   -  clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   -  clblasCompilerNotAvailable if a compiler is not available;
*   -  clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasSsprNative(JNIEnv *env, jclass cls, jint order, jint uplo, jlong N, jfloat alpha, jobject X, jlong offx, jint incx, jobject AP, jlong offa, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // N is primitive
    // alpha is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasSspr");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (AP == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'AP' is null for clblasSspr");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasSspr");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasSspr(order=%d, uplo=%d, N=%ld, alpha=%f, X=%p, offx=%ld, incx=%d, AP=%p, offa=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, N, alpha, X, offx, incx, AP, offa, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    size_t N_native = 0;
    cl_float alpha_native = 0.0f;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem AP_native = nullptr;
    size_t offa_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    N_native = (size_t)N;
    alpha_native = (cl_float)alpha;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, AP, AP_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasSspr(order_native, uplo_native, N_native, alpha_native, X_native, offx_native, incx_native, AP_native, offa_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // N is primitive
    // alpha is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // AP is a read-only native pointer
    // offa is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* @example example_sspr.c
* Example of how to use the @ref clblasSspr function.
*/
/**
* Symmetric rank 1 operation with a general triangular packed-matrix and.
* double elements.
*
* Symmetric rank 1 operation:
*   - \f$ A \leftarrow \alpha X X^T + A \f$
*
* @param order (in)     Row/column order.
* @param uplo (in)      The triangle in matrix being referenced.
* @param N (in)         Number of columns in matrix  A.
* @param alpha (in)     The factor of matrix  A.
* @param X (in)         Buffer object storing vector  X.
* @param offx (in)      Offset of first element of vector  X in buffer object.
* @param incx (in)      Increment for the elements of  X. Must not be zero.
* @param AP (out) 	    Buffer object storing packed-matrix  AP.
* @param offa (in)      Offset of first element of matrix  AP in buffer object.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasInvalidDevice if a target device does not support floating
*     point arithmetic with double precision;
*   - the same error codes as the clblasSspr() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasDsprNative(JNIEnv *env, jclass cls, jint order, jint uplo, jlong N, jdouble alpha, jobject X, jlong offx, jint incx, jobject AP, jlong offa, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // N is primitive
    // alpha is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasDspr");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (AP == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'AP' is null for clblasDspr");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasDspr");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasDspr(order=%d, uplo=%d, N=%ld, alpha=%lf, X=%p, offx=%ld, incx=%d, AP=%p, offa=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, N, alpha, X, offx, incx, AP, offa, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    size_t N_native = 0;
    cl_double alpha_native = 0.0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem AP_native = nullptr;
    size_t offa_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    N_native = (size_t)N;
    alpha_native = (cl_double)alpha;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, AP, AP_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasDspr(order_native, uplo_native, N_native, alpha_native, X_native, offx_native, incx_native, AP_native, offa_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // N is primitive
    // alpha is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // AP is a read-only native pointer
    // offa is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* hermitian rank 1 operation with a general triangular packed-matrix and.
* float-complex elements.
*
* hermitian rank 1 operation:
*   - \f$ A \leftarrow \alpha X X^H + A \f$
*
* @param order (in)     Row/column order.
* @param uplo (in)      The triangle in matrix being referenced.
* @param N (in)         Number of columns in matrix  A.
* @param alpha (in)     The factor of matrix  A (a scalar float value)
* @param X (in)         Buffer object storing vector  X.
* @param offx (in)      Offset in number of elements for the first element in vector  X.
* @param incx (in)      Increment for the elements of  X. Must not be zero.
* @param AP (out) 	    Buffer object storing matrix  AP.
* @param offa (in)      Offset in number of elements for the first element in matrix  AP.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasNotInitialized if clblasSetup() was not called;
*   -  clblasInvalidValue if invalid parameters are passed:
*     -  N is zero, or
*     - either  incx is zero
*   -  clblasInvalidMemObject if either  AP,  X object is
*     Invalid, or an image object rather than the buffer one;
*   -  clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   -  clblasInvalidCommandQueue if the passed command queue is invalid;
*   -  clblasInvalidContext if a context a passed command queue belongs
*     to was released;
*   -  clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   -  clblasCompilerNotAvailable if a compiler is not available;
*   -  clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasChprNative(JNIEnv *env, jclass cls, jint order, jint uplo, jlong N, jfloat alpha, jobject X, jlong offx, jint incx, jobject AP, jlong offa, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // N is primitive
    // alpha is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasChpr");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (AP == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'AP' is null for clblasChpr");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasChpr");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasChpr(order=%d, uplo=%d, N=%ld, alpha=%f, X=%p, offx=%ld, incx=%d, AP=%p, offa=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, N, alpha, X, offx, incx, AP, offa, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    size_t N_native = 0;
    cl_float alpha_native = 0.0f;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem AP_native = nullptr;
    size_t offa_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    N_native = (size_t)N;
    alpha_native = (cl_float)alpha;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, AP, AP_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasChpr(order_native, uplo_native, N_native, alpha_native, X_native, offx_native, incx_native, AP_native, offa_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // N is primitive
    // alpha is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // AP is a read-only native pointer
    // offa is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* @example example_chpr.c
* Example of how to use the @ref clblasChpr function.
*/
/**
* hermitian rank 1 operation with a general triangular packed-matrix and.
* double-complex elements.
*
* hermitian rank 1 operation:
*   - \f$ A \leftarrow \alpha X X^H + A \f$
*
* @param order (in)     Row/column order.
* @param uplo (in)      The triangle in matrix being referenced.
* @param N (in)         Number of columns in matrix  A.
* @param alpha (in)     The factor of matrix  A (a scalar float value)
* @param X (in)         Buffer object storing vector  X.
* @param offx (in)      Offset in number of elements for the first element in vector  X.
* @param incx (in)      Increment for the elements of  X. Must not be zero.
* @param AP (out) 	    Buffer object storing matrix  AP.
* @param offa (in)      Offset in number of elements for the first element in matrix  AP.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasInvalidDevice if a target device does not support floating
*     point arithmetic with double precision;
*   - the same error codes as the clblasChpr() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasZhprNative(JNIEnv *env, jclass cls, jint order, jint uplo, jlong N, jdouble alpha, jobject X, jlong offx, jint incx, jobject AP, jlong offa, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // N is primitive
    // alpha is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasZhpr");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (AP == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'AP' is null for clblasZhpr");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasZhpr");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasZhpr(order=%d, uplo=%d, N=%ld, alpha=%lf, X=%p, offx=%ld, incx=%d, AP=%p, offa=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, N, alpha, X, offx, incx, AP, offa, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    size_t N_native = 0;
    cl_double alpha_native = 0.0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem AP_native = nullptr;
    size_t offa_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    N_native = (size_t)N;
    alpha_native = (cl_double)alpha;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, AP, AP_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasZhpr(order_native, uplo_native, N_native, alpha_native, X_native, offx_native, incx_native, AP_native, offa_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // N is primitive
    // alpha is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // AP is a read-only native pointer
    // offa is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Symmetric rank 2 operation with a general triangular packed-matrix and.
* float elements.
*
* Symmetric rank 2 operation:
*   - \f$ A \leftarrow \alpha X Y^T + \alpha Y X^T + A \f$
*
* @param order (in)     Row/column order.
* @param uplo (in)      The triangle in matrix being referenced.
* @param N (in)         Number of columns in matrix  A.
* @param alpha (in)     The factor of matrix  A.
* @param X (in)         Buffer object storing vector  X.
* @param offx (in)      Offset of first element of vector  X in buffer object.
* @param incx (in)      Increment for the elements of  X. Must not be zero.
* @param Y (in)         Buffer object storing vector  Y.
* @param offy (in)      Offset of first element of vector  Y in buffer object.
* @param incy (in)      Increment for the elements of  Y. Must not be zero.
* @param AP		Buffer (out) object storing packed-matrix  AP.
* @param offa (in)      Offset of first element of matrix  AP in buffer object.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasNotInitialized if clblasSetup() was not called;
*   -  clblasInvalidValue if invalid parameters are passed:
*     - either  N is zero, or
*     - either  incx or  incy is zero
*   -  clblasInvalidMemObject if either  AP,  X, or  Y object is
*     Invalid, or an image object rather than the buffer one;
*   -  clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   -  clblasInvalidCommandQueue if the passed command queue is invalid;
*   -  clblasInvalidContext if a context a passed command queue belongs
*     to was released;
*   -  clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   -  clblasCompilerNotAvailable if a compiler is not available;
*   -  clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasSspr2Native(JNIEnv *env, jclass cls, jint order, jint uplo, jlong N, jfloat alpha, jobject X, jlong offx, jint incx, jobject Y, jlong offy, jint incy, jobject AP, jlong offa, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // N is primitive
    // alpha is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasSspr2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (Y == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasSspr2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    if (AP == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'AP' is null for clblasSspr2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasSspr2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasSspr2(order=%d, uplo=%d, N=%ld, alpha=%f, X=%p, offx=%ld, incx=%d, Y=%p, offy=%ld, incy=%d, AP=%p, offa=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, N, alpha, X, offx, incx, Y, offy, incy, AP, offa, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    size_t N_native = 0;
    cl_float alpha_native = 0.0f;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_mem AP_native = nullptr;
    size_t offa_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    N_native = (size_t)N;
    alpha_native = (cl_float)alpha;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    if (!initNative(env, AP, AP_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasSspr2(order_native, uplo_native, N_native, alpha_native, X_native, offx_native, incx_native, Y_native, offy_native, incy_native, AP_native, offa_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // N is primitive
    // alpha is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // AP is a read-only native pointer
    // offa is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* @example example_sspr2.c
* Example of how to use the @ref clblasSspr2 function.
*/
/**
* Symmetric rank 2 operation with a general triangular packed-matrix and.
* double elements.
*
* Symmetric rank 2 operation:
*   - \f$ A \leftarrow \alpha X Y^T + \alpha Y X^T + A \f$
*
* @param order (in)     Row/column order.
* @param uplo (in)      The triangle in matrix being referenced.
* @param N (in)         Number of columns in matrix  A.
* @param alpha (in)     The factor of matrix  A.
* @param X (in)         Buffer object storing vector  X.
* @param offx (in)      Offset of first element of vector  X in buffer object.
* @param incx (in)      Increment for the elements of  X. Must not be zero.
* @param Y (in)         Buffer object storing vector  Y.
* @param offy (in)      Offset of first element of vector  Y in buffer object.
* @param incy (in)      Increment for the elements of  Y. Must not be zero.
* @param AP		Buffer (out) object storing packed-matrix  AP.
* @param offa (in)      Offset of first element of matrix  AP in buffer object.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasInvalidDevice if a target device does not support floating
*     point arithmetic with double precision;
*   - the same error codes as the clblasSspr2() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasDspr2Native(JNIEnv *env, jclass cls, jint order, jint uplo, jlong N, jdouble alpha, jobject X, jlong offx, jint incx, jobject Y, jlong offy, jint incy, jobject AP, jlong offa, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // N is primitive
    // alpha is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasDspr2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (Y == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasDspr2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    if (AP == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'AP' is null for clblasDspr2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasDspr2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasDspr2(order=%d, uplo=%d, N=%ld, alpha=%lf, X=%p, offx=%ld, incx=%d, Y=%p, offy=%ld, incy=%d, AP=%p, offa=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, N, alpha, X, offx, incx, Y, offy, incy, AP, offa, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    size_t N_native = 0;
    cl_double alpha_native = 0.0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_mem AP_native = nullptr;
    size_t offa_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    N_native = (size_t)N;
    alpha_native = (cl_double)alpha;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    if (!initNative(env, AP, AP_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasDspr2(order_native, uplo_native, N_native, alpha_native, X_native, offx_native, incx_native, Y_native, offy_native, incy_native, AP_native, offa_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // N is primitive
    // alpha is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // AP is a read-only native pointer
    // offa is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Hermitian rank 2 operation with a general triangular packed-matrix and.
* float-compelx elements.
*
* Hermitian rank 2 operation:
*   - \f$ A \leftarrow \alpha X Y^H + \conjg( alpha ) Y X^H + A \f$
*
* @param order (in)     Row/column order.
* @param uplo (in)      The triangle in matrix being referenced.
* @param N (in)         Number of columns in matrix  A.
* @param alpha (in)     The factor of matrix  A.
* @param X (in)         Buffer object storing vector  X.
* @param offx (in)      Offset in number of elements for the first element in vector  X.
* @param incx (in)      Increment for the elements of  X. Must not be zero.
* @param Y (in)         Buffer object storing vector  Y.
* @param offy (in)      Offset in number of elements for the first element in vector  Y.
* @param incy (in)      Increment for the elements of  Y. Must not be zero.
* @param AP		Buffer (out) object storing packed-matrix  AP.
* @param offa (in)      Offset in number of elements for the first element in matrix  AP.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasNotInitialized if clblasSetup() was not called;
*   -  clblasInvalidValue if invalid parameters are passed:
*     - either  N is zero, or
*     - either  incx or  incy is zero
*   -  clblasInvalidMemObject if either  AP,  X, or  Y object is
*     Invalid, or an image object rather than the buffer one;
*   -  clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   -  clblasInvalidCommandQueue if the passed command queue is invalid;
*   -  clblasInvalidContext if a context a passed command queue belongs
*     to was released;
*   -  clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   -  clblasCompilerNotAvailable if a compiler is not available;
*   -  clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasChpr2Native(JNIEnv *env, jclass cls, jint order, jint uplo, jlong N, jfloatArray alpha, jobject X, jlong offx, jint incx, jobject Y, jlong offy, jint incy, jobject AP, jlong offa, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // N is primitive
    if (alpha == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'alpha' is null for clblasChpr2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasChpr2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (Y == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasChpr2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    if (AP == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'AP' is null for clblasChpr2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasChpr2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasChpr2(order=%d, uplo=%d, N=%ld, alpha=%p, X=%p, offx=%ld, incx=%d, Y=%p, offy=%ld, incy=%d, AP=%p, offa=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, N, alpha, X, offx, incx, Y, offy, incy, AP, offa, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    size_t N_native = 0;
    cl_float2 alpha_native;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_mem AP_native = nullptr;
    size_t offa_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    N_native = (size_t)N;
    if (!initNative(env, alpha, alpha_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    if (!initNative(env, AP, AP_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasChpr2(order_native, uplo_native, N_native, alpha_native, X_native, offx_native, incx_native, Y_native, offy_native, incy_native, AP_native, offa_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // N is primitive
    if (!releaseNative(env, alpha_native, alpha, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // AP is a read-only native pointer
    // offa is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Hermitian rank 2 operation with a general triangular packed-matrix and.
* double-compelx elements.
*
* Hermitian rank 2 operation:
*   - \f$ A \leftarrow \alpha X Y^H + \conjg( alpha ) Y X^H + A \f$
*
* @param order (in)     Row/column order.
* @param uplo (in)      The triangle in matrix being referenced.
* @param N (in)         Number of columns in matrix  A.
* @param alpha (in)     The factor of matrix  A.
* @param X (in)         Buffer object storing vector  X.
* @param offx (in)      Offset in number of elements for the first element in vector  X.
* @param incx (in)      Increment for the elements of  X. Must not be zero.
* @param Y (in)         Buffer object storing vector  Y.
* @param offy (in)      Offset in number of elements for the first element in vector  Y.
* @param incy (in)      Increment for the elements of  Y. Must not be zero.
* @param AP		Buffer (out) object storing packed-matrix  AP.
* @param offa (in)      Offset in number of elements for the first element in matrix  AP.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasInvalidDevice if a target device does not support floating
*     point arithmetic with double precision;
*   - the same error codes as the clblasChpr2() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasZhpr2Native(JNIEnv *env, jclass cls, jint order, jint uplo, jlong N, jdoubleArray alpha, jobject X, jlong offx, jint incx, jobject Y, jlong offy, jint incy, jobject AP, jlong offa, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // N is primitive
    if (alpha == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'alpha' is null for clblasZhpr2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasZhpr2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (Y == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasZhpr2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    if (AP == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'AP' is null for clblasZhpr2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasZhpr2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasZhpr2(order=%d, uplo=%d, N=%ld, alpha=%p, X=%p, offx=%ld, incx=%d, Y=%p, offy=%ld, incy=%d, AP=%p, offa=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, N, alpha, X, offx, incx, Y, offy, incy, AP, offa, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    size_t N_native = 0;
    cl_double2 alpha_native;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_mem AP_native = nullptr;
    size_t offa_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    N_native = (size_t)N;
    if (!initNative(env, alpha, alpha_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    if (!initNative(env, AP, AP_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasZhpr2(order_native, uplo_native, N_native, alpha_native, X_native, offx_native, incx_native, Y_native, offy_native, incy_native, AP_native, offa_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // N is primitive
    if (!releaseNative(env, alpha_native, alpha, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // AP is a read-only native pointer
    // offa is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* @example example_zhpr2.c
* Example of how to use the @ref clblasZhpr2 function.
*/
/**
* Matrix-vector product with a general rectangular banded matrix and.
* float elements.
*
* Matrix-vector products:
*   - \f$ Y \leftarrow \alpha A X + eta Y \f$
*   - \f$ Y \leftarrow \alpha A^T X + eta Y \f$
*
* @param order (in)     Row/column order.
* @param trans (in)     How matrix  A is to be transposed.
* @param M (in)         Number of rows in banded matrix  A.
* @param N (in)         Number of columns in banded matrix  A.
* @param KL (in)        Number of sub-diagonals in banded matrix  A.
* @param KU (in)        Number of super-diagonals in banded matrix  A.
* @param alpha (in)     The factor of banded matrix  A.
* @param A (in)         Buffer object storing banded matrix  A.
* @param offa (in)      Offset in number of elements for the first element in banded matrix  A.
* @param lda (in)       Leading dimension of banded matrix  A. It cannot be less
*                      than (  KL +  KU + 1 )
* @param X (in)         Buffer object storing vector  X.
* @param offx (in)      Offset of first element of vector  X in buffer object.
*                      Counted in elements.
* @param incx (in)      Increment for the elements of  X. Must not be zero.
* @param beta (in)      The factor of the vector  Y.
* @param Y (out)        Buffer object storing the vector  y.
* @param offy (in)      Offset of first element of vector  Y in buffer object.
*                      Counted in elements.
* @param incy (in)      Increment for the elements of  Y. Must not be zero.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasNotInitialized if clblasSetup() was not called;
*   -  clblasInvalidValue if invalid parameters are passed:
*     - either  M or  N is zero, or
*     - KL is greater than  M - 1, or
*     - KU is greater than  N - 1, or
*     - either  incx or  incy is zero, or
*     - any of the leading dimensions is invalid;
*     - the matrix size or the vector sizes along with the increments lead to
*       accessing outside of any of the buffers;
*   -  clblasInvalidMemObject if either  A,  X, or  Y object is
*     Invalid, or an image object rather than the buffer one;
*   -  clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   -  clblasInvalidCommandQueue if the passed command queue is invalid;
*   -  clblasInvalidContext if a context a passed command queue belongs
*     to was released;
*   -  clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   -  clblasCompilerNotAvailable if a compiler is not available;
*   -  clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasSgbmvNative(JNIEnv *env, jclass cls, jint order, jint trans, jlong M, jlong N, jlong KL, jlong KU, jfloat alpha, jobject A, jlong offa, jlong lda, jobject X, jlong offx, jint incx, jfloat beta, jobject Y, jlong offy, jint incy, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // trans is primitive
    // M is primitive
    // N is primitive
    // KL is primitive
    // KU is primitive
    // alpha is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasSgbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasSgbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    // beta is primitive
    if (Y == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasSgbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasSgbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasSgbmv(order=%d, trans=%d, M=%ld, N=%ld, KL=%ld, KU=%ld, alpha=%f, A=%p, offa=%ld, lda=%ld, X=%p, offx=%ld, incx=%d, beta=%f, Y=%p, offy=%ld, incy=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, trans, M, N, KL, KU, alpha, A, offa, lda, X, offx, incx, beta, Y, offy, incy, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasTranspose trans_native;
    size_t M_native = 0;
    size_t N_native = 0;
    size_t KL_native = 0;
    size_t KU_native = 0;
    cl_float alpha_native = 0.0f;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_float beta_native = 0.0f;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    trans_native = (clblasTranspose)trans;
    M_native = (size_t)M;
    N_native = (size_t)N;
    KL_native = (size_t)KL;
    KU_native = (size_t)KU;
    alpha_native = (cl_float)alpha;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    beta_native = (cl_float)beta;
    if (!initNative(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasSgbmv(order_native, trans_native, M_native, N_native, KL_native, KU_native, alpha_native, A_native, offa_native, lda_native, X_native, offx_native, incx_native, beta_native, Y_native, offy_native, incy_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // trans is primitive
    // M is primitive
    // N is primitive
    // KL is primitive
    // KU is primitive
    // alpha is primitive
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // beta is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* @example example_sgbmv.c
* Example of how to use the @ref clblasSgbmv function.
*/
/**
* Matrix-vector product with a general rectangular banded matrix and.
* double elements.
*
* Matrix-vector products:
*   - \f$ Y \leftarrow \alpha A X + eta Y \f$
*   - \f$ Y \leftarrow \alpha A^T X + eta Y \f$
*
* @param order (in)     Row/column order.
* @param trans (in)     How matrix  A is to be transposed.
* @param M (in)         Number of rows in banded matrix  A.
* @param N (in)         Number of columns in banded matrix  A.
* @param KL (in)        Number of sub-diagonals in banded matrix  A.
* @param KU (in)        Number of super-diagonals in banded matrix  A.
* @param alpha (in)     The factor of banded matrix  A.
* @param A (in)         Buffer object storing banded matrix  A.
* @param offa (in)      Offset in number of elements for the first element in banded matrix  A.
* @param lda (in)       Leading dimension of banded matrix  A. It cannot be less
*                      than (  KL +  KU + 1 )
* @param X (in)         Buffer object storing vector  X.
* @param offx (in)      Offset of first element of vector  X in buffer object.
*                      Counted in elements.
* @param incx (in)      Increment for the elements of  X. Must not be zero.
* @param beta (in)      The factor of the vector  Y.
* @param Y (out)        Buffer object storing the vector  y.
* @param offy (in)      Offset of first element of vector  Y in buffer object.
*                      Counted in elements.
* @param incy (in)      Increment for the elements of  Y. Must not be zero.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasInvalidDevice if a target device does not support floating
*     point arithmetic with double precision;
*   - the same error codes as the clblasSgbmv() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasDgbmvNative(JNIEnv *env, jclass cls, jint order, jint trans, jlong M, jlong N, jlong KL, jlong KU, jdouble alpha, jobject A, jlong offa, jlong lda, jobject X, jlong offx, jint incx, jdouble beta, jobject Y, jlong offy, jint incy, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // trans is primitive
    // M is primitive
    // N is primitive
    // KL is primitive
    // KU is primitive
    // alpha is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasDgbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasDgbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    // beta is primitive
    if (Y == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasDgbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasDgbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasDgbmv(order=%d, trans=%d, M=%ld, N=%ld, KL=%ld, KU=%ld, alpha=%lf, A=%p, offa=%ld, lda=%ld, X=%p, offx=%ld, incx=%d, beta=%lf, Y=%p, offy=%ld, incy=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, trans, M, N, KL, KU, alpha, A, offa, lda, X, offx, incx, beta, Y, offy, incy, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasTranspose trans_native;
    size_t M_native = 0;
    size_t N_native = 0;
    size_t KL_native = 0;
    size_t KU_native = 0;
    cl_double alpha_native = 0.0;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_double beta_native = 0.0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    trans_native = (clblasTranspose)trans;
    M_native = (size_t)M;
    N_native = (size_t)N;
    KL_native = (size_t)KL;
    KU_native = (size_t)KU;
    alpha_native = (cl_double)alpha;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    beta_native = (cl_double)beta;
    if (!initNative(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasDgbmv(order_native, trans_native, M_native, N_native, KL_native, KU_native, alpha_native, A_native, offa_native, lda_native, X_native, offx_native, incx_native, beta_native, Y_native, offy_native, incy_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // trans is primitive
    // M is primitive
    // N is primitive
    // KL is primitive
    // KU is primitive
    // alpha is primitive
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // beta is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Matrix-vector product with a general rectangular banded matrix and.
* float-complex elements.
*
* Matrix-vector products:
*   - \f$ Y \leftarrow \alpha A X + eta Y \f$
*   - \f$ Y \leftarrow \alpha A^T X + eta Y \f$
*
* @param order (in)     Row/column order.
* @param trans (in)     How matrix  A is to be transposed.
* @param M (in)         Number of rows in banded matrix  A.
* @param N (in)         Number of columns in banded matrix  A.
* @param KL (in)        Number of sub-diagonals in banded matrix  A.
* @param KU (in)        Number of super-diagonals in banded matrix  A.
* @param alpha (in)     The factor of banded matrix  A.
* @param A (in)         Buffer object storing banded matrix  A.
* @param offa (in)      Offset in number of elements for the first element in banded matrix  A.
* @param lda (in)       Leading dimension of banded matrix  A. It cannot be less
*                      than (  KL +  KU + 1 )
* @param X (in)         Buffer object storing vector  X.
* @param offx (in)      Offset of first element of vector  X in buffer object.
*                      Counted in elements.
* @param incx (in)      Increment for the elements of  X. Must not be zero.
* @param beta (in)      The factor of the vector  Y.
* @param Y (out)        Buffer object storing the vector  y.
* @param offy (in)      Offset of first element of vector  Y in buffer object.
*                      Counted in elements.
* @param incy (in)      Increment for the elements of  Y. Must not be zero.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return The same result as the clblasSgbmv() function.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasCgbmvNative(JNIEnv *env, jclass cls, jint order, jint trans, jlong M, jlong N, jlong KL, jlong KU, jfloatArray alpha, jobject A, jlong offa, jlong lda, jobject X, jlong offx, jint incx, jfloatArray beta, jobject Y, jlong offy, jint incy, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // trans is primitive
    // M is primitive
    // N is primitive
    // KL is primitive
    // KU is primitive
    if (alpha == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'alpha' is null for clblasCgbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasCgbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasCgbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (beta == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'beta' is null for clblasCgbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (Y == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasCgbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasCgbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasCgbmv(order=%d, trans=%d, M=%ld, N=%ld, KL=%ld, KU=%ld, alpha=%p, A=%p, offa=%ld, lda=%ld, X=%p, offx=%ld, incx=%d, beta=%p, Y=%p, offy=%ld, incy=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, trans, M, N, KL, KU, alpha, A, offa, lda, X, offx, incx, beta, Y, offy, incy, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasTranspose trans_native;
    size_t M_native = 0;
    size_t N_native = 0;
    size_t KL_native = 0;
    size_t KU_native = 0;
    cl_float2 alpha_native;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_float2 beta_native;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    trans_native = (clblasTranspose)trans;
    M_native = (size_t)M;
    N_native = (size_t)N;
    KL_native = (size_t)KL;
    KU_native = (size_t)KU;
    if (!initNative(env, alpha, alpha_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, beta, beta_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasCgbmv(order_native, trans_native, M_native, N_native, KL_native, KU_native, alpha_native, A_native, offa_native, lda_native, X_native, offx_native, incx_native, beta_native, Y_native, offy_native, incy_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // trans is primitive
    // M is primitive
    // N is primitive
    // KL is primitive
    // KU is primitive
    if (!releaseNative(env, alpha_native, alpha, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    if (!releaseNative(env, beta_native, beta, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Matrix-vector product with a general rectangular banded matrix and.
* double-complex elements.
*
* Matrix-vector products:
*   - \f$ Y \leftarrow \alpha A X + eta Y \f$
*   - \f$ Y \leftarrow \alpha A^T X + eta Y \f$
*
* @param order (in)     Row/column order.
* @param trans (in)     How matrix  A is to be transposed.
* @param M (in)         Number of rows in banded matrix  A.
* @param N (in)         Number of columns in banded matrix  A.
* @param KL (in)        Number of sub-diagonals in banded matrix  A.
* @param KU (in)        Number of super-diagonals in banded matrix  A.
* @param alpha (in)     The factor of banded matrix  A.
* @param A (in)         Buffer object storing banded matrix  A.
* @param offa (in)      Offset in number of elements for the first element in banded matrix  A.
* @param lda (in)       Leading dimension of banded matrix  A. It cannot be less
*                      than (  KL +  KU + 1 )
* @param X (in)         Buffer object storing vector  X.
* @param offx (in)      Offset of first element of vector  X in buffer object.
*                      Counted in elements.
* @param incx (in)      Increment for the elements of  X. Must not be zero.
* @param beta (in)      The factor of the vector  Y.
* @param Y (out)        Buffer object storing the vector  y.
* @param offy (in)      Offset of first element of vector  Y in buffer object.
*                      Counted in elements.
* @param incy (in)      Increment for the elements of  Y. Must not be zero.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return The same result as the clblasDgbmv() function.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasZgbmvNative(JNIEnv *env, jclass cls, jint order, jint trans, jlong M, jlong N, jlong KL, jlong KU, jdoubleArray alpha, jobject A, jlong offa, jlong lda, jobject X, jlong offx, jint incx, jdoubleArray beta, jobject Y, jlong offy, jint incy, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // trans is primitive
    // M is primitive
    // N is primitive
    // KL is primitive
    // KU is primitive
    if (alpha == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'alpha' is null for clblasZgbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasZgbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasZgbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (beta == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'beta' is null for clblasZgbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (Y == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasZgbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasZgbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasZgbmv(order=%d, trans=%d, M=%ld, N=%ld, KL=%ld, KU=%ld, alpha=%p, A=%p, offa=%ld, lda=%ld, X=%p, offx=%ld, incx=%d, beta=%p, Y=%p, offy=%ld, incy=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, trans, M, N, KL, KU, alpha, A, offa, lda, X, offx, incx, beta, Y, offy, incy, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasTranspose trans_native;
    size_t M_native = 0;
    size_t N_native = 0;
    size_t KL_native = 0;
    size_t KU_native = 0;
    cl_double2 alpha_native;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_double2 beta_native;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    trans_native = (clblasTranspose)trans;
    M_native = (size_t)M;
    N_native = (size_t)N;
    KL_native = (size_t)KL;
    KU_native = (size_t)KU;
    if (!initNative(env, alpha, alpha_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, beta, beta_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasZgbmv(order_native, trans_native, M_native, N_native, KL_native, KU_native, alpha_native, A_native, offa_native, lda_native, X_native, offx_native, incx_native, beta_native, Y_native, offy_native, incy_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // trans is primitive
    // M is primitive
    // N is primitive
    // KL is primitive
    // KU is primitive
    if (!releaseNative(env, alpha_native, alpha, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    if (!releaseNative(env, beta_native, beta, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Matrix-vector product with a triangular banded matrix and.
* float elements.
*
* Matrix-vector products:
*   - \f$ X \leftarrow  A X \f$
*   - \f$ X \leftarrow  A^T X \f$
*
* @param order				Row/column (in) order.
* @param uplo				The (in) triangle in matrix being referenced.
* @param trans				How (in) matrix  A is to be transposed.
* @param diag				Specify (in) whether matrix  A is unit triangular.
* @param N					Number (in) of rows/columns in banded matrix  A.
* @param K					Number (in) of sub-diagonals/super-diagonals in triangular banded matrix  A.
* @param A					Buffer (in) object storing matrix  A.
* @param offa				Offset (in) in number of elements for first element in matrix  A.
* @param lda				Leading (in) dimension of matrix  A. It cannot be less
*								than (  K + 1 )
* @param X				Buffer (out) object storing vector  X.
* @param offx				Offset (in) in number of elements for first element in vector  X.
* @param incx				Increment (in) for the elements of  X. Must not be zero.
* @param scratchBuff		Temporary (in) cl_mem scratch buffer object which can hold a
*								minimum of (1 + (N-1)*abs(incx)) elements
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasNotInitialized if clblasSetup() was not called;
*   -  clblasInvalidValue if invalid parameters are passed:
*     - either  N or  incx is zero, or
*     - K is greater than  N - 1
*     - the leading dimension is invalid;
*   -  clblasInvalidMemObject if either  A or  X object is
*     Invalid, or an image object rather than the buffer one;
*   -  clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   -  clblasInvalidCommandQueue if the passed command queue is invalid;
*   -  clblasInvalidContext if a context a passed command queue belongs
*     to was released;
*   -  clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   -  clblasCompilerNotAvailable if a compiler is not available;
*   -  clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasStbmvNative(JNIEnv *env, jclass cls, jint order, jint uplo, jint trans, jint diag, jlong N, jlong K, jobject A, jlong offa, jlong lda, jobject X, jlong offx, jint incx, jobject scratchBuff, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    // K is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasStbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasStbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (scratchBuff == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'scratchBuff' is null for clblasStbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasStbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasStbmv(order=%d, uplo=%d, trans=%d, diag=%d, N=%ld, K=%ld, A=%p, offa=%ld, lda=%ld, X=%p, offx=%ld, incx=%d, scratchBuff=%p, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, trans, diag, N, K, A, offa, lda, X, offx, incx, scratchBuff, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    clblasTranspose trans_native;
    clblasDiag diag_native;
    size_t N_native = 0;
    size_t K_native = 0;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem scratchBuff_native = nullptr;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    trans_native = (clblasTranspose)trans;
    diag_native = (clblasDiag)diag;
    N_native = (size_t)N;
    K_native = (size_t)K;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, scratchBuff, scratchBuff_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasStbmv(order_native, uplo_native, trans_native, diag_native, N_native, K_native, A_native, offa_native, lda_native, X_native, offx_native, incx_native, scratchBuff_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    // K is primitive
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // scratchBuff is a read-only native pointer
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* @example example_stbmv.c
* Example of how to use the @ref clblasStbmv function.
*/
/**
* Matrix-vector product with a triangular banded matrix and.
* double elements.
*
* Matrix-vector products:
*   - \f$ X \leftarrow  A X \f$
*   - \f$ X \leftarrow  A^T X \f$
*
* @param order				Row/column (in) order.
* @param uplo				The (in) triangle in matrix being referenced.
* @param trans				How (in) matrix  A is to be transposed.
* @param diag				Specify (in) whether matrix  A is unit triangular.
* @param N					Number (in) of rows/columns in banded matrix  A.
* @param K					Number (in) of sub-diagonals/super-diagonals in triangular banded matrix  A.
* @param A					Buffer (in) object storing matrix  A.
* @param offa				Offset (in) in number of elements for first element in matrix  A.
* @param lda				Leading (in) dimension of matrix  A. It cannot be less
*								than (  K + 1 )
* @param X				Buffer (out) object storing vector  X.
* @param offx				Offset (in) in number of elements for first element in vector  X.
* @param incx				Increment (in) for the elements of  X. Must not be zero.
* @param scratchBuff		Temporary (in) cl_mem scratch buffer object which can hold a
*								minimum of (1 + (N-1)*abs(incx)) elements
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasInvalidDevice if a target device does not support floating
*     point arithmetic with double precision;
*   - the same error codes as the clblasStbmv() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasDtbmvNative(JNIEnv *env, jclass cls, jint order, jint uplo, jint trans, jint diag, jlong N, jlong K, jobject A, jlong offa, jlong lda, jobject X, jlong offx, jint incx, jobject scratchBuff, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    // K is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasDtbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasDtbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (scratchBuff == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'scratchBuff' is null for clblasDtbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasDtbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasDtbmv(order=%d, uplo=%d, trans=%d, diag=%d, N=%ld, K=%ld, A=%p, offa=%ld, lda=%ld, X=%p, offx=%ld, incx=%d, scratchBuff=%p, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, trans, diag, N, K, A, offa, lda, X, offx, incx, scratchBuff, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    clblasTranspose trans_native;
    clblasDiag diag_native;
    size_t N_native = 0;
    size_t K_native = 0;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem scratchBuff_native = nullptr;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    trans_native = (clblasTranspose)trans;
    diag_native = (clblasDiag)diag;
    N_native = (size_t)N;
    K_native = (size_t)K;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, scratchBuff, scratchBuff_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasDtbmv(order_native, uplo_native, trans_native, diag_native, N_native, K_native, A_native, offa_native, lda_native, X_native, offx_native, incx_native, scratchBuff_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    // K is primitive
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // scratchBuff is a read-only native pointer
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Matrix-vector product with a triangular banded matrix and.
* float-complex elements.
*
* Matrix-vector products:
*   - \f$ X \leftarrow  A X \f$
*   - \f$ X \leftarrow  A^T X \f$
*
* @param order				Row/column (in) order.
* @param uplo				The (in) triangle in matrix being referenced.
* @param trans				How (in) matrix  A is to be transposed.
* @param diag				Specify (in) whether matrix  A is unit triangular.
* @param N					Number (in) of rows/columns in banded matrix  A.
* @param K					Number (in) of sub-diagonals/super-diagonals in triangular banded matrix  A.
* @param A					Buffer (in) object storing matrix  A.
* @param offa				Offset (in) in number of elements for first element in matrix  A.
* @param lda				Leading (in) dimension of matrix  A. It cannot be less
*								than (  K + 1 )
* @param X				Buffer (out) object storing vector  X.
* @param offx				Offset (in) in number of elements for first element in vector  X.
* @param incx				Increment (in) for the elements of  X. Must not be zero.
* @param scratchBuff		Temporary (in) cl_mem scratch buffer object which can hold a
*								minimum of (1 + (N-1)*abs(incx)) elements
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return The same result as the clblasStbmv() function.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasCtbmvNative(JNIEnv *env, jclass cls, jint order, jint uplo, jint trans, jint diag, jlong N, jlong K, jobject A, jlong offa, jlong lda, jobject X, jlong offx, jint incx, jobject scratchBuff, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    // K is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasCtbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasCtbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (scratchBuff == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'scratchBuff' is null for clblasCtbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasCtbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasCtbmv(order=%d, uplo=%d, trans=%d, diag=%d, N=%ld, K=%ld, A=%p, offa=%ld, lda=%ld, X=%p, offx=%ld, incx=%d, scratchBuff=%p, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, trans, diag, N, K, A, offa, lda, X, offx, incx, scratchBuff, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    clblasTranspose trans_native;
    clblasDiag diag_native;
    size_t N_native = 0;
    size_t K_native = 0;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem scratchBuff_native = nullptr;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    trans_native = (clblasTranspose)trans;
    diag_native = (clblasDiag)diag;
    N_native = (size_t)N;
    K_native = (size_t)K;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, scratchBuff, scratchBuff_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasCtbmv(order_native, uplo_native, trans_native, diag_native, N_native, K_native, A_native, offa_native, lda_native, X_native, offx_native, incx_native, scratchBuff_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    // K is primitive
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // scratchBuff is a read-only native pointer
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Matrix-vector product with a triangular banded matrix and.
* double-complex elements.
*
* Matrix-vector products:
*   - \f$ X \leftarrow  A X \f$
*   - \f$ X \leftarrow  A^T X \f$
*
* @param order				Row/column (in) order.
* @param uplo				The (in) triangle in matrix being referenced.
* @param trans				How (in) matrix  A is to be transposed.
* @param diag				Specify (in) whether matrix  A is unit triangular.
* @param N					Number (in) of rows/columns in banded matrix  A.
* @param K					Number (in) of sub-diagonals/super-diagonals in triangular banded matrix  A.
* @param A					Buffer (in) object storing matrix  A.
* @param offa				Offset (in) in number of elements for first element in matrix  A.
* @param lda				Leading (in) dimension of matrix  A. It cannot be less
*								than (  K + 1 )
* @param X				Buffer (out) object storing vector  X.
* @param offx				Offset (in) in number of elements for first element in vector  X.
* @param incx				Increment (in) for the elements of  X. Must not be zero.
* @param scratchBuff		Temporary (in) cl_mem scratch buffer object which can hold a
*								minimum of (1 + (N-1)*abs(incx)) elements
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return The same result as the clblasDtbmv() function.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasZtbmvNative(JNIEnv *env, jclass cls, jint order, jint uplo, jint trans, jint diag, jlong N, jlong K, jobject A, jlong offa, jlong lda, jobject X, jlong offx, jint incx, jobject scratchBuff, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    // K is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasZtbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasZtbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (scratchBuff == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'scratchBuff' is null for clblasZtbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasZtbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasZtbmv(order=%d, uplo=%d, trans=%d, diag=%d, N=%ld, K=%ld, A=%p, offa=%ld, lda=%ld, X=%p, offx=%ld, incx=%d, scratchBuff=%p, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, trans, diag, N, K, A, offa, lda, X, offx, incx, scratchBuff, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    clblasTranspose trans_native;
    clblasDiag diag_native;
    size_t N_native = 0;
    size_t K_native = 0;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem scratchBuff_native = nullptr;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    trans_native = (clblasTranspose)trans;
    diag_native = (clblasDiag)diag;
    N_native = (size_t)N;
    K_native = (size_t)K;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, scratchBuff, scratchBuff_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasZtbmv(order_native, uplo_native, trans_native, diag_native, N_native, K_native, A_native, offa_native, lda_native, X_native, offx_native, incx_native, scratchBuff_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    // K is primitive
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // scratchBuff is a read-only native pointer
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Matrix-vector product with a symmetric banded matrix and float elements..
*
* Matrix-vector products:
* - \f$ Y \leftarrow \alpha A X + eta Y \f$
*
* @param order (in)     Row/columns order.
* @param uplo (in)      The triangle in matrix being referenced.
* @param N (in)         Number of rows and columns in banded matrix  A.
* @param K			Number (in) of sub-diagonals/super-diagonals in banded matrix  A.
* @param alpha (in)     The factor of matrix  A.
* @param A			Buffer (in) object storing matrix  A.
* @param offa		Offset (in) in number of elements for first element in matrix  A.
* @param lda		Leading (in) dimension of matrix  A. It cannot be less
*						than (  K + 1 )
* @param X (in)         Buffer object storing vector  X.
* @param offx (in)      Offset of first element of vector  X in buffer object.
*                      Counted in elements.
* @param incx (in)      Increment for the elements of vector  X. It cannot be zero.
* @param beta (in)      The factor of vector  Y.
* @param Y (out)        Buffer object storing vector  Y.
* @param offy (in)      Offset of first element of vector  Y in buffer object.
*                      Counted in elements.
* @param incy (in)      Increment for the elements of vector  Y. It cannot be zero.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasNotInitialized if clblasSetup() was not called;
*   -  clblasInvalidValue if invalid parameters are passed:
*     - either  N or  incx is zero, or
*     - K is greater than  N - 1
*     - the leading dimension is invalid;
*   -  clblasInvalidMemObject if either  A or  X object is
*     Invalid, or an image object rather than the buffer one;
*   -  clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   -  clblasInvalidCommandQueue if the passed command queue is invalid;
*   -  clblasInvalidContext if a context a passed command queue belongs
*     to was released;
*   -  clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   -  clblasCompilerNotAvailable if a compiler is not available;
*   -  clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasSsbmvNative(JNIEnv *env, jclass cls, jint order, jint uplo, jlong N, jlong K, jfloat alpha, jobject A, jlong offa, jlong lda, jobject X, jlong offx, jint incx, jfloat beta, jobject Y, jlong offy, jint incy, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // N is primitive
    // K is primitive
    // alpha is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasSsbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasSsbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    // beta is primitive
    if (Y == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasSsbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasSsbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasSsbmv(order=%d, uplo=%d, N=%ld, K=%ld, alpha=%f, A=%p, offa=%ld, lda=%ld, X=%p, offx=%ld, incx=%d, beta=%f, Y=%p, offy=%ld, incy=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, N, K, alpha, A, offa, lda, X, offx, incx, beta, Y, offy, incy, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    size_t N_native = 0;
    size_t K_native = 0;
    cl_float alpha_native = 0.0f;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_float beta_native = 0.0f;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    N_native = (size_t)N;
    K_native = (size_t)K;
    alpha_native = (cl_float)alpha;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    beta_native = (cl_float)beta;
    if (!initNative(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasSsbmv(order_native, uplo_native, N_native, K_native, alpha_native, A_native, offa_native, lda_native, X_native, offx_native, incx_native, beta_native, Y_native, offy_native, incy_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // N is primitive
    // K is primitive
    // alpha is primitive
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // beta is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* @example example_ssbmv.c
* This is an example of how to use the @ref clblasSsbmv function.
*/
/**
* Matrix-vector product with a symmetric banded matrix and double elements..
*
* Matrix-vector products:
* - \f$ Y \leftarrow \alpha A X + eta Y \f$
*
* @param order (in)     Row/columns order.
* @param uplo (in)      The triangle in matrix being referenced.
* @param N (in)         Number of rows and columns in banded matrix  A.
* @param K			Number (in) of sub-diagonals/super-diagonals in banded matrix  A.
* @param alpha (in)     The factor of matrix  A.
* @param A			Buffer (in) object storing matrix  A.
* @param offa		Offset (in) in number of elements for first element in matrix  A.
* @param lda		Leading (in) dimension of matrix  A. It cannot be less
*						than (  K + 1 )
* @param X (in)         Buffer object storing vector  X.
* @param offx (in)      Offset of first element of vector  X in buffer object.
*                      Counted in elements.
* @param incx (in)      Increment for the elements of vector  X. It cannot be zero.
* @param beta (in)      The factor of vector  Y.
* @param Y (out)        Buffer object storing vector  Y.
* @param offy (in)      Offset of first element of vector  Y in buffer object.
*                      Counted in elements.
* @param incy (in)      Increment for the elements of vector  Y. It cannot be zero.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasInvalidDevice if a target device does not support floating
*     point arithmetic with double precision;
*   - the same error codes as the clblasSsbmv() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasDsbmvNative(JNIEnv *env, jclass cls, jint order, jint uplo, jlong N, jlong K, jdouble alpha, jobject A, jlong offa, jlong lda, jobject X, jlong offx, jint incx, jdouble beta, jobject Y, jlong offy, jint incy, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // N is primitive
    // K is primitive
    // alpha is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasDsbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasDsbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    // beta is primitive
    if (Y == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasDsbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasDsbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasDsbmv(order=%d, uplo=%d, N=%ld, K=%ld, alpha=%lf, A=%p, offa=%ld, lda=%ld, X=%p, offx=%ld, incx=%d, beta=%lf, Y=%p, offy=%ld, incy=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, N, K, alpha, A, offa, lda, X, offx, incx, beta, Y, offy, incy, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    size_t N_native = 0;
    size_t K_native = 0;
    cl_double alpha_native = 0.0;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_double beta_native = 0.0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    N_native = (size_t)N;
    K_native = (size_t)K;
    alpha_native = (cl_double)alpha;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    beta_native = (cl_double)beta;
    if (!initNative(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasDsbmv(order_native, uplo_native, N_native, K_native, alpha_native, A_native, offa_native, lda_native, X_native, offx_native, incx_native, beta_native, Y_native, offy_native, incy_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // N is primitive
    // K is primitive
    // alpha is primitive
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // beta is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Matrix-vector product with a hermitian banded matrix and float elements..
*
* Matrix-vector products:
* - \f$ Y \leftarrow \alpha A X + eta Y \f$
*
* @param order (in)     Row/columns order.
* @param uplo (in)      The triangle in matrix being referenced.
* @param N (in)         Number of rows and columns in banded matrix  A.
* @param K			Number (in) of sub-diagonals/super-diagonals in banded matrix  A.
* @param alpha (in)     The factor of matrix  A.
* @param A			Buffer (in) object storing matrix  A.
* @param offa		Offset (in) in number of elements for first element in matrix  A.
* @param lda		Leading (in) dimension of matrix  A. It cannot be less
*						than (  K + 1 )
* @param X (in)         Buffer object storing vector  X.
* @param offx (in)      Offset of first element of vector  X in buffer object.
*                      Counted in elements.
* @param incx (in)      Increment for the elements of vector  X. It cannot be zero.
* @param beta (in)      The factor of vector  Y.
* @param Y (out)        Buffer object storing vector  Y.
* @param offy (in)      Offset of first element of vector  Y in buffer object.
*                      Counted in elements.
* @param incy (in)      Increment for the elements of vector  Y. It cannot be zero.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasNotInitialized if clblasSetup() was not called;
*   -  clblasInvalidValue if invalid parameters are passed:
*     - either  N or  incx is zero, or
*     - K is greater than  N - 1
*     - the leading dimension is invalid;
*   -  clblasInvalidMemObject if either  A or  X object is
*     Invalid, or an image object rather than the buffer one;
*   -  clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   -  clblasInvalidCommandQueue if the passed command queue is invalid;
*   -  clblasInvalidContext if a context a passed command queue belongs
*     to was released;
*   -  clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   -  clblasCompilerNotAvailable if a compiler is not available;
*   -  clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasChbmvNative(JNIEnv *env, jclass cls, jint order, jint uplo, jlong N, jlong K, jfloatArray alpha, jobject A, jlong offa, jlong lda, jobject X, jlong offx, jint incx, jfloatArray beta, jobject Y, jlong offy, jint incy, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // N is primitive
    // K is primitive
    if (alpha == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'alpha' is null for clblasChbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasChbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasChbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (beta == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'beta' is null for clblasChbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (Y == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasChbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasChbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasChbmv(order=%d, uplo=%d, N=%ld, K=%ld, alpha=%p, A=%p, offa=%ld, lda=%ld, X=%p, offx=%ld, incx=%d, beta=%p, Y=%p, offy=%ld, incy=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, N, K, alpha, A, offa, lda, X, offx, incx, beta, Y, offy, incy, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    size_t N_native = 0;
    size_t K_native = 0;
    cl_float2 alpha_native;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_float2 beta_native;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    N_native = (size_t)N;
    K_native = (size_t)K;
    if (!initNative(env, alpha, alpha_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, beta, beta_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasChbmv(order_native, uplo_native, N_native, K_native, alpha_native, A_native, offa_native, lda_native, X_native, offx_native, incx_native, beta_native, Y_native, offy_native, incy_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // N is primitive
    // K is primitive
    if (!releaseNative(env, alpha_native, alpha, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    if (!releaseNative(env, beta_native, beta, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* @example example_chbmv.c
* This is an example of how to use the @ref clblasChbmv function.
*/
/**
* Matrix-vector product with a hermitian banded matrix and double elements..
*
* Matrix-vector products:
* - \f$ Y \leftarrow \alpha A X + eta Y \f$
*
* @param order (in)     Row/columns order.
* @param uplo (in)      The triangle in matrix being referenced.
* @param N (in)         Number of rows and columns in banded matrix  A.
* @param K			Number (in) of sub-diagonals/super-diagonals in banded matrix  A.
* @param alpha (in)     The factor of matrix  A.
* @param A			Buffer (in) object storing matrix  A.
* @param offa		Offset (in) in number of elements for first element in matrix  A.
* @param lda		Leading (in) dimension of matrix  A. It cannot be less
*						than (  K + 1 )
* @param X (in)         Buffer object storing vector  X.
* @param offx (in)      Offset of first element of vector  X in buffer object.
*                      Counted in elements.
* @param incx (in)      Increment for the elements of vector  X. It cannot be zero.
* @param beta (in)      The factor of vector  Y.
* @param Y (out)        Buffer object storing vector  Y.
* @param offy (in)      Offset of first element of vector  Y in buffer object.
*                      Counted in elements.
* @param incy (in)      Increment for the elements of vector  Y. It cannot be zero.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasInvalidDevice if a target device does not support floating
*     point arithmetic with double precision;
*   - the same error codes as the clblasChbmv() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasZhbmvNative(JNIEnv *env, jclass cls, jint order, jint uplo, jlong N, jlong K, jdoubleArray alpha, jobject A, jlong offa, jlong lda, jobject X, jlong offx, jint incx, jdoubleArray beta, jobject Y, jlong offy, jint incy, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // N is primitive
    // K is primitive
    if (alpha == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'alpha' is null for clblasZhbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasZhbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasZhbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (beta == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'beta' is null for clblasZhbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (Y == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasZhbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasZhbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasZhbmv(order=%d, uplo=%d, N=%ld, K=%ld, alpha=%p, A=%p, offa=%ld, lda=%ld, X=%p, offx=%ld, incx=%d, beta=%p, Y=%p, offy=%ld, incy=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, N, K, alpha, A, offa, lda, X, offx, incx, beta, Y, offy, incy, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    size_t N_native = 0;
    size_t K_native = 0;
    cl_double2 alpha_native;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_double2 beta_native;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    N_native = (size_t)N;
    K_native = (size_t)K;
    if (!initNative(env, alpha, alpha_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!initNative(env, beta, beta_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasZhbmv(order_native, uplo_native, N_native, K_native, alpha_native, A_native, offa_native, lda_native, X_native, offx_native, incx_native, beta_native, Y_native, offy_native, incy_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // N is primitive
    // K is primitive
    if (!releaseNative(env, alpha_native, alpha, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    if (!releaseNative(env, beta_native, beta, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* solving triangular banded matrix problems with float elements..
*
* Matrix-vector products:
*   - \f$ A X \leftarrow  X \f$
*   - \f$ A^T X \leftarrow  X \f$
*
* @param order				Row/column (in) order.
* @param uplo				The (in) triangle in matrix being referenced.
* @param trans				How (in) matrix  A is to be transposed.
* @param diag				Specify (in) whether matrix  A is unit triangular.
* @param N					Number (in) of rows/columns in banded matrix  A.
* @param K					Number (in) of sub-diagonals/super-diagonals in triangular banded matrix  A.
* @param A					Buffer (in) object storing matrix  A.
* @param offa				Offset (in) in number of elements for first element in matrix  A.
* @param lda				Leading (in) dimension of matrix  A. It cannot be less
*								than (  K + 1 )
* @param X				Buffer (out) object storing vector  X.
* @param offx				Offset (in) in number of elements for first element in vector  X.
* @param incx				Increment (in) for the elements of  X. Must not be zero.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasNotInitialized if clblasSetup() was not called;
*   -  clblasInvalidValue if invalid parameters are passed:
*     - either  N or  incx is zero, or
*     - K is greater than  N - 1
*     - the leading dimension is invalid;
*   -  clblasInvalidMemObject if either  A or  X object is
*     Invalid, or an image object rather than the buffer one;
*   -  clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   -  clblasInvalidCommandQueue if the passed command queue is invalid;
*   -  clblasInvalidContext if a context a passed command queue belongs
*     to was released;
*   -  clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   -  clblasCompilerNotAvailable if a compiler is not available;
*   -  clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasStbsvNative(JNIEnv *env, jclass cls, jint order, jint uplo, jint trans, jint diag, jlong N, jlong K, jobject A, jlong offa, jlong lda, jobject X, jlong offx, jint incx, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    // K is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasStbsv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasStbsv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasStbsv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasStbsv(order=%d, uplo=%d, trans=%d, diag=%d, N=%ld, K=%ld, A=%p, offa=%ld, lda=%ld, X=%p, offx=%ld, incx=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, trans, diag, N, K, A, offa, lda, X, offx, incx, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    clblasTranspose trans_native;
    clblasDiag diag_native;
    size_t N_native = 0;
    size_t K_native = 0;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    trans_native = (clblasTranspose)trans;
    diag_native = (clblasDiag)diag;
    N_native = (size_t)N;
    K_native = (size_t)K;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasStbsv(order_native, uplo_native, trans_native, diag_native, N_native, K_native, A_native, offa_native, lda_native, X_native, offx_native, incx_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    // K is primitive
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* @example example_stbsv.c
* This is an example of how to use the @ref clblasStbsv function.
*/
/**
* solving triangular banded matrix problems with double elements..
*
* Matrix-vector products:
*   - \f$ A X \leftarrow  X \f$
*   - \f$ A^T X \leftarrow  X \f$
*
* @param order				Row/column (in) order.
* @param uplo				The (in) triangle in matrix being referenced.
* @param trans				How (in) matrix  A is to be transposed.
* @param diag				Specify (in) whether matrix  A is unit triangular.
* @param N					Number (in) of rows/columns in banded matrix  A.
* @param K					Number (in) of sub-diagonals/super-diagonals in triangular banded matrix  A.
* @param A					Buffer (in) object storing matrix  A.
* @param offa				Offset (in) in number of elements for first element in matrix  A.
* @param lda				Leading (in) dimension of matrix  A. It cannot be less
*								than (  K + 1 )
* @param X				Buffer (out) object storing vector  X.
* @param offx				Offset (in) in number of elements for first element in vector  X.
* @param incx				Increment (in) for the elements of  X. Must not be zero.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasInvalidDevice if a target device does not support floating
*     point arithmetic with double precision;
*   - the same error codes as the clblasStbsv() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasDtbsvNative(JNIEnv *env, jclass cls, jint order, jint uplo, jint trans, jint diag, jlong N, jlong K, jobject A, jlong offa, jlong lda, jobject X, jlong offx, jint incx, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    // K is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasDtbsv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasDtbsv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasDtbsv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasDtbsv(order=%d, uplo=%d, trans=%d, diag=%d, N=%ld, K=%ld, A=%p, offa=%ld, lda=%ld, X=%p, offx=%ld, incx=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, trans, diag, N, K, A, offa, lda, X, offx, incx, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    clblasTranspose trans_native;
    clblasDiag diag_native;
    size_t N_native = 0;
    size_t K_native = 0;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    trans_native = (clblasTranspose)trans;
    diag_native = (clblasDiag)diag;
    N_native = (size_t)N;
    K_native = (size_t)K;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasDtbsv(order_native, uplo_native, trans_native, diag_native, N_native, K_native, A_native, offa_native, lda_native, X_native, offx_native, incx_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    // K is primitive
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* solving triangular banded matrix problems with float-complex elements..
*
* Matrix-vector products:
*   - \f$ A X \leftarrow  X \f$
*   - \f$ A^T X \leftarrow  X \f$
*
* @param order				Row/column (in) order.
* @param uplo				The (in) triangle in matrix being referenced.
* @param trans				How (in) matrix  A is to be transposed.
* @param diag				Specify (in) whether matrix  A is unit triangular.
* @param N					Number (in) of rows/columns in banded matrix  A.
* @param K					Number (in) of sub-diagonals/super-diagonals in triangular banded matrix  A.
* @param A					Buffer (in) object storing matrix  A.
* @param offa				Offset (in) in number of elements for first element in matrix  A.
* @param lda				Leading (in) dimension of matrix  A. It cannot be less
*								than (  K + 1 )
* @param X				Buffer (out) object storing vector  X.
* @param offx				Offset (in) in number of elements for first element in vector  X.
* @param incx				Increment (in) for the elements of  X. Must not be zero.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return The same result as the clblasStbsv() function.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasCtbsvNative(JNIEnv *env, jclass cls, jint order, jint uplo, jint trans, jint diag, jlong N, jlong K, jobject A, jlong offa, jlong lda, jobject X, jlong offx, jint incx, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    // K is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasCtbsv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasCtbsv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasCtbsv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasCtbsv(order=%d, uplo=%d, trans=%d, diag=%d, N=%ld, K=%ld, A=%p, offa=%ld, lda=%ld, X=%p, offx=%ld, incx=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, trans, diag, N, K, A, offa, lda, X, offx, incx, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    clblasTranspose trans_native;
    clblasDiag diag_native;
    size_t N_native = 0;
    size_t K_native = 0;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    trans_native = (clblasTranspose)trans;
    diag_native = (clblasDiag)diag;
    N_native = (size_t)N;
    K_native = (size_t)K;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasCtbsv(order_native, uplo_native, trans_native, diag_native, N_native, K_native, A_native, offa_native, lda_native, X_native, offx_native, incx_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    // K is primitive
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* solving triangular banded matrix problems with double-complex elements..
*
* Matrix-vector products:
*   - \f$ A X \leftarrow  X \f$
*   - \f$ A^T X \leftarrow  X \f$
*
* @param order				Row/column (in) order.
* @param uplo				The (in) triangle in matrix being referenced.
* @param trans				How (in) matrix  A is to be transposed.
* @param diag				Specify (in) whether matrix  A is unit triangular.
* @param N					Number (in) of rows/columns in banded matrix  A.
* @param K					Number (in) of sub-diagonals/super-diagonals in triangular banded matrix  A.
* @param A					Buffer (in) object storing matrix  A.
* @param offa				Offset (in) in number of elements for first element in matrix  A.
* @param lda				Leading (in) dimension of matrix  A. It cannot be less
*								than (  K + 1 )
* @param X				Buffer (out) object storing vector  X.
* @param offx				Offset (in) in number of elements for first element in vector  X.
* @param incx				Increment (in) for the elements of  X. Must not be zero.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return The same result as the clblasDtbsv() function.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasZtbsvNative(JNIEnv *env, jclass cls, jint order, jint uplo, jint trans, jint diag, jlong N, jlong K, jobject A, jlong offa, jlong lda, jobject X, jlong offx, jint incx, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    // K is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasZtbsv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    if (X == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasZtbsv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasZtbsv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasZtbsv(order=%d, uplo=%d, trans=%d, diag=%d, N=%ld, K=%ld, A=%p, offa=%ld, lda=%ld, X=%p, offx=%ld, incx=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, trans, diag, N, K, A, offa, lda, X, offx, incx, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    clblasTranspose trans_native;
    clblasDiag diag_native;
    size_t N_native = 0;
    size_t K_native = 0;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    trans_native = (clblasTranspose)trans;
    diag_native = (clblasDiag)diag;
    N_native = (size_t)N;
    K_native = (size_t)K;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    if (!initNative(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasZtbsv(order_native, uplo_native, trans_native, diag_native, N_native, K_native, A_native, offa_native, lda_native, X_native, offx_native, incx_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    // K is primitive
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Matrix-matrix product of general rectangular matrices with float.
*        elements. Extended version.
*
* Matrix-matrix products:
*   - \f$ C \leftarrow \alpha A B + eta C \f$
*   - \f$ C \leftarrow \alpha A^T B + eta C \f$
*   - \f$ C \leftarrow \alpha A B^T + eta C \f$
*   - \f$ C \leftarrow \alpha A^T B^T + eta C \f$
*
* @param order (in)     Row/column order.
* @param transA (in)    How matrix  A is to be transposed.
* @param transB (in)    How matrix  B is to be transposed.
* @param M (in)         Number of rows in matrix  A.
* @param N (in)         Number of columns in matrix  B.
* @param K (in)         Number of columns in matrix  A and rows in matrix  B.
* @param alpha (in)     The factor of matrix  A.
* @param A (in)         Buffer object storing matrix  A.
* @param offA (in)      Offset of the first element of the matrix  A in the
*                      buffer object. Counted in elements.
* @param lda (in)       Leading dimension of matrix  A. It cannot be less
*                      than  K when the  order parameter is set to
*                       clblasRowMajor,\n or less than  M when the
*                      parameter is set to  clblasColumnMajor.
* @param B (in)         Buffer object storing matrix  B.
* @param offB (in)      Offset of the first element of the matrix  B in the
*                      buffer object. Counted in elements.
* @param ldb (in)       Leading dimension of matrix  B. It cannot be less
*                      than  N when the  order parameter is set to
*                       clblasRowMajor,\n or less than  K
*                      when it is set to  clblasColumnMajor.
* @param beta (in)      The factor of matrix  C.
* @param C (out)        Buffer object storing matrix  C.
* @param  (in) offC     Offset of the first element of the matrix  C in the
*                      buffer object. Counted in elements.
* @param ldc (in)       Leading dimension of matrix  C. It cannot be less
*                      than  N when the  order parameter is set to
*                       clblasRowMajor,\n or less than  M when
*                      it is set to  clblasColumnMajorOrder.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasInvalidValue if either  offA,  offB or  offC exceeds
*        the size of the respective buffer object;
*   - the same error codes as clblasSgemm() otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasSgemmNative(JNIEnv *env, jclass cls, jint order, jint transA, jint transB, jlong M, jlong N, jlong K, jfloat alpha, jobject A, jlong offA, jlong lda, jobject B, jlong offB, jlong ldb, jfloat beta, jobject C, jlong offC, jlong ldc, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // transA is primitive
    // transB is primitive
    // M is primitive
    // N is primitive
    // K is primitive
    // alpha is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasSgemm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // lda is primitive
    if (B == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasSgemm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offB is primitive
    // ldb is primitive
    // beta is primitive
    if (C == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'C' is null for clblasSgemm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offC is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasSgemm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasSgemm(order=%d, transA=%d, transB=%d, M=%ld, N=%ld, K=%ld, alpha=%f, A=%p, offA=%ld, lda=%ld, B=%p, offB=%ld, ldb=%ld, beta=%f, C=%p, offC=%ld, ldc=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, transA, transB, M, N, K, alpha, A, offA, lda, B, offB, ldb, beta, C, offC, ldc, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasTranspose transA_native;
    clblasTranspose transB_native;
    size_t M_native = 0;
    size_t N_native = 0;
    size_t K_native = 0;
    cl_float alpha_native = 0.0f;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    size_t lda_native = 0;
    cl_mem B_native = nullptr;
    size_t offB_native = 0;
    size_t ldb_native = 0;
    cl_float beta_native = 0.0f;
    cl_mem C_native = nullptr;
    size_t offC_native = 0;
    size_t ldc_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    transA_native = (clblasTranspose)transA;
    transB_native = (clblasTranspose)transB;
    M_native = (size_t)M;
    N_native = (size_t)N;
    K_native = (size_t)K;
    alpha_native = (cl_float)alpha;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    lda_native = (size_t)lda;
    if (!initNative(env, B, B_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offB_native = (size_t)offB;
    ldb_native = (size_t)ldb;
    beta_native = (cl_float)beta;
    if (!initNative(env, C, C_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offC_native = (size_t)offC;
    ldc_native = (size_t)ldc;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasSgemm(order_native, transA_native, transB_native, M_native, N_native, K_native, alpha_native, A_native, offA_native, lda_native, B_native, offB_native, ldb_native, beta_native, C_native, offC_native, ldc_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // transA is primitive
    // transB is primitive
    // M is primitive
    // N is primitive
    // K is primitive
    // alpha is primitive
    // A is a read-only native pointer
    // offA is primitive
    // lda is primitive
    // B is a read-only native pointer
    // offB is primitive
    // ldb is primitive
    // beta is primitive
    // C is a read-only native pointer
    // offC is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* @example example_sgemm.c
* This is an example of how to use the @ref clblasSgemmEx function.
*/
/**
* Matrix-matrix product of general rectangular matrices with double.
*        elements. Extended version.
*
* Matrix-matrix products:
*   - \f$ C \leftarrow \alpha A B + eta C \f$
*   - \f$ C \leftarrow \alpha A^T B + eta C \f$
*   - \f$ C \leftarrow \alpha A B^T + eta C \f$
*   - \f$ C \leftarrow \alpha A^T B^T + eta C \f$
*
* @param order (in)     Row/column order.
* @param transA (in)    How matrix  A is to be transposed.
* @param transB (in)    How matrix  B is to be transposed.
* @param M (in)         Number of rows in matrix  A.
* @param N (in)         Number of columns in matrix  B.
* @param K (in)         Number of columns in matrix  A and rows in matrix  B.
* @param alpha (in)     The factor of matrix  A.
* @param A (in)         Buffer object storing matrix  A.
* @param offA (in)      Offset of the first element of the matrix  A in the
*                      buffer object. Counted in elements.
* @param lda (in)       Leading dimension of matrix  A. For detailed description,
*                      see clblasSgemm().
* @param B (in)         Buffer object storing matrix  B.
* @param offB (in)      Offset of the first element of the matrix  B in the
*                      buffer object. Counted in elements.
* @param ldb (in)       Leading dimension of matrix  B. For detailed description,
*                      see clblasSgemm().
* @param beta (in)      The factor of matrix  C.
* @param C (out)        Buffer object storing matrix  C.
* @param offC (in)      Offset of the first element of the matrix  C in the
*                      buffer object. Counted in elements.
* @param ldc (in)       Leading dimension of matrix  C. For detailed description,
*                      see clblasSgemm().
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasInvalidDevice if a target device does not support floating
*        point arithmetic with double precision;
*   -  clblasInvalidValue if either  offA,  offB or offC exceeds
*        the size of the respective buffer object;
*   - the same error codes as the clblasSgemm() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasDgemmNative(JNIEnv *env, jclass cls, jint order, jint transA, jint transB, jlong M, jlong N, jlong K, jdouble alpha, jobject A, jlong offA, jlong lda, jobject B, jlong offB, jlong ldb, jdouble beta, jobject C, jlong offC, jlong ldc, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // transA is primitive
    // transB is primitive
    // M is primitive
    // N is primitive
    // K is primitive
    // alpha is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasDgemm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // lda is primitive
    if (B == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasDgemm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offB is primitive
    // ldb is primitive
    // beta is primitive
    if (C == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'C' is null for clblasDgemm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offC is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasDgemm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasDgemm(order=%d, transA=%d, transB=%d, M=%ld, N=%ld, K=%ld, alpha=%lf, A=%p, offA=%ld, lda=%ld, B=%p, offB=%ld, ldb=%ld, beta=%lf, C=%p, offC=%ld, ldc=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, transA, transB, M, N, K, alpha, A, offA, lda, B, offB, ldb, beta, C, offC, ldc, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasTranspose transA_native;
    clblasTranspose transB_native;
    size_t M_native = 0;
    size_t N_native = 0;
    size_t K_native = 0;
    cl_double alpha_native = 0.0;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    size_t lda_native = 0;
    cl_mem B_native = nullptr;
    size_t offB_native = 0;
    size_t ldb_native = 0;
    cl_double beta_native = 0.0;
    cl_mem C_native = nullptr;
    size_t offC_native = 0;
    size_t ldc_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    transA_native = (clblasTranspose)transA;
    transB_native = (clblasTranspose)transB;
    M_native = (size_t)M;
    N_native = (size_t)N;
    K_native = (size_t)K;
    alpha_native = (cl_double)alpha;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    lda_native = (size_t)lda;
    if (!initNative(env, B, B_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offB_native = (size_t)offB;
    ldb_native = (size_t)ldb;
    beta_native = (cl_double)beta;
    if (!initNative(env, C, C_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offC_native = (size_t)offC;
    ldc_native = (size_t)ldc;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasDgemm(order_native, transA_native, transB_native, M_native, N_native, K_native, alpha_native, A_native, offA_native, lda_native, B_native, offB_native, ldb_native, beta_native, C_native, offC_native, ldc_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // transA is primitive
    // transB is primitive
    // M is primitive
    // N is primitive
    // K is primitive
    // alpha is primitive
    // A is a read-only native pointer
    // offA is primitive
    // lda is primitive
    // B is a read-only native pointer
    // offB is primitive
    // ldb is primitive
    // beta is primitive
    // C is a read-only native pointer
    // offC is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Matrix-matrix product of general rectangular matrices with float.
*        complex elements. Extended version.
*
* Matrix-matrix products:
*   - \f$ C \leftarrow \alpha A B + eta C \f$
*   - \f$ C \leftarrow \alpha A^T B + eta C \f$
*   - \f$ C \leftarrow \alpha A B^T + eta C \f$
*   - \f$ C \leftarrow \alpha A^T B^T + eta C \f$
*
* @param order (in)     Row/column order.
* @param transA (in)    How matrix  A is to be transposed.
* @param transB (in)    How matrix  B is to be transposed.
* @param M (in)         Number of rows in matrix  A.
* @param N (in)         Number of columns in matrix  B.
* @param K (in)         Number of columns in matrix  A and rows in matrix  B.
* @param alpha (in)     The factor of matrix  A.
* @param A (in)         Buffer object storing matrix  A.
* @param offA (in)      Offset of the first element of the matrix  A in the
*                      buffer object. Counted in elements.
* @param lda (in)       Leading dimension of matrix  A. For detailed description,
*                      see clblasSgemm().
* @param B (in)         Buffer object storing matrix  B.
* @param offB (in)      Offset of the first element of the matrix  B in the
*                      buffer object. Counted in elements.
* @param ldb (in)       Leading dimension of matrix  B. For detailed description,
*                      see clblasSgemm().
* @param beta (in)      The factor of matrix  C.
* @param C (out)        Buffer object storing matrix  C.
* @param offC (in)      Offset of the first element of the matrix  C in the
*                      buffer object. Counted in elements.
* @param ldc (in)       Leading dimension of matrix  C. For detailed description,
*                      see clblasSgemm().
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasInvalidValue if either  offA,  offB or offC exceeds
*        the size of the respective buffer object;
*   - the same error codes as the clblasSgemm() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasCgemmNative(JNIEnv *env, jclass cls, jint order, jint transA, jint transB, jlong M, jlong N, jlong K, jfloatArray alpha, jobject A, jlong offA, jlong lda, jobject B, jlong offB, jlong ldb, jfloatArray beta, jobject C, jlong offC, jlong ldc, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // transA is primitive
    // transB is primitive
    // M is primitive
    // N is primitive
    // K is primitive
    if (alpha == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'alpha' is null for clblasCgemm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasCgemm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // lda is primitive
    if (B == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasCgemm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offB is primitive
    // ldb is primitive
    if (beta == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'beta' is null for clblasCgemm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (C == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'C' is null for clblasCgemm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offC is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasCgemm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasCgemm(order=%d, transA=%d, transB=%d, M=%ld, N=%ld, K=%ld, alpha=%p, A=%p, offA=%ld, lda=%ld, B=%p, offB=%ld, ldb=%ld, beta=%p, C=%p, offC=%ld, ldc=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, transA, transB, M, N, K, alpha, A, offA, lda, B, offB, ldb, beta, C, offC, ldc, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasTranspose transA_native;
    clblasTranspose transB_native;
    size_t M_native = 0;
    size_t N_native = 0;
    size_t K_native = 0;
    FloatComplex alpha_native;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    size_t lda_native = 0;
    cl_mem B_native = nullptr;
    size_t offB_native = 0;
    size_t ldb_native = 0;
    FloatComplex beta_native;
    cl_mem C_native = nullptr;
    size_t offC_native = 0;
    size_t ldc_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    transA_native = (clblasTranspose)transA;
    transB_native = (clblasTranspose)transB;
    M_native = (size_t)M;
    N_native = (size_t)N;
    K_native = (size_t)K;
    if (!initNative(env, alpha, alpha_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    lda_native = (size_t)lda;
    if (!initNative(env, B, B_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offB_native = (size_t)offB;
    ldb_native = (size_t)ldb;
    if (!initNative(env, beta, beta_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, C, C_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offC_native = (size_t)offC;
    ldc_native = (size_t)ldc;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasCgemm(order_native, transA_native, transB_native, M_native, N_native, K_native, alpha_native, A_native, offA_native, lda_native, B_native, offB_native, ldb_native, beta_native, C_native, offC_native, ldc_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // transA is primitive
    // transB is primitive
    // M is primitive
    // N is primitive
    // K is primitive
    if (!releaseNative(env, alpha_native, alpha, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // A is a read-only native pointer
    // offA is primitive
    // lda is primitive
    // B is a read-only native pointer
    // offB is primitive
    // ldb is primitive
    if (!releaseNative(env, beta_native, beta, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // C is a read-only native pointer
    // offC is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Matrix-matrix product of general rectangular matrices with double.
*        complex elements. Exteneded version.
*
* Matrix-matrix products:
*   - \f$ C \leftarrow \alpha A B + eta C \f$
*   - \f$ C \leftarrow \alpha A^T B + eta C \f$
*   - \f$ C \leftarrow \alpha A B^T + eta C \f$
*   - \f$ C \leftarrow \alpha A^T B^T + eta C \f$
*
* @param order (in)     Row/column order.
* @param transA (in)    How matrix  A is to be transposed.
* @param transB (in)    How matrix  B is to be transposed.
* @param M (in)         Number of rows in matrix  A.
* @param N (in)         Number of columns in matrix  B.
* @param K (in)         Number of columns in matrix  A and rows in matrix  B.
* @param alpha (in)     The factor of matrix  A.
* @param A (in)         Buffer object storing matrix  A.
* @param offA (in)      Offset of the first element of the matrix  A in the
*                      buffer object. Counted in elements.
* @param lda (in)       Leading dimension of matrix  A. For detailed description,
*                      see clblasSgemm().
* @param B (in)         Buffer object storing matrix  B.
* @param offB (in)      Offset of the first element of the matrix  B in the
*                      buffer object. Counted in elements.
* @param ldb (in)       Leading dimension of matrix  B. For detailed description,
*                      see clblasSgemm().
* @param beta (in)      The factor of matrix  C.
* @param C (out)        Buffer object storing matrix  C.
* @param offC (in)      Offset of the first element of the matrix  C in the
*                      buffer object. Counted in elements.
* @param ldc (in)       Leading dimension of matrix  C. For detailed description,
*                      see clblasSgemm().
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasInvalidDevice if a target device does not support floating
*        point arithmetic with double precision;
*   -  clblasInvalidValue if either  offA,  offB or offC exceeds
*        the size of the respective buffer object;
*   - the same error codes as the clblasSgemm() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasZgemmNative(JNIEnv *env, jclass cls, jint order, jint transA, jint transB, jlong M, jlong N, jlong K, jdoubleArray alpha, jobject A, jlong offA, jlong lda, jobject B, jlong offB, jlong ldb, jdoubleArray beta, jobject C, jlong offC, jlong ldc, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // transA is primitive
    // transB is primitive
    // M is primitive
    // N is primitive
    // K is primitive
    if (alpha == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'alpha' is null for clblasZgemm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasZgemm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // lda is primitive
    if (B == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasZgemm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offB is primitive
    // ldb is primitive
    if (beta == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'beta' is null for clblasZgemm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (C == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'C' is null for clblasZgemm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offC is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasZgemm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasZgemm(order=%d, transA=%d, transB=%d, M=%ld, N=%ld, K=%ld, alpha=%p, A=%p, offA=%ld, lda=%ld, B=%p, offB=%ld, ldb=%ld, beta=%p, C=%p, offC=%ld, ldc=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, transA, transB, M, N, K, alpha, A, offA, lda, B, offB, ldb, beta, C, offC, ldc, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasTranspose transA_native;
    clblasTranspose transB_native;
    size_t M_native = 0;
    size_t N_native = 0;
    size_t K_native = 0;
    DoubleComplex alpha_native;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    size_t lda_native = 0;
    cl_mem B_native = nullptr;
    size_t offB_native = 0;
    size_t ldb_native = 0;
    DoubleComplex beta_native;
    cl_mem C_native = nullptr;
    size_t offC_native = 0;
    size_t ldc_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    transA_native = (clblasTranspose)transA;
    transB_native = (clblasTranspose)transB;
    M_native = (size_t)M;
    N_native = (size_t)N;
    K_native = (size_t)K;
    if (!initNative(env, alpha, alpha_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    lda_native = (size_t)lda;
    if (!initNative(env, B, B_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offB_native = (size_t)offB;
    ldb_native = (size_t)ldb;
    if (!initNative(env, beta, beta_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, C, C_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offC_native = (size_t)offC;
    ldc_native = (size_t)ldc;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasZgemm(order_native, transA_native, transB_native, M_native, N_native, K_native, alpha_native, A_native, offA_native, lda_native, B_native, offB_native, ldb_native, beta_native, C_native, offC_native, ldc_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // transA is primitive
    // transB is primitive
    // M is primitive
    // N is primitive
    // K is primitive
    if (!releaseNative(env, alpha_native, alpha, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // A is a read-only native pointer
    // offA is primitive
    // lda is primitive
    // B is a read-only native pointer
    // offB is primitive
    // ldb is primitive
    if (!releaseNative(env, beta_native, beta, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // C is a read-only native pointer
    // offC is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Multiplying a matrix by a triangular matrix with float elements..
*        Extended version.
*
* Matrix-triangular matrix products:
*   - \f$ B \leftarrow \alpha A B \f$
*   - \f$ B \leftarrow \alpha A^T B \f$
*   - \f$ B \leftarrow \alpha B A \f$
*   - \f$ B \leftarrow \alpha B A^T \f$
*
* where  T is an upper or lower triangular matrix.
*
* @param order (in)     Row/column order.
* @param side (in)      The side of triangular matrix.
* @param uplo (in)      The triangle in matrix being referenced.
* @param transA (in)    How matrix  A is to be transposed.
* @param diag (in)      Specify whether matrix is unit triangular.
* @param M (in)         Number of rows in matrix  B.
* @param N (in)         Number of columns in matrix  B.
* @param alpha (in)     The factor of matrix  A.
* @param A (in)         Buffer object storing matrix  A.
* @param offA (in)      Offset of the first element of the matrix  A in the
*                      buffer object. Counted in elements.
* @param lda (in)       Leading dimension of matrix  A. It cannot be less
*                      than  M when the  side parameter is set to
*                       clblasLeft,\n or less than  N when it is set
*                      to  clblasRight.
* @param B (out)        Buffer object storing matrix  B.
* @param offB (in)      Offset of the first element of the matrix  B in the
*                      buffer object. Counted in elements.
* @param ldb (in)       Leading dimension of matrix  B. It cannot be less
*                      than  N when the  order parameter is set to
*                       clblasRowMajor,\n or not less than  M
*                      when it is set to  clblasColumnMajor.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasInvalidValue if either  offA or  offB exceeds the size
*        of the respective buffer object;
*   - the same error codes as clblasStrmm() otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasStrmmNative(JNIEnv *env, jclass cls, jint order, jint side, jint uplo, jint transA, jint diag, jlong M, jlong N, jfloat alpha, jobject A, jlong offA, jlong lda, jobject B, jlong offB, jlong ldb, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // side is primitive
    // uplo is primitive
    // transA is primitive
    // diag is primitive
    // M is primitive
    // N is primitive
    // alpha is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasStrmm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // lda is primitive
    if (B == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasStrmm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offB is primitive
    // ldb is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasStrmm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasStrmm(order=%d, side=%d, uplo=%d, transA=%d, diag=%d, M=%ld, N=%ld, alpha=%f, A=%p, offA=%ld, lda=%ld, B=%p, offB=%ld, ldb=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, side, uplo, transA, diag, M, N, alpha, A, offA, lda, B, offB, ldb, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasSide side_native;
    clblasUplo uplo_native;
    clblasTranspose transA_native;
    clblasDiag diag_native;
    size_t M_native = 0;
    size_t N_native = 0;
    cl_float alpha_native = 0.0f;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    size_t lda_native = 0;
    cl_mem B_native = nullptr;
    size_t offB_native = 0;
    size_t ldb_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    side_native = (clblasSide)side;
    uplo_native = (clblasUplo)uplo;
    transA_native = (clblasTranspose)transA;
    diag_native = (clblasDiag)diag;
    M_native = (size_t)M;
    N_native = (size_t)N;
    alpha_native = (cl_float)alpha;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    lda_native = (size_t)lda;
    if (!initNative(env, B, B_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offB_native = (size_t)offB;
    ldb_native = (size_t)ldb;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasStrmm(order_native, side_native, uplo_native, transA_native, diag_native, M_native, N_native, alpha_native, A_native, offA_native, lda_native, B_native, offB_native, ldb_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // side is primitive
    // uplo is primitive
    // transA is primitive
    // diag is primitive
    // M is primitive
    // N is primitive
    // alpha is primitive
    // A is a read-only native pointer
    // offA is primitive
    // lda is primitive
    // B is a read-only native pointer
    // offB is primitive
    // ldb is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* @example example_strmm.c
* This is an example of how to use the @ref clblasStrmmEx function.
*/
/**
* Multiplying a matrix by a triangular matrix with double elements..
*        Extended version.
*
* Matrix-triangular matrix products:
*   - \f$ B \leftarrow \alpha A B \f$
*   - \f$ B \leftarrow \alpha A^T B \f$
*   - \f$ B \leftarrow \alpha B A \f$
*   - \f$ B \leftarrow \alpha B A^T \f$
*
* where  T is an upper or lower triangular matrix.
*
* @param order (in)     Row/column order.
* @param side (in)      The side of triangular matrix.
* @param uplo (in)      The triangle in matrix being referenced.
* @param transA (in)    How matrix  A is to be transposed.
* @param diag (in)      Specify whether matrix is unit triangular.
* @param M (in)         Number of rows in matrix  B.
* @param N (in)         Number of columns in matrix  B.
* @param alpha (in)     The factor of matrix  A.
* @param A (in)         Buffer object storing matrix  A.
* @param offA (in)      Offset of the first element of the matrix  A in the
*                      buffer object. Counted in elements.
* @param lda (in)       Leading dimension of matrix  A. For detailed
*                      description, see clblasStrmm().
* @param B (out)        Buffer object storing matrix  B.
* @param offB (in)      Offset of the first element of the matrix  B in the
*                      buffer object. Counted in elements.
* @param ldb (in)       Leading dimension of matrix  B. For detailed
*                      description, see clblasStrmm().
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasInvalidDevice if a target device does not support floating
*     point arithmetic with double precision;
*   -  clblasInvalidValue if either  offA or  offB exceeds the size
*        of the respective buffer object;
*   - the same error codes as the clblasStrmm() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasDtrmmNative(JNIEnv *env, jclass cls, jint order, jint side, jint uplo, jint transA, jint diag, jlong M, jlong N, jdouble alpha, jobject A, jlong offA, jlong lda, jobject B, jlong offB, jlong ldb, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // side is primitive
    // uplo is primitive
    // transA is primitive
    // diag is primitive
    // M is primitive
    // N is primitive
    // alpha is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasDtrmm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // lda is primitive
    if (B == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasDtrmm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offB is primitive
    // ldb is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasDtrmm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasDtrmm(order=%d, side=%d, uplo=%d, transA=%d, diag=%d, M=%ld, N=%ld, alpha=%lf, A=%p, offA=%ld, lda=%ld, B=%p, offB=%ld, ldb=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, side, uplo, transA, diag, M, N, alpha, A, offA, lda, B, offB, ldb, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasSide side_native;
    clblasUplo uplo_native;
    clblasTranspose transA_native;
    clblasDiag diag_native;
    size_t M_native = 0;
    size_t N_native = 0;
    cl_double alpha_native = 0.0;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    size_t lda_native = 0;
    cl_mem B_native = nullptr;
    size_t offB_native = 0;
    size_t ldb_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    side_native = (clblasSide)side;
    uplo_native = (clblasUplo)uplo;
    transA_native = (clblasTranspose)transA;
    diag_native = (clblasDiag)diag;
    M_native = (size_t)M;
    N_native = (size_t)N;
    alpha_native = (cl_double)alpha;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    lda_native = (size_t)lda;
    if (!initNative(env, B, B_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offB_native = (size_t)offB;
    ldb_native = (size_t)ldb;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasDtrmm(order_native, side_native, uplo_native, transA_native, diag_native, M_native, N_native, alpha_native, A_native, offA_native, lda_native, B_native, offB_native, ldb_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // side is primitive
    // uplo is primitive
    // transA is primitive
    // diag is primitive
    // M is primitive
    // N is primitive
    // alpha is primitive
    // A is a read-only native pointer
    // offA is primitive
    // lda is primitive
    // B is a read-only native pointer
    // offB is primitive
    // ldb is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Multiplying a matrix by a triangular matrix with float complex.
*        elements. Extended version.
*
* Matrix-triangular matrix products:
*   - \f$ B \leftarrow \alpha A B \f$
*   - \f$ B \leftarrow \alpha A^T B \f$
*   - \f$ B \leftarrow \alpha B A \f$
*   - \f$ B \leftarrow \alpha B A^T \f$
*
* where  T is an upper or lower triangular matrix.
* @param order (in)     Row/column order.
* @param side (in)      The side of triangular matrix.
* @param uplo (in)      The triangle in matrix being referenced.
* @param transA (in)    How matrix  A is to be transposed.
* @param diag (in)      Specify whether matrix is unit triangular.
* @param M (in)         Number of rows in matrix  B.
* @param N (in)         Number of columns in matrix  B.
* @param alpha (in)     The factor of matrix  A.
* @param offA (in)      Offset of the first element of the matrix  A in the
*                      buffer object. Counted in elements.
* @param A (in)         Buffer object storing matrix  A.
* @param lda (in)       Leading dimension of matrix  A. For detailed
*                      description, see clblasStrmm().
* @param B (out)        Buffer object storing matrix  B.
* @param offB (in)      Offset of the first element of the matrix  B in the
*                      buffer object. Counted in elements.
* @param ldb (in)       Leading dimension of matrix  B. For detailed
*                      description, see clblasStrmm().
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasInvalidValue if either  offA or  offB exceeds the size
*        of the respective buffer object;
*   - the same error codes as clblasStrmm() otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasCtrmmNative(JNIEnv *env, jclass cls, jint order, jint side, jint uplo, jint transA, jint diag, jlong M, jlong N, jfloatArray alpha, jobject A, jlong offA, jlong lda, jobject B, jlong offB, jlong ldb, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // side is primitive
    // uplo is primitive
    // transA is primitive
    // diag is primitive
    // M is primitive
    // N is primitive
    if (alpha == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'alpha' is null for clblasCtrmm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasCtrmm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // lda is primitive
    if (B == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasCtrmm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offB is primitive
    // ldb is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasCtrmm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasCtrmm(order=%d, side=%d, uplo=%d, transA=%d, diag=%d, M=%ld, N=%ld, alpha=%p, A=%p, offA=%ld, lda=%ld, B=%p, offB=%ld, ldb=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, side, uplo, transA, diag, M, N, alpha, A, offA, lda, B, offB, ldb, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasSide side_native;
    clblasUplo uplo_native;
    clblasTranspose transA_native;
    clblasDiag diag_native;
    size_t M_native = 0;
    size_t N_native = 0;
    FloatComplex alpha_native;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    size_t lda_native = 0;
    cl_mem B_native = nullptr;
    size_t offB_native = 0;
    size_t ldb_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    side_native = (clblasSide)side;
    uplo_native = (clblasUplo)uplo;
    transA_native = (clblasTranspose)transA;
    diag_native = (clblasDiag)diag;
    M_native = (size_t)M;
    N_native = (size_t)N;
    if (!initNative(env, alpha, alpha_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    lda_native = (size_t)lda;
    if (!initNative(env, B, B_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offB_native = (size_t)offB;
    ldb_native = (size_t)ldb;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasCtrmm(order_native, side_native, uplo_native, transA_native, diag_native, M_native, N_native, alpha_native, A_native, offA_native, lda_native, B_native, offB_native, ldb_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // side is primitive
    // uplo is primitive
    // transA is primitive
    // diag is primitive
    // M is primitive
    // N is primitive
    if (!releaseNative(env, alpha_native, alpha, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // A is a read-only native pointer
    // offA is primitive
    // lda is primitive
    // B is a read-only native pointer
    // offB is primitive
    // ldb is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Multiplying a matrix by a triangular matrix with double complex.
*        elements. Extended version.
*
* Matrix-triangular matrix products:
*   - \f$ B \leftarrow \alpha A B \f$
*   - \f$ B \leftarrow \alpha A^T B \f$
*   - \f$ B \leftarrow \alpha B A \f$
*   - \f$ B \leftarrow \alpha B A^T \f$
*
* where  T is an upper or lower triangular matrix.
*
* @param order (in)     Row/column order.
* @param side (in)      The side of triangular matrix.
* @param uplo (in)      The triangle in matrix being referenced.
* @param transA (in)    How matrix  A is to be transposed.
* @param diag (in)      Specify whether matrix is unit triangular.
* @param M (in)         Number of rows in matrix  B.
* @param N (in)         Number of columns in matrix  B.
* @param alpha (in)     The factor of matrix  A.
* @param A (in)         Buffer object storing matrix  A.
* @param offA (in)      Offset of the first element of the matrix  A in the
*                      buffer object. Counted in elements.
* @param lda (in)       Leading dimension of matrix  A. For detailed
*                      description, see clblasStrmm().
* @param B (out)        Buffer object storing matrix  B.
* @param offB (in)      Offset of the first element of the matrix  B in the
*                      buffer object. Counted in elements.
* @param ldb (in)       Leading dimension of matrix  B. For detailed
*                      description, see clblasStrmm().
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasInvalidDevice if a target device does not support floating
*     point arithmetic with double precision;
*   -  clblasInvalidValue if either  offA or  offB exceeds the size
*        of the respective buffer object;
*   - the same error codes as the clblasStrmm() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasZtrmmNative(JNIEnv *env, jclass cls, jint order, jint side, jint uplo, jint transA, jint diag, jlong M, jlong N, jdoubleArray alpha, jobject A, jlong offA, jlong lda, jobject B, jlong offB, jlong ldb, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // side is primitive
    // uplo is primitive
    // transA is primitive
    // diag is primitive
    // M is primitive
    // N is primitive
    if (alpha == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'alpha' is null for clblasZtrmm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasZtrmm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // lda is primitive
    if (B == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasZtrmm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offB is primitive
    // ldb is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasZtrmm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasZtrmm(order=%d, side=%d, uplo=%d, transA=%d, diag=%d, M=%ld, N=%ld, alpha=%p, A=%p, offA=%ld, lda=%ld, B=%p, offB=%ld, ldb=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, side, uplo, transA, diag, M, N, alpha, A, offA, lda, B, offB, ldb, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasSide side_native;
    clblasUplo uplo_native;
    clblasTranspose transA_native;
    clblasDiag diag_native;
    size_t M_native = 0;
    size_t N_native = 0;
    DoubleComplex alpha_native;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    size_t lda_native = 0;
    cl_mem B_native = nullptr;
    size_t offB_native = 0;
    size_t ldb_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    side_native = (clblasSide)side;
    uplo_native = (clblasUplo)uplo;
    transA_native = (clblasTranspose)transA;
    diag_native = (clblasDiag)diag;
    M_native = (size_t)M;
    N_native = (size_t)N;
    if (!initNative(env, alpha, alpha_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    lda_native = (size_t)lda;
    if (!initNative(env, B, B_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offB_native = (size_t)offB;
    ldb_native = (size_t)ldb;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasZtrmm(order_native, side_native, uplo_native, transA_native, diag_native, M_native, N_native, alpha_native, A_native, offA_native, lda_native, B_native, offB_native, ldb_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // side is primitive
    // uplo is primitive
    // transA is primitive
    // diag is primitive
    // M is primitive
    // N is primitive
    if (!releaseNative(env, alpha_native, alpha, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // A is a read-only native pointer
    // offA is primitive
    // lda is primitive
    // B is a read-only native pointer
    // offB is primitive
    // ldb is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Solving triangular systems of equations with multiple right-hand.
*        sides and float elements. Extended version.
*
* Solving triangular systems of equations:
*   - \f$ B \leftarrow \alpha A^{-1} B \f$
*   - \f$ B \leftarrow \alpha A^{-T} B \f$
*   - \f$ B \leftarrow \alpha B A^{-1} \f$
*   - \f$ B \leftarrow \alpha B A^{-T} \f$
*
* where  T is an upper or lower triangular matrix.
*
* @param order (in)     Row/column order.
* @param side (in)      The side of triangular matrix.
* @param uplo (in)      The triangle in matrix being referenced.
* @param transA (in)    How matrix  A is to be transposed.
* @param diag (in)      Specify whether matrix is unit triangular.
* @param M (in)         Number of rows in matrix  B.
* @param N (in)         Number of columns in matrix  B.
* @param alpha (in)     The factor of matrix  A.
* @param A (in)         Buffer object storing matrix  A.
* @param offA (in)      Offset of the first element of the matrix  A in the
*                      buffer object. Counted in elements.
* @param lda (in)       Leading dimension of matrix  A. It cannot be less
*                      than  M when the  side parameter is set to
*                       clblasLeft,\n or less than  N
*                      when it is set to  clblasRight.
* @param B (out)        Buffer object storing matrix  B.
* @param offB (in)      Offset of the first element of the matrix  B in the
*                      buffer object. Counted in elements.
* @param ldb (in)       Leading dimension of matrix  B. It cannot be less
*                      than  N when the  order parameter is set to
*                       clblasRowMajor,\n or less than  M
*                      when it is set to  clblasColumnMajor.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasInvalidValue if either  offA or  offB exceeds the size
*        of the respective buffer object;
*   - the same error codes as clblasStrsm() otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasStrsmNative(JNIEnv *env, jclass cls, jint order, jint side, jint uplo, jint transA, jint diag, jlong M, jlong N, jfloat alpha, jobject A, jlong offA, jlong lda, jobject B, jlong offB, jlong ldb, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // side is primitive
    // uplo is primitive
    // transA is primitive
    // diag is primitive
    // M is primitive
    // N is primitive
    // alpha is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasStrsm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // lda is primitive
    if (B == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasStrsm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offB is primitive
    // ldb is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasStrsm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasStrsm(order=%d, side=%d, uplo=%d, transA=%d, diag=%d, M=%ld, N=%ld, alpha=%f, A=%p, offA=%ld, lda=%ld, B=%p, offB=%ld, ldb=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, side, uplo, transA, diag, M, N, alpha, A, offA, lda, B, offB, ldb, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasSide side_native;
    clblasUplo uplo_native;
    clblasTranspose transA_native;
    clblasDiag diag_native;
    size_t M_native = 0;
    size_t N_native = 0;
    cl_float alpha_native = 0.0f;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    size_t lda_native = 0;
    cl_mem B_native = nullptr;
    size_t offB_native = 0;
    size_t ldb_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    side_native = (clblasSide)side;
    uplo_native = (clblasUplo)uplo;
    transA_native = (clblasTranspose)transA;
    diag_native = (clblasDiag)diag;
    M_native = (size_t)M;
    N_native = (size_t)N;
    alpha_native = (cl_float)alpha;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    lda_native = (size_t)lda;
    if (!initNative(env, B, B_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offB_native = (size_t)offB;
    ldb_native = (size_t)ldb;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasStrsm(order_native, side_native, uplo_native, transA_native, diag_native, M_native, N_native, alpha_native, A_native, offA_native, lda_native, B_native, offB_native, ldb_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // side is primitive
    // uplo is primitive
    // transA is primitive
    // diag is primitive
    // M is primitive
    // N is primitive
    // alpha is primitive
    // A is a read-only native pointer
    // offA is primitive
    // lda is primitive
    // B is a read-only native pointer
    // offB is primitive
    // ldb is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* @example example_strsm.c
* This is an example of how to use the @ref clblasStrsmEx function.
*/
/**
* Solving triangular systems of equations with multiple right-hand.
*        sides and double elements. Extended version.
*
* Solving triangular systems of equations:
*   - \f$ B \leftarrow \alpha A^{-1} B \f$
*   - \f$ B \leftarrow \alpha A^{-T} B \f$
*   - \f$ B \leftarrow \alpha B A^{-1} \f$
*   - \f$ B \leftarrow \alpha B A^{-T} \f$
*
* where  T is an upper or lower triangular matrix.
*
* @param order (in)     Row/column order.
* @param side (in)      The side of triangular matrix.
* @param uplo (in)      The triangle in matrix being referenced.
* @param transA (in)    How matrix  A is to be transposed.
* @param diag (in)      Specify whether matrix is unit triangular.
* @param M (in)         Number of rows in matrix  B.
* @param N (in)         Number of columns in matrix  B.
* @param alpha (in)     The factor of matrix  A.
* @param A (in)         Buffer object storing matrix  A.
* @param offA (in)      Offset of the first element of the matrix  A in the
*                      buffer object. Counted in elements.
* @param lda (in)       Leading dimension of matrix  A. For detailed
*                      description, see clblasStrsm().
* @param B (out)        Buffer object storing matrix  B.
* @param offB (in)      Offset of the first element of the matrix  A in the
*                      buffer object. Counted in elements.
* @param ldb (in)       Leading dimension of matrix  B. For detailed
*                      description, see clblasStrsm().
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasInvalidDevice if a target device does not support floating
*        point arithmetic with double precision;
*   -  clblasInvalidValue if either  offA or  offB exceeds the size
*        of the respective buffer object;
*   - the same error codes as the clblasStrsm() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasDtrsmNative(JNIEnv *env, jclass cls, jint order, jint side, jint uplo, jint transA, jint diag, jlong M, jlong N, jdouble alpha, jobject A, jlong offA, jlong lda, jobject B, jlong offB, jlong ldb, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // side is primitive
    // uplo is primitive
    // transA is primitive
    // diag is primitive
    // M is primitive
    // N is primitive
    // alpha is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasDtrsm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // lda is primitive
    if (B == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasDtrsm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offB is primitive
    // ldb is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasDtrsm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasDtrsm(order=%d, side=%d, uplo=%d, transA=%d, diag=%d, M=%ld, N=%ld, alpha=%lf, A=%p, offA=%ld, lda=%ld, B=%p, offB=%ld, ldb=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, side, uplo, transA, diag, M, N, alpha, A, offA, lda, B, offB, ldb, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasSide side_native;
    clblasUplo uplo_native;
    clblasTranspose transA_native;
    clblasDiag diag_native;
    size_t M_native = 0;
    size_t N_native = 0;
    cl_double alpha_native = 0.0;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    size_t lda_native = 0;
    cl_mem B_native = nullptr;
    size_t offB_native = 0;
    size_t ldb_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    side_native = (clblasSide)side;
    uplo_native = (clblasUplo)uplo;
    transA_native = (clblasTranspose)transA;
    diag_native = (clblasDiag)diag;
    M_native = (size_t)M;
    N_native = (size_t)N;
    alpha_native = (cl_double)alpha;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    lda_native = (size_t)lda;
    if (!initNative(env, B, B_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offB_native = (size_t)offB;
    ldb_native = (size_t)ldb;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasDtrsm(order_native, side_native, uplo_native, transA_native, diag_native, M_native, N_native, alpha_native, A_native, offA_native, lda_native, B_native, offB_native, ldb_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // side is primitive
    // uplo is primitive
    // transA is primitive
    // diag is primitive
    // M is primitive
    // N is primitive
    // alpha is primitive
    // A is a read-only native pointer
    // offA is primitive
    // lda is primitive
    // B is a read-only native pointer
    // offB is primitive
    // ldb is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Solving triangular systems of equations with multiple right-hand.
*        sides and float complex elements. Extended version.
*
* Solving triangular systems of equations:
*   - \f$ B \leftarrow \alpha A^{-1} B \f$
*   - \f$ B \leftarrow \alpha A^{-T} B \f$
*   - \f$ B \leftarrow \alpha B A^{-1} \f$
*   - \f$ B \leftarrow \alpha B A^{-T} \f$
*
* where  T is an upper or lower triangular matrix.
*
* @param order (in)     Row/column order.
* @param side (in)      The side of triangular matrix.
* @param uplo (in)      The triangle in matrix being referenced.
* @param transA (in)    How matrix  A is to be transposed.
* @param diag (in)      Specify whether matrix is unit triangular.
* @param M (in)         Number of rows in matrix  B.
* @param N (in)         Number of columns in matrix  B.
* @param alpha (in)     The factor of matrix  A.
* @param A (in)         Buffer object storing matrix  A.
* @param offA (in)      Offset of the first element of the matrix  A in the
*                      buffer object. Counted in elements.
* @param lda (in)       Leading dimension of matrix  A. For detailed
*                      description, see clblasStrsm().
* @param B (out)        Buffer object storing matrix  B.
* @param offB (in)      Offset of the first element of the matrix  B in the
*                      buffer object. Counted in elements.
* @param ldb (in)       Leading dimension of matrix  B. For detailed
*                      description, see clblasStrsm().
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasInvalidValue if either  offA or  offB exceeds the size
*        of the respective buffer object;
*   - the same error codes as clblasStrsm() otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasCtrsmNative(JNIEnv *env, jclass cls, jint order, jint side, jint uplo, jint transA, jint diag, jlong M, jlong N, jfloatArray alpha, jobject A, jlong offA, jlong lda, jobject B, jlong offB, jlong ldb, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // side is primitive
    // uplo is primitive
    // transA is primitive
    // diag is primitive
    // M is primitive
    // N is primitive
    if (alpha == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'alpha' is null for clblasCtrsm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasCtrsm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // lda is primitive
    if (B == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasCtrsm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offB is primitive
    // ldb is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasCtrsm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasCtrsm(order=%d, side=%d, uplo=%d, transA=%d, diag=%d, M=%ld, N=%ld, alpha=%p, A=%p, offA=%ld, lda=%ld, B=%p, offB=%ld, ldb=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, side, uplo, transA, diag, M, N, alpha, A, offA, lda, B, offB, ldb, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasSide side_native;
    clblasUplo uplo_native;
    clblasTranspose transA_native;
    clblasDiag diag_native;
    size_t M_native = 0;
    size_t N_native = 0;
    FloatComplex alpha_native;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    size_t lda_native = 0;
    cl_mem B_native = nullptr;
    size_t offB_native = 0;
    size_t ldb_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    side_native = (clblasSide)side;
    uplo_native = (clblasUplo)uplo;
    transA_native = (clblasTranspose)transA;
    diag_native = (clblasDiag)diag;
    M_native = (size_t)M;
    N_native = (size_t)N;
    if (!initNative(env, alpha, alpha_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    lda_native = (size_t)lda;
    if (!initNative(env, B, B_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offB_native = (size_t)offB;
    ldb_native = (size_t)ldb;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasCtrsm(order_native, side_native, uplo_native, transA_native, diag_native, M_native, N_native, alpha_native, A_native, offA_native, lda_native, B_native, offB_native, ldb_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // side is primitive
    // uplo is primitive
    // transA is primitive
    // diag is primitive
    // M is primitive
    // N is primitive
    if (!releaseNative(env, alpha_native, alpha, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // A is a read-only native pointer
    // offA is primitive
    // lda is primitive
    // B is a read-only native pointer
    // offB is primitive
    // ldb is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Solving triangular systems of equations with multiple right-hand.
*        sides and double complex elements. Extended version.
*
* Solving triangular systems of equations:
*   - \f$ B \leftarrow \alpha A^{-1} B \f$
*   - \f$ B \leftarrow \alpha A^{-T} B \f$
*   - \f$ B \leftarrow \alpha B A^{-1} \f$
*   - \f$ B \leftarrow \alpha B A^{-T} \f$
*
* where  T is an upper or lower triangular matrix.
*
* @param order (in)     Row/column order.
* @param side (in)      The side of triangular matrix.
* @param uplo (in)      The triangle in matrix being referenced.
* @param transA (in)    How matrix  A is to be transposed.
* @param diag (in)      Specify whether matrix is unit triangular.
* @param M (in)         Number of rows in matrix  B.
* @param N (in)         Number of columns in matrix  B.
* @param alpha (in)     The factor of matrix  A.
* @param A (in)         Buffer object storing matrix  A.
* @param offA (in)      Offset of the first element of the matrix  A in the
*                      buffer object. Counted in elements.
* @param lda (in)       Leading dimension of matrix  A. For detailed
*                      description, see clblasStrsm().
* @param B (out)        Buffer object storing matrix  B.
* @param offB (in)      Offset of the first element of the matrix  B in the
*                      buffer object. Counted in elements.
* @param ldb (in)       Leading dimension of matrix  B. For detailed
*                      description, see clblasStrsm().
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasInvalidDevice if a target device does not support floating
*        point arithmetic with double precision;
*   -  clblasInvalidValue if either  offA or  offB exceeds the size
*        of the respective buffer object;
*   - the same error codes as the clblasStrsm() function otherwise
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasZtrsmNative(JNIEnv *env, jclass cls, jint order, jint side, jint uplo, jint transA, jint diag, jlong M, jlong N, jdoubleArray alpha, jobject A, jlong offA, jlong lda, jobject B, jlong offB, jlong ldb, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // side is primitive
    // uplo is primitive
    // transA is primitive
    // diag is primitive
    // M is primitive
    // N is primitive
    if (alpha == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'alpha' is null for clblasZtrsm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasZtrsm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // lda is primitive
    if (B == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasZtrsm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offB is primitive
    // ldb is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasZtrsm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasZtrsm(order=%d, side=%d, uplo=%d, transA=%d, diag=%d, M=%ld, N=%ld, alpha=%p, A=%p, offA=%ld, lda=%ld, B=%p, offB=%ld, ldb=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, side, uplo, transA, diag, M, N, alpha, A, offA, lda, B, offB, ldb, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasSide side_native;
    clblasUplo uplo_native;
    clblasTranspose transA_native;
    clblasDiag diag_native;
    size_t M_native = 0;
    size_t N_native = 0;
    DoubleComplex alpha_native;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    size_t lda_native = 0;
    cl_mem B_native = nullptr;
    size_t offB_native = 0;
    size_t ldb_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    side_native = (clblasSide)side;
    uplo_native = (clblasUplo)uplo;
    transA_native = (clblasTranspose)transA;
    diag_native = (clblasDiag)diag;
    M_native = (size_t)M;
    N_native = (size_t)N;
    if (!initNative(env, alpha, alpha_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    lda_native = (size_t)lda;
    if (!initNative(env, B, B_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offB_native = (size_t)offB;
    ldb_native = (size_t)ldb;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasZtrsm(order_native, side_native, uplo_native, transA_native, diag_native, M_native, N_native, alpha_native, A_native, offA_native, lda_native, B_native, offB_native, ldb_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // side is primitive
    // uplo is primitive
    // transA is primitive
    // diag is primitive
    // M is primitive
    // N is primitive
    if (!releaseNative(env, alpha_native, alpha, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // A is a read-only native pointer
    // offA is primitive
    // lda is primitive
    // B is a read-only native pointer
    // offB is primitive
    // ldb is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Rank-k update of a symmetric matrix with float elements..
*        Extended version.
*
* Rank-k updates:
*   - \f$ C \leftarrow \alpha A A^T + eta C \f$
*   - \f$ C \leftarrow \alpha A^T A + eta C \f$
*
* where  C is a symmetric matrix.
*
* @param order (in)      Row/column order.
* @param uplo (in)       The triangle in matrix  C being referenced.
* @param transA (in)     How matrix  A is to be transposed.
* @param N (in)          Number of rows and columns in matrix  C.
* @param K (in)          Number of columns of the matrix  A if it is not
*                       transposed, and number of rows otherwise.
* @param alpha (in)      The factor of matrix  A.
* @param A (in)          Buffer object storing the matrix  A.
* @param offA (in)       Offset of the first element of the matrix  A in the
*                       buffer object. Counted in elements.
* @param lda (in)        Leading dimension of matrix  A. It cannot be
*                       less than  K if  A is
*                       in the row-major format, and less than  N
*                       otherwise.
* @param beta (in)       The factor of the matrix  C.
* @param C (out)         Buffer object storing matrix  C.
* @param offC (in)       Offset of the first element of the matrix  C in the
*                       buffer object. Counted in elements.
* @param ldc (in)        Leading dimension of matric  C. It cannot be less
*                       than  N.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasInvalidValue if either  offA or  offC exceeds the size
*        of the respective buffer object;
*   - the same error codes as the clblasSsyrk() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasSsyrkNative(JNIEnv *env, jclass cls, jint order, jint uplo, jint transA, jlong N, jlong K, jfloat alpha, jobject A, jlong offA, jlong lda, jfloat beta, jobject C, jlong offC, jlong ldc, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // transA is primitive
    // N is primitive
    // K is primitive
    // alpha is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasSsyrk");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // lda is primitive
    // beta is primitive
    if (C == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'C' is null for clblasSsyrk");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offC is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasSsyrk");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasSsyrk(order=%d, uplo=%d, transA=%d, N=%ld, K=%ld, alpha=%f, A=%p, offA=%ld, lda=%ld, beta=%f, C=%p, offC=%ld, ldc=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, transA, N, K, alpha, A, offA, lda, beta, C, offC, ldc, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    clblasTranspose transA_native;
    size_t N_native = 0;
    size_t K_native = 0;
    cl_float alpha_native = 0.0f;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    size_t lda_native = 0;
    cl_float beta_native = 0.0f;
    cl_mem C_native = nullptr;
    size_t offC_native = 0;
    size_t ldc_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    transA_native = (clblasTranspose)transA;
    N_native = (size_t)N;
    K_native = (size_t)K;
    alpha_native = (cl_float)alpha;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    lda_native = (size_t)lda;
    beta_native = (cl_float)beta;
    if (!initNative(env, C, C_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offC_native = (size_t)offC;
    ldc_native = (size_t)ldc;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasSsyrk(order_native, uplo_native, transA_native, N_native, K_native, alpha_native, A_native, offA_native, lda_native, beta_native, C_native, offC_native, ldc_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // transA is primitive
    // N is primitive
    // K is primitive
    // alpha is primitive
    // A is a read-only native pointer
    // offA is primitive
    // lda is primitive
    // beta is primitive
    // C is a read-only native pointer
    // offC is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* @example example_ssyrk.c
* This is an example of how to use the @ref clblasSsyrkEx function.
*/
/**
* Rank-k update of a symmetric matrix with double elements..
*        Extended version.
*
* Rank-k updates:
*   - \f$ C \leftarrow \alpha A A^T + eta C \f$
*   - \f$ C \leftarrow \alpha A^T A + eta C \f$
*
* where  C is a symmetric matrix.
*
* @param order (in)      Row/column order.
* @param uplo (in)       The triangle in matrix  C being referenced.
* @param transA (in)     How matrix  A is to be transposed.
* @param N (in)          Number of rows and columns in matrix  C.
* @param K (in)          Number of columns of the matrix  A if it is not
*                       transposed, and number of rows otherwise.
* @param alpha (in)      The factor of matrix  A.
* @param A (in)          Buffer object storing the matrix  A.
* @param offA (in)       Offset of the first element of the matrix  A in the
*                       buffer object. Counted in elements.
* @param lda (in)        Leading dimension of matrix  A. For detailed
*                       description, see clblasSsyrk().
* @param beta (in)       The factor of the matrix  C.
* @param C (out)         Buffer object storing matrix  C.
* @param offC (in)       Offset of the first element of the matrix  C in the
*                       buffer object. Counted in elements.
* @param ldc (in)        Leading dimension of matrix  C. It cannot be less
*                       than  N.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasInvalidDevice if a target device does not support floating
*        point arithmetic with double precision;
*   -  clblasInvalidValue if either  offA or  offC exceeds the size
*        of the respective buffer object;
*   - the same error codes as the clblasSsyrk() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasDsyrkNative(JNIEnv *env, jclass cls, jint order, jint uplo, jint transA, jlong N, jlong K, jdouble alpha, jobject A, jlong offA, jlong lda, jdouble beta, jobject C, jlong offC, jlong ldc, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // transA is primitive
    // N is primitive
    // K is primitive
    // alpha is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasDsyrk");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // lda is primitive
    // beta is primitive
    if (C == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'C' is null for clblasDsyrk");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offC is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasDsyrk");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasDsyrk(order=%d, uplo=%d, transA=%d, N=%ld, K=%ld, alpha=%lf, A=%p, offA=%ld, lda=%ld, beta=%lf, C=%p, offC=%ld, ldc=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, transA, N, K, alpha, A, offA, lda, beta, C, offC, ldc, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    clblasTranspose transA_native;
    size_t N_native = 0;
    size_t K_native = 0;
    cl_double alpha_native = 0.0;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    size_t lda_native = 0;
    cl_double beta_native = 0.0;
    cl_mem C_native = nullptr;
    size_t offC_native = 0;
    size_t ldc_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    transA_native = (clblasTranspose)transA;
    N_native = (size_t)N;
    K_native = (size_t)K;
    alpha_native = (cl_double)alpha;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    lda_native = (size_t)lda;
    beta_native = (cl_double)beta;
    if (!initNative(env, C, C_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offC_native = (size_t)offC;
    ldc_native = (size_t)ldc;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasDsyrk(order_native, uplo_native, transA_native, N_native, K_native, alpha_native, A_native, offA_native, lda_native, beta_native, C_native, offC_native, ldc_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // transA is primitive
    // N is primitive
    // K is primitive
    // alpha is primitive
    // A is a read-only native pointer
    // offA is primitive
    // lda is primitive
    // beta is primitive
    // C is a read-only native pointer
    // offC is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Rank-k update of a symmetric matrix with complex float elements..
*        Extended version.
*
* Rank-k updates:
*   - \f$ C \leftarrow \alpha A A^T + eta C \f$
*   - \f$ C \leftarrow \alpha A^T A + eta C \f$
*
* where  C is a symmetric matrix.
*
* @param order (in)      Row/column order.
* @param uplo (in)       The triangle in matrix  C being referenced.
* @param transA (in)     How matrix  A is to be transposed.
* @param N (in)          Number of rows and columns in matrix  C.
* @param K (in)          Number of columns of the matrix  A if it is not
*                       transposed, and number of rows otherwise.
* @param alpha (in)      The factor of matrix  A.
* @param A (in)          Buffer object storing the matrix  A.
* @param offA (in)       Offset of the first element of the matrix  A in the
*                       buffer object. Counted in elements.
* @param lda (in)        Leading dimension of matrix  A. For detailed
*                       description, see clblasSsyrk().
* @param beta (in)       The factor of the matrix  C.
* @param C (out)         Buffer object storing matrix  C.
* @param offC (in)       Offset of the first element of the matrix  C in the
*                       buffer object. Counted in elements.
* @param ldc (in)        Leading dimension of matrix  C. It cannot be less
*                       than  N.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasInvalidValue if either  offA or  offC exceeds the size
*        of the respective buffer object;
*   -  clblasInvalidValue if  transA is set to \ref clblasConjTrans.
*   - the same error codes as the clblasSsyrk() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasCsyrkNative(JNIEnv *env, jclass cls, jint order, jint uplo, jint transA, jlong N, jlong K, jfloatArray alpha, jobject A, jlong offA, jlong lda, jfloatArray beta, jobject C, jlong offC, jlong ldc, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // transA is primitive
    // N is primitive
    // K is primitive
    if (alpha == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'alpha' is null for clblasCsyrk");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasCsyrk");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // lda is primitive
    if (beta == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'beta' is null for clblasCsyrk");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (C == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'C' is null for clblasCsyrk");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offC is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasCsyrk");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasCsyrk(order=%d, uplo=%d, transA=%d, N=%ld, K=%ld, alpha=%p, A=%p, offA=%ld, lda=%ld, beta=%p, C=%p, offC=%ld, ldc=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, transA, N, K, alpha, A, offA, lda, beta, C, offC, ldc, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    clblasTranspose transA_native;
    size_t N_native = 0;
    size_t K_native = 0;
    FloatComplex alpha_native;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    size_t lda_native = 0;
    FloatComplex beta_native;
    cl_mem C_native = nullptr;
    size_t offC_native = 0;
    size_t ldc_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    transA_native = (clblasTranspose)transA;
    N_native = (size_t)N;
    K_native = (size_t)K;
    if (!initNative(env, alpha, alpha_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    lda_native = (size_t)lda;
    if (!initNative(env, beta, beta_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, C, C_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offC_native = (size_t)offC;
    ldc_native = (size_t)ldc;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasCsyrk(order_native, uplo_native, transA_native, N_native, K_native, alpha_native, A_native, offA_native, lda_native, beta_native, C_native, offC_native, ldc_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // transA is primitive
    // N is primitive
    // K is primitive
    if (!releaseNative(env, alpha_native, alpha, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // A is a read-only native pointer
    // offA is primitive
    // lda is primitive
    if (!releaseNative(env, beta_native, beta, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // C is a read-only native pointer
    // offC is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Rank-k update of a symmetric matrix with complex double elements..
*        Extended version.
*
* Rank-k updates:
*   - \f$ C \leftarrow \alpha A A^T + eta C \f$
*   - \f$ C \leftarrow \alpha A^T A + eta C \f$
*
* where  C is a symmetric matrix.
*
* @param order (in)      Row/column order.
* @param uplo (in)       The triangle in matrix  C being referenced.
* @param transA (in)     How matrix  A is to be transposed.
* @param N (in)          Number of rows and columns in matrix  C.
* @param K (in)          Number of columns of the matrix  A if it is not
*                       transposed, and number of rows otherwise.
* @param alpha (in)      The factor of matrix  A.
* @param A (in)          Buffer object storing the matrix  A.
* @param offA (in)       Offset of the first element of the matrix  A in the
*                       buffer object. Counted in elements.
* @param lda (in)        Leading dimension of matrix  A. For detailed
*                       description, see clblasSsyrk().
* @param beta (in)       The factor of the matrix  C.
* @param C (out)         Buffer object storing matrix  C.
* @param offC (in)       Offset of the first element of the matrix  C in the
*                       buffer object. Counted in elements.
* @param ldc (in)        Leading dimension of matrix  C. It cannot be less
*                       than  N.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasInvalidDevice if a target device does not support floating
*         point arithmetic with double precision;
*   -  clblasInvalidValue if either  offA or  offC exceeds the size
*        of the respective buffer object;
*   -  clblasInvalidValue if  transA is set to \ref clblasConjTrans.
*   - the same error codes as the clblasSsyrk() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasZsyrkNative(JNIEnv *env, jclass cls, jint order, jint uplo, jint transA, jlong N, jlong K, jdoubleArray alpha, jobject A, jlong offA, jlong lda, jdoubleArray beta, jobject C, jlong offC, jlong ldc, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // transA is primitive
    // N is primitive
    // K is primitive
    if (alpha == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'alpha' is null for clblasZsyrk");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasZsyrk");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // lda is primitive
    if (beta == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'beta' is null for clblasZsyrk");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (C == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'C' is null for clblasZsyrk");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offC is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasZsyrk");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasZsyrk(order=%d, uplo=%d, transA=%d, N=%ld, K=%ld, alpha=%p, A=%p, offA=%ld, lda=%ld, beta=%p, C=%p, offC=%ld, ldc=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, transA, N, K, alpha, A, offA, lda, beta, C, offC, ldc, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    clblasTranspose transA_native;
    size_t N_native = 0;
    size_t K_native = 0;
    DoubleComplex alpha_native;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    size_t lda_native = 0;
    DoubleComplex beta_native;
    cl_mem C_native = nullptr;
    size_t offC_native = 0;
    size_t ldc_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    transA_native = (clblasTranspose)transA;
    N_native = (size_t)N;
    K_native = (size_t)K;
    if (!initNative(env, alpha, alpha_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    lda_native = (size_t)lda;
    if (!initNative(env, beta, beta_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, C, C_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offC_native = (size_t)offC;
    ldc_native = (size_t)ldc;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasZsyrk(order_native, uplo_native, transA_native, N_native, K_native, alpha_native, A_native, offA_native, lda_native, beta_native, C_native, offC_native, ldc_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // transA is primitive
    // N is primitive
    // K is primitive
    if (!releaseNative(env, alpha_native, alpha, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // A is a read-only native pointer
    // offA is primitive
    // lda is primitive
    if (!releaseNative(env, beta_native, beta, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // C is a read-only native pointer
    // offC is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Rank-2k update of a symmetric matrix with float elements..
*        Extended version.
*
* Rank-k updates:
*   - \f$ C \leftarrow \alpha A B^T + \alpha B A^T + eta C \f$
*   - \f$ C \leftarrow \alpha A^T B + \alpha B^T A eta C \f$
*
* where  C is a symmetric matrix.
*
* @param order (in)      Row/column order.
* @param uplo (in)       The triangle in matrix  C being referenced.
* @param transAB (in)    How matrices  A and  B is to be transposed.
* @param N (in)          Number of rows and columns in matrix  C.
* @param K (in)          Number of columns of the matrices  A and  B if they
*                       are not transposed, and number of rows otherwise.
* @param alpha (in)      The factor of matrices  A and  B.
* @param A (in)          Buffer object storing matrix  A.
* @param offA (in)       Offset of the first element of the matrix  A in the
*                       buffer object. Counted in elements.
* @param lda (in)        Leading dimension of matrix  A. It cannot be less
*                       than  K if  A is
*                       in the row-major format, and less than  N
*                       otherwise.
* @param B (in)          Buffer object storing matrix  B.
* @param offB (in)       Offset of the first element of the matrix  B in the
*                       buffer object. Counted in elements.
* @param ldb (in)        Leading dimension of matrix  B. It cannot be less
*                       less than  K if  B matches to the op( B) matrix
*                       in the row-major format, and less than  N
*                       otherwise.
* @param beta (in)       The factor of matrix  C.
* @param C (out)         Buffer object storing matrix  C.
* @param offC (in)       Offset of the first element of the matrix  C in the
*                       buffer object. Counted in elements.
* @param ldc (in)        Leading dimension of matrix  C. It cannot be less
*                       than  N.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasInvalidValue if either  offA,  offB or  offC exceeds
*        the size of the respective buffer object;
*   - the same error codes as the clblasSsyr2k() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasSsyr2kNative(JNIEnv *env, jclass cls, jint order, jint uplo, jint transAB, jlong N, jlong K, jfloat alpha, jobject A, jlong offA, jlong lda, jobject B, jlong offB, jlong ldb, jfloat beta, jobject C, jlong offC, jlong ldc, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // transAB is primitive
    // N is primitive
    // K is primitive
    // alpha is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasSsyr2k");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // lda is primitive
    if (B == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasSsyr2k");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offB is primitive
    // ldb is primitive
    // beta is primitive
    if (C == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'C' is null for clblasSsyr2k");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offC is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasSsyr2k");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasSsyr2k(order=%d, uplo=%d, transAB=%d, N=%ld, K=%ld, alpha=%f, A=%p, offA=%ld, lda=%ld, B=%p, offB=%ld, ldb=%ld, beta=%f, C=%p, offC=%ld, ldc=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, transAB, N, K, alpha, A, offA, lda, B, offB, ldb, beta, C, offC, ldc, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    clblasTranspose transAB_native;
    size_t N_native = 0;
    size_t K_native = 0;
    cl_float alpha_native = 0.0f;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    size_t lda_native = 0;
    cl_mem B_native = nullptr;
    size_t offB_native = 0;
    size_t ldb_native = 0;
    cl_float beta_native = 0.0f;
    cl_mem C_native = nullptr;
    size_t offC_native = 0;
    size_t ldc_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    transAB_native = (clblasTranspose)transAB;
    N_native = (size_t)N;
    K_native = (size_t)K;
    alpha_native = (cl_float)alpha;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    lda_native = (size_t)lda;
    if (!initNative(env, B, B_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offB_native = (size_t)offB;
    ldb_native = (size_t)ldb;
    beta_native = (cl_float)beta;
    if (!initNative(env, C, C_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offC_native = (size_t)offC;
    ldc_native = (size_t)ldc;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasSsyr2k(order_native, uplo_native, transAB_native, N_native, K_native, alpha_native, A_native, offA_native, lda_native, B_native, offB_native, ldb_native, beta_native, C_native, offC_native, ldc_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // transAB is primitive
    // N is primitive
    // K is primitive
    // alpha is primitive
    // A is a read-only native pointer
    // offA is primitive
    // lda is primitive
    // B is a read-only native pointer
    // offB is primitive
    // ldb is primitive
    // beta is primitive
    // C is a read-only native pointer
    // offC is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* @example example_ssyr2k.c
* This is an example of how to use the @ref clblasSsyr2kEx function.
*/
/**
* Rank-2k update of a symmetric matrix with double elements..
*        Extended version.
*
* Rank-k updates:
*   - \f$ C \leftarrow \alpha A B^T + \alpha B A^T + eta C \f$
*   - \f$ C \leftarrow \alpha A^T B + \alpha B^T A eta C \f$
*
* where  C is a symmetric matrix.
*
* @param order (in)      Row/column order.
* @param uplo (in)       The triangle in matrix  C being referenced.
* @param transAB (in)    How matrices  A and  B is to be transposed.
* @param N (in)          Number of rows and columns in matrix  C.
* @param K (in)          Number of columns of the matrices  A and  B if they
*                       are not transposed, and number of rows otherwise.
* @param alpha (in)      The factor of matrices  A and  B.
* @param A (in)          Buffer object storing matrix  A.
* @param offA (in)       Offset of the first element of the matrix  A in the
*                       buffer object. Counted in elements.
* @param lda (in)        Leading dimension of matrix  A. For detailed
*                       description, see clblasSsyr2k().
* @param B (in)          Buffer object storing matrix  B.
* @param offB (in)       Offset of the first element of the matrix  B in the
*                       buffer object. Counted in elements.
* @param ldb (in)        Leading dimension of matrix  B. For detailed
*                       description, see clblasSsyr2k().
* @param beta (in)       The factor of matrix  C.
* @param C (out)         Buffer object storing matrix  C.
* @param offC (in)       Offset of the first element of the matrix  C in the
*                       buffer object. Counted in elements.
* @param ldc (in)        Leading dimension of matrix  C. It cannot be less
*                       than  N.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasInvalidDevice if a target device does not support floating
*        point arithmetic with double precision;
*   -  clblasInvalidValue if either  offA,  offB or  offC exceeds
*        the size of the respective buffer object;
*   - the same error codes as the clblasSsyr2k() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasDsyr2kNative(JNIEnv *env, jclass cls, jint order, jint uplo, jint transAB, jlong N, jlong K, jdouble alpha, jobject A, jlong offA, jlong lda, jobject B, jlong offB, jlong ldb, jdouble beta, jobject C, jlong offC, jlong ldc, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // transAB is primitive
    // N is primitive
    // K is primitive
    // alpha is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasDsyr2k");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // lda is primitive
    if (B == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasDsyr2k");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offB is primitive
    // ldb is primitive
    // beta is primitive
    if (C == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'C' is null for clblasDsyr2k");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offC is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasDsyr2k");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasDsyr2k(order=%d, uplo=%d, transAB=%d, N=%ld, K=%ld, alpha=%lf, A=%p, offA=%ld, lda=%ld, B=%p, offB=%ld, ldb=%ld, beta=%lf, C=%p, offC=%ld, ldc=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, transAB, N, K, alpha, A, offA, lda, B, offB, ldb, beta, C, offC, ldc, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    clblasTranspose transAB_native;
    size_t N_native = 0;
    size_t K_native = 0;
    cl_double alpha_native = 0.0;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    size_t lda_native = 0;
    cl_mem B_native = nullptr;
    size_t offB_native = 0;
    size_t ldb_native = 0;
    cl_double beta_native = 0.0;
    cl_mem C_native = nullptr;
    size_t offC_native = 0;
    size_t ldc_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    transAB_native = (clblasTranspose)transAB;
    N_native = (size_t)N;
    K_native = (size_t)K;
    alpha_native = (cl_double)alpha;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    lda_native = (size_t)lda;
    if (!initNative(env, B, B_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offB_native = (size_t)offB;
    ldb_native = (size_t)ldb;
    beta_native = (cl_double)beta;
    if (!initNative(env, C, C_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offC_native = (size_t)offC;
    ldc_native = (size_t)ldc;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasDsyr2k(order_native, uplo_native, transAB_native, N_native, K_native, alpha_native, A_native, offA_native, lda_native, B_native, offB_native, ldb_native, beta_native, C_native, offC_native, ldc_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // transAB is primitive
    // N is primitive
    // K is primitive
    // alpha is primitive
    // A is a read-only native pointer
    // offA is primitive
    // lda is primitive
    // B is a read-only native pointer
    // offB is primitive
    // ldb is primitive
    // beta is primitive
    // C is a read-only native pointer
    // offC is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Rank-2k update of a symmetric matrix with complex float elements..
*        Extended version.
*
* Rank-k updates:
*   - \f$ C \leftarrow \alpha A B^T + \alpha B A^T + eta C \f$
*   - \f$ C \leftarrow \alpha A^T B + \alpha B^T A eta C \f$
*
* where  C is a symmetric matrix.
*
* @param order (in)      Row/column order.
* @param uplo (in)       The triangle in matrix  C being referenced.
* @param transAB (in)    How matrices  A and  B is to be transposed.
* @param N (in)          Number of rows and columns in matrix  C.
* @param K (in)          Number of columns of the matrices  A and  B if they
*                       are not transposed, and number of rows otherwise.
* @param alpha (in)      The factor of matrices  A and  B.
* @param A (in)          Buffer object storing matrix  A.
* @param offA (in)       Offset of the first element of the matrix  A in the
*                       buffer object. Counted in elements.
* @param lda (in)        Leading dimension of matrix  A. For detailed
*                       description, see clblasSsyr2k().
* @param B (in)          Buffer object storing matrix  B.
* @param offB (in)       Offset of the first element of the matrix  B in the
*                       buffer object. Counted in elements.
* @param ldb (in)        Leading dimension of matrix  B. For detailed
*                       description, see clblasSsyr2k().
* @param beta (in)       The factor of matrix  C.
* @param C (out)         Buffer object storing matrix  C.
* @param offC (in)       Offset of the first element of the matrix  C in the
*                       buffer object. Counted in elements.
* @param ldc (in)        Leading dimension of matrix  C. It cannot be less
*                       than  N.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasInvalidValue if either  offA,  offB or  offC exceeds
*        the size of the respective buffer object;
*   -  clblasInvalidValue if  transAB is set to \ref clblasConjTrans.
*   - the same error codes as the clblasSsyr2k() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasCsyr2kNative(JNIEnv *env, jclass cls, jint order, jint uplo, jint transAB, jlong N, jlong K, jfloatArray alpha, jobject A, jlong offA, jlong lda, jobject B, jlong offB, jlong ldb, jfloatArray beta, jobject C, jlong offC, jlong ldc, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // transAB is primitive
    // N is primitive
    // K is primitive
    if (alpha == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'alpha' is null for clblasCsyr2k");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasCsyr2k");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // lda is primitive
    if (B == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasCsyr2k");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offB is primitive
    // ldb is primitive
    if (beta == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'beta' is null for clblasCsyr2k");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (C == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'C' is null for clblasCsyr2k");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offC is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasCsyr2k");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasCsyr2k(order=%d, uplo=%d, transAB=%d, N=%ld, K=%ld, alpha=%p, A=%p, offA=%ld, lda=%ld, B=%p, offB=%ld, ldb=%ld, beta=%p, C=%p, offC=%ld, ldc=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, transAB, N, K, alpha, A, offA, lda, B, offB, ldb, beta, C, offC, ldc, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    clblasTranspose transAB_native;
    size_t N_native = 0;
    size_t K_native = 0;
    FloatComplex alpha_native;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    size_t lda_native = 0;
    cl_mem B_native = nullptr;
    size_t offB_native = 0;
    size_t ldb_native = 0;
    FloatComplex beta_native;
    cl_mem C_native = nullptr;
    size_t offC_native = 0;
    size_t ldc_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    transAB_native = (clblasTranspose)transAB;
    N_native = (size_t)N;
    K_native = (size_t)K;
    if (!initNative(env, alpha, alpha_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    lda_native = (size_t)lda;
    if (!initNative(env, B, B_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offB_native = (size_t)offB;
    ldb_native = (size_t)ldb;
    if (!initNative(env, beta, beta_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, C, C_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offC_native = (size_t)offC;
    ldc_native = (size_t)ldc;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasCsyr2k(order_native, uplo_native, transAB_native, N_native, K_native, alpha_native, A_native, offA_native, lda_native, B_native, offB_native, ldb_native, beta_native, C_native, offC_native, ldc_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // transAB is primitive
    // N is primitive
    // K is primitive
    if (!releaseNative(env, alpha_native, alpha, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // A is a read-only native pointer
    // offA is primitive
    // lda is primitive
    // B is a read-only native pointer
    // offB is primitive
    // ldb is primitive
    if (!releaseNative(env, beta_native, beta, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // C is a read-only native pointer
    // offC is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Rank-2k update of a symmetric matrix with complex double elements..
*        Extended version.
*
* Rank-k updates:
*   - \f$ C \leftarrow \alpha A B^T + \alpha B A^T + eta C \f$
*   - \f$ C \leftarrow \alpha A^T B + \alpha B^T A eta C \f$
*
* where  C is a symmetric matrix.
*
* @param order (in)      Row/column order.
* @param uplo (in)       The triangle in matrix  C being referenced.
* @param transAB (in)    How matrices  A and  B is to be transposed.
* @param N (in)          Number of rows and columns in matrix  C.
* @param K (in)          Number of columns of the matrices  A and  B if they
*                       are not transposed, and number of rows otherwise.
* @param alpha (in)      The factor of matrices  A and  B.
* @param A (in)          Buffer object storing matrix  A.
* @param offA (in)       Offset of the first element of the matrix  A in the
*                       buffer object. Counted in elements.
* @param lda (in)        Leading dimension of matrix  A. For detailed
*                       description, see clblasSsyr2k().
* @param B (in)          Buffer object storing matrix  B.
* @param offB (in)       Offset of the first element of the matrix  B in the
*                       buffer object. Counted in elements.
* @param ldb (in)        Leading dimension of matrix  B. For detailed
*                       description, see clblasSsyr2k().
* @param beta (in)       The factor of matrix  C.
* @param C (out)         Buffer object storing matrix  C.
* @param offC (in)       Offset of the first element of the matrix  C in the
*                       buffer object. Counted in elements.
* @param ldc (in)        Leading dimension of matrix  C. It cannot be less
*                       than  N.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasInvalidDevice if a target device does not support floating
*        point arithmetic with double precision;
*   -  clblasInvalidValue if either  offA,  offB or  offC exceeds
*        the size of the respective buffer object;
*   -  clblasInvalidValue if  transAB is set to \ref clblasConjTrans.
*   - the same error codes as the clblasSsyr2k() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasZsyr2kNative(JNIEnv *env, jclass cls, jint order, jint uplo, jint transAB, jlong N, jlong K, jdoubleArray alpha, jobject A, jlong offA, jlong lda, jobject B, jlong offB, jlong ldb, jdoubleArray beta, jobject C, jlong offC, jlong ldc, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // transAB is primitive
    // N is primitive
    // K is primitive
    if (alpha == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'alpha' is null for clblasZsyr2k");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasZsyr2k");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // lda is primitive
    if (B == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasZsyr2k");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offB is primitive
    // ldb is primitive
    if (beta == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'beta' is null for clblasZsyr2k");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (C == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'C' is null for clblasZsyr2k");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offC is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasZsyr2k");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasZsyr2k(order=%d, uplo=%d, transAB=%d, N=%ld, K=%ld, alpha=%p, A=%p, offA=%ld, lda=%ld, B=%p, offB=%ld, ldb=%ld, beta=%p, C=%p, offC=%ld, ldc=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, transAB, N, K, alpha, A, offA, lda, B, offB, ldb, beta, C, offC, ldc, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    clblasTranspose transAB_native;
    size_t N_native = 0;
    size_t K_native = 0;
    DoubleComplex alpha_native;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    size_t lda_native = 0;
    cl_mem B_native = nullptr;
    size_t offB_native = 0;
    size_t ldb_native = 0;
    DoubleComplex beta_native;
    cl_mem C_native = nullptr;
    size_t offC_native = 0;
    size_t ldc_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    transAB_native = (clblasTranspose)transAB;
    N_native = (size_t)N;
    K_native = (size_t)K;
    if (!initNative(env, alpha, alpha_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    lda_native = (size_t)lda;
    if (!initNative(env, B, B_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offB_native = (size_t)offB;
    ldb_native = (size_t)ldb;
    if (!initNative(env, beta, beta_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, C, C_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offC_native = (size_t)offC;
    ldc_native = (size_t)ldc;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasZsyr2k(order_native, uplo_native, transAB_native, N_native, K_native, alpha_native, A_native, offA_native, lda_native, B_native, offB_native, ldb_native, beta_native, C_native, offC_native, ldc_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // transAB is primitive
    // N is primitive
    // K is primitive
    if (!releaseNative(env, alpha_native, alpha, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // A is a read-only native pointer
    // offA is primitive
    // lda is primitive
    // B is a read-only native pointer
    // offB is primitive
    // ldb is primitive
    if (!releaseNative(env, beta_native, beta, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // C is a read-only native pointer
    // offC is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Matrix-matrix product of symmetric rectangular matrices with float.
* elements.
*
* Matrix-matrix products:
*   - \f$ C \leftarrow \alpha A B + eta C \f$
*   - \f$ C \leftarrow \alpha B A + eta C \f$
*
* @param order (in)     Row/column order.
* @param side		The (in) side of triangular matrix.
* @param uplo		The (in) triangle in matrix being referenced.
* @param M (in)         Number of rows in matrices  B and  C.
* @param N (in)         Number of columns in matrices  B and  C.
* @param alpha (in)     The factor of matrix  A.
* @param A (in)         Buffer object storing matrix  A.
* @param offa (in)      Offset of the first element of the matrix  A in the
*                      buffer object. Counted in elements.
* @param lda (in)       Leading dimension of matrix  A. It cannot be less
*                      than  M when the  side parameter is set to
*                       clblasLeft,\n or less than  N when the
*                      parameter is set to  clblasRight.
* @param B (in)         Buffer object storing matrix  B.
* @param offb (in)      Offset of the first element of the matrix  B in the
*                      buffer object. Counted in elements.
* @param ldb (in)       Leading dimension of matrix  B. It cannot be less
*                      than  N when the  order parameter is set to
*                       clblasRowMajor,\n or less than  M
*                      when it is set to  clblasColumnMajor.
* @param beta (in)      The factor of matrix  C.
* @param C (out)        Buffer object storing matrix  C.
* @param offc (in)      Offset of the first element of the matrix  C in the
*                      buffer object. Counted in elements.
* @param ldc (in)       Leading dimension of matrix  C. It cannot be less
*                      than  N when the  order parameter is set to
*                       clblasRowMajor,\n or less than  M when
*                      it is set to  clblasColumnMajorOrder.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events			 (in)  Event objects per each command queue that identify
*								  a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasNotInitialized if clblasSetup() was not called;
*   -  clblasInvalidValue if invalid parameters are passed:
*     -  M or  N is zero, or
*     - any of the leading dimensions is invalid;
*     - the matrix sizes lead to accessing outsize of any of the buffers;
*   -  clblasInvalidMemObject if A, B, or C object is invalid,
*     or an image object rather than the buffer one;
*   -  clblasOutOfResources if you use image-based function implementation
*     and no suitable scratch image available;
*   -  clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   -  clblasInvalidCommandQueue if the passed command queue is invalid;
*   -  clblasInvalidContext if a context a passed command queue belongs to
*     was released;
*   -  clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   -  clblasCompilerNotAvailable if a compiler is not available;
*   -  clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasSsymmNative(JNIEnv *env, jclass cls, jint order, jint side, jint uplo, jlong M, jlong N, jfloat alpha, jobject A, jlong offa, jlong lda, jobject B, jlong offb, jlong ldb, jfloat beta, jobject C, jlong offc, jlong ldc, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // side is primitive
    // uplo is primitive
    // M is primitive
    // N is primitive
    // alpha is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasSsymm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    if (B == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasSsymm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offb is primitive
    // ldb is primitive
    // beta is primitive
    if (C == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'C' is null for clblasSsymm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offc is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasSsymm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasSsymm(order=%d, side=%d, uplo=%d, M=%ld, N=%ld, alpha=%f, A=%p, offa=%ld, lda=%ld, B=%p, offb=%ld, ldb=%ld, beta=%f, C=%p, offc=%ld, ldc=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, side, uplo, M, N, alpha, A, offa, lda, B, offb, ldb, beta, C, offc, ldc, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasSide side_native;
    clblasUplo uplo_native;
    size_t M_native = 0;
    size_t N_native = 0;
    cl_float alpha_native = 0.0f;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_mem B_native = nullptr;
    size_t offb_native = 0;
    size_t ldb_native = 0;
    cl_float beta_native = 0.0f;
    cl_mem C_native = nullptr;
    size_t offc_native = 0;
    size_t ldc_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    side_native = (clblasSide)side;
    uplo_native = (clblasUplo)uplo;
    M_native = (size_t)M;
    N_native = (size_t)N;
    alpha_native = (cl_float)alpha;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    if (!initNative(env, B, B_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offb_native = (size_t)offb;
    ldb_native = (size_t)ldb;
    beta_native = (cl_float)beta;
    if (!initNative(env, C, C_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offc_native = (size_t)offc;
    ldc_native = (size_t)ldc;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasSsymm(order_native, side_native, uplo_native, M_native, N_native, alpha_native, A_native, offa_native, lda_native, B_native, offb_native, ldb_native, beta_native, C_native, offc_native, ldc_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // side is primitive
    // uplo is primitive
    // M is primitive
    // N is primitive
    // alpha is primitive
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // B is a read-only native pointer
    // offb is primitive
    // ldb is primitive
    // beta is primitive
    // C is a read-only native pointer
    // offc is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* @example example_ssymm.c
* This is an example of how to use the @ref clblasSsymm function.
*/
/**
* Matrix-matrix product of symmetric rectangular matrices with double.
* elements.
*
* Matrix-matrix products:
*   - \f$ C \leftarrow \alpha A B + eta C \f$
*   - \f$ C \leftarrow \alpha B A + eta C \f$
*
* @param order (in)     Row/column order.
* @param side		The (in) side of triangular matrix.
* @param uplo		The (in) triangle in matrix being referenced.
* @param M (in)         Number of rows in matrices  B and  C.
* @param N (in)         Number of columns in matrices  B and  C.
* @param alpha (in)     The factor of matrix  A.
* @param A (in)         Buffer object storing matrix  A.
* @param offa (in)      Offset of the first element of the matrix  A in the
*                      buffer object. Counted in elements.
* @param lda (in)       Leading dimension of matrix  A. It cannot be less
*                      than  M when the  side parameter is set to
*                       clblasLeft,\n or less than  N when the
*                      parameter is set to  clblasRight.
* @param B (in)         Buffer object storing matrix  B.
* @param offb (in)      Offset of the first element of the matrix  B in the
*                      buffer object. Counted in elements.
* @param ldb (in)       Leading dimension of matrix  B. It cannot be less
*                      than  N when the  order parameter is set to
*                       clblasRowMajor,\n or less than  M
*                      when it is set to  clblasColumnMajor.
* @param beta (in)      The factor of matrix  C.
* @param C (out)        Buffer object storing matrix  C.
* @param offc (in)      Offset of the first element of the matrix  C in the
*                      buffer object. Counted in elements.
* @param ldc (in)       Leading dimension of matrix  C. It cannot be less
*                      than  N when the  order parameter is set to
*                       clblasRowMajor,\n or less than  M when
*                      it is set to  clblasColumnMajorOrder.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events			 (in)  Event objects per each command queue that identify
*								  a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasInvalidDevice if a target device does not support floating
*     point arithmetic with double precision;
*   - the same error codes as the clblasSsymm() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasDsymmNative(JNIEnv *env, jclass cls, jint order, jint side, jint uplo, jlong M, jlong N, jdouble alpha, jobject A, jlong offa, jlong lda, jobject B, jlong offb, jlong ldb, jdouble beta, jobject C, jlong offc, jlong ldc, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // side is primitive
    // uplo is primitive
    // M is primitive
    // N is primitive
    // alpha is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasDsymm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    if (B == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasDsymm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offb is primitive
    // ldb is primitive
    // beta is primitive
    if (C == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'C' is null for clblasDsymm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offc is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasDsymm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasDsymm(order=%d, side=%d, uplo=%d, M=%ld, N=%ld, alpha=%lf, A=%p, offa=%ld, lda=%ld, B=%p, offb=%ld, ldb=%ld, beta=%lf, C=%p, offc=%ld, ldc=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, side, uplo, M, N, alpha, A, offa, lda, B, offb, ldb, beta, C, offc, ldc, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasSide side_native;
    clblasUplo uplo_native;
    size_t M_native = 0;
    size_t N_native = 0;
    cl_double alpha_native = 0.0;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_mem B_native = nullptr;
    size_t offb_native = 0;
    size_t ldb_native = 0;
    cl_double beta_native = 0.0;
    cl_mem C_native = nullptr;
    size_t offc_native = 0;
    size_t ldc_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    side_native = (clblasSide)side;
    uplo_native = (clblasUplo)uplo;
    M_native = (size_t)M;
    N_native = (size_t)N;
    alpha_native = (cl_double)alpha;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    if (!initNative(env, B, B_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offb_native = (size_t)offb;
    ldb_native = (size_t)ldb;
    beta_native = (cl_double)beta;
    if (!initNative(env, C, C_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offc_native = (size_t)offc;
    ldc_native = (size_t)ldc;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasDsymm(order_native, side_native, uplo_native, M_native, N_native, alpha_native, A_native, offa_native, lda_native, B_native, offb_native, ldb_native, beta_native, C_native, offc_native, ldc_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // side is primitive
    // uplo is primitive
    // M is primitive
    // N is primitive
    // alpha is primitive
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // B is a read-only native pointer
    // offb is primitive
    // ldb is primitive
    // beta is primitive
    // C is a read-only native pointer
    // offc is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Matrix-matrix product of symmetric rectangular matrices with.
* float-complex elements.
*
* Matrix-matrix products:
*   - \f$ C \leftarrow \alpha A B + eta C \f$
*   - \f$ C \leftarrow \alpha B A + eta C \f$
*
* @param order (in)     Row/column order.
* @param side		The (in) side of triangular matrix.
* @param uplo		The (in) triangle in matrix being referenced.
* @param M (in)         Number of rows in matrices  B and  C.
* @param N (in)         Number of columns in matrices  B and  C.
* @param alpha (in)     The factor of matrix  A.
* @param A (in)         Buffer object storing matrix  A.
* @param offa (in)      Offset of the first element of the matrix  A in the
*                      buffer object. Counted in elements.
* @param lda (in)       Leading dimension of matrix  A. It cannot be less
*                      than  M when the  side parameter is set to
*                       clblasLeft,\n or less than  N when the
*                      parameter is set to  clblasRight.
* @param B (in)         Buffer object storing matrix  B.
* @param offb (in)      Offset of the first element of the matrix  B in the
*                      buffer object. Counted in elements.
* @param ldb (in)       Leading dimension of matrix  B. It cannot be less
*                      than  N when the  order parameter is set to
*                       clblasRowMajor,\n or less than  M
*                      when it is set to  clblasColumnMajor.
* @param beta (in)      The factor of matrix  C.
* @param C (out)        Buffer object storing matrix  C.
* @param offc (in)      Offset of the first element of the matrix  C in the
*                      buffer object. Counted in elements.
* @param ldc (in)       Leading dimension of matrix  C. It cannot be less
*                      than  N when the  order parameter is set to
*                       clblasRowMajor,\n or less than  M when
*                      it is set to  clblasColumnMajorOrder.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events			 (in)  Event objects per each command queue that identify
*								  a particular kernel execution instance.
*
* @return The same result as the clblasSsymm() function.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasCsymmNative(JNIEnv *env, jclass cls, jint order, jint side, jint uplo, jlong M, jlong N, jfloatArray alpha, jobject A, jlong offa, jlong lda, jobject B, jlong offb, jlong ldb, jfloatArray beta, jobject C, jlong offc, jlong ldc, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // side is primitive
    // uplo is primitive
    // M is primitive
    // N is primitive
    if (alpha == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'alpha' is null for clblasCsymm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasCsymm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    if (B == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasCsymm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offb is primitive
    // ldb is primitive
    if (beta == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'beta' is null for clblasCsymm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (C == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'C' is null for clblasCsymm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offc is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasCsymm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasCsymm(order=%d, side=%d, uplo=%d, M=%ld, N=%ld, alpha=%p, A=%p, offa=%ld, lda=%ld, B=%p, offb=%ld, ldb=%ld, beta=%p, C=%p, offc=%ld, ldc=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, side, uplo, M, N, alpha, A, offa, lda, B, offb, ldb, beta, C, offc, ldc, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasSide side_native;
    clblasUplo uplo_native;
    size_t M_native = 0;
    size_t N_native = 0;
    cl_float2 alpha_native;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_mem B_native = nullptr;
    size_t offb_native = 0;
    size_t ldb_native = 0;
    cl_float2 beta_native;
    cl_mem C_native = nullptr;
    size_t offc_native = 0;
    size_t ldc_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    side_native = (clblasSide)side;
    uplo_native = (clblasUplo)uplo;
    M_native = (size_t)M;
    N_native = (size_t)N;
    if (!initNative(env, alpha, alpha_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    if (!initNative(env, B, B_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offb_native = (size_t)offb;
    ldb_native = (size_t)ldb;
    if (!initNative(env, beta, beta_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, C, C_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offc_native = (size_t)offc;
    ldc_native = (size_t)ldc;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasCsymm(order_native, side_native, uplo_native, M_native, N_native, alpha_native, A_native, offa_native, lda_native, B_native, offb_native, ldb_native, beta_native, C_native, offc_native, ldc_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // side is primitive
    // uplo is primitive
    // M is primitive
    // N is primitive
    if (!releaseNative(env, alpha_native, alpha, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // B is a read-only native pointer
    // offb is primitive
    // ldb is primitive
    if (!releaseNative(env, beta_native, beta, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // C is a read-only native pointer
    // offc is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Matrix-matrix product of symmetric rectangular matrices with.
* double-complex elements.
*
* Matrix-matrix products:
*   - \f$ C \leftarrow \alpha A B + eta C \f$
*   - \f$ C \leftarrow \alpha B A + eta C \f$
*
* @param order (in)     Row/column order.
* @param side		The (in) side of triangular matrix.
* @param uplo		The (in) triangle in matrix being referenced.
* @param M (in)         Number of rows in matrices  B and  C.
* @param N (in)         Number of columns in matrices  B and  C.
* @param alpha (in)     The factor of matrix  A.
* @param A (in)         Buffer object storing matrix  A.
* @param offa (in)      Offset of the first element of the matrix  A in the
*                      buffer object. Counted in elements.
* @param lda (in)       Leading dimension of matrix  A. It cannot be less
*                      than  M when the  side parameter is set to
*                       clblasLeft,\n or less than  N when the
*                      parameter is set to  clblasRight.
* @param B (in)         Buffer object storing matrix  B.
* @param offb (in)      Offset of the first element of the matrix  B in the
*                      buffer object. Counted in elements.
* @param ldb (in)       Leading dimension of matrix  B. It cannot be less
*                      than  N when the  order parameter is set to
*                       clblasRowMajor,\n or less than  M
*                      when it is set to  clblasColumnMajor.
* @param beta (in)      The factor of matrix  C.
* @param C (out)        Buffer object storing matrix  C.
* @param offc (in)      Offset of the first element of the matrix  C in the
*                      buffer object. Counted in elements.
* @param ldc (in)       Leading dimension of matrix  C. It cannot be less
*                      than  N when the  order parameter is set to
*                       clblasRowMajor,\n or less than  M when
*                      it is set to  clblasColumnMajorOrder.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events			 (in)  Event objects per each command queue that identify
*								  a particular kernel execution instance.
*
* @return The same result as the clblasDsymm() function.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasZsymmNative(JNIEnv *env, jclass cls, jint order, jint side, jint uplo, jlong M, jlong N, jdoubleArray alpha, jobject A, jlong offa, jlong lda, jobject B, jlong offb, jlong ldb, jdoubleArray beta, jobject C, jlong offc, jlong ldc, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // side is primitive
    // uplo is primitive
    // M is primitive
    // N is primitive
    if (alpha == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'alpha' is null for clblasZsymm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasZsymm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    if (B == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasZsymm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offb is primitive
    // ldb is primitive
    if (beta == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'beta' is null for clblasZsymm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (C == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'C' is null for clblasZsymm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offc is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasZsymm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasZsymm(order=%d, side=%d, uplo=%d, M=%ld, N=%ld, alpha=%p, A=%p, offa=%ld, lda=%ld, B=%p, offb=%ld, ldb=%ld, beta=%p, C=%p, offc=%ld, ldc=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, side, uplo, M, N, alpha, A, offa, lda, B, offb, ldb, beta, C, offc, ldc, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasSide side_native;
    clblasUplo uplo_native;
    size_t M_native = 0;
    size_t N_native = 0;
    cl_double2 alpha_native;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_mem B_native = nullptr;
    size_t offb_native = 0;
    size_t ldb_native = 0;
    cl_double2 beta_native;
    cl_mem C_native = nullptr;
    size_t offc_native = 0;
    size_t ldc_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    side_native = (clblasSide)side;
    uplo_native = (clblasUplo)uplo;
    M_native = (size_t)M;
    N_native = (size_t)N;
    if (!initNative(env, alpha, alpha_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    if (!initNative(env, B, B_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offb_native = (size_t)offb;
    ldb_native = (size_t)ldb;
    if (!initNative(env, beta, beta_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, C, C_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offc_native = (size_t)offc;
    ldc_native = (size_t)ldc;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasZsymm(order_native, side_native, uplo_native, M_native, N_native, alpha_native, A_native, offa_native, lda_native, B_native, offb_native, ldb_native, beta_native, C_native, offc_native, ldc_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // side is primitive
    // uplo is primitive
    // M is primitive
    // N is primitive
    if (!releaseNative(env, alpha_native, alpha, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // B is a read-only native pointer
    // offb is primitive
    // ldb is primitive
    if (!releaseNative(env, beta_native, beta, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // C is a read-only native pointer
    // offc is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Matrix-matrix product of hermitian rectangular matrices with.
* float-complex elements.
*
* Matrix-matrix products:
*   - \f$ C \leftarrow \alpha A B + eta C \f$
*   - \f$ C \leftarrow \alpha B A + eta C \f$
*
* @param order (in)     Row/column order.
* @param side		The (in) side of triangular matrix.
* @param uplo		The (in) triangle in matrix being referenced.
* @param M (in)         Number of rows in matrices  B and  C.
* @param N (in)         Number of columns in matrices  B and  C.
* @param alpha (in)     The factor of matrix  A.
* @param A (in)         Buffer object storing matrix  A.
* @param offa (in)      Offset of the first element of the matrix  A in the
*                      buffer object. Counted in elements.
* @param lda (in)       Leading dimension of matrix  A. It cannot be less
*                      than  M when the  side parameter is set to
*                       clblasLeft,\n or less than  N when the
*                      parameter is set to  clblasRight.
* @param B (in)         Buffer object storing matrix  B.
* @param offb (in)      Offset of the first element of the matrix  B in the
*                      buffer object. Counted in elements.
* @param ldb (in)       Leading dimension of matrix  B. It cannot be less
*                      than  N when the  order parameter is set to
*                       clblasRowMajor,\n or less than  M
*                      when it is set to  clblasColumnMajor.
* @param beta (in)      The factor of matrix  C.
* @param C (out)        Buffer object storing matrix  C.
* @param offc (in)      Offset of the first element of the matrix  C in the
*                      buffer object. Counted in elements.
* @param ldc (in)       Leading dimension of matrix  C. It cannot be less
*                      than  N when the  order parameter is set to
*                       clblasRowMajor,\n or less than  M when
*                      it is set to  clblasColumnMajorOrder.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasNotInitialized if clblasSetup() was not called;
*   -  clblasInvalidValue if invalid parameters are passed:
*     -  M or  N is zero, or
*     - any of the leading dimensions is invalid;
*     - the matrix sizes lead to accessing outsize of any of the buffers;
*   -  clblasInvalidMemObject if A, B, or C object is invalid,
*     or an image object rather than the buffer one;
*   -  clblasOutOfResources if you use image-based function implementation
*     and no suitable scratch image available;
*   -  clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   -  clblasInvalidCommandQueue if the passed command queue is invalid;
*   -  clblasInvalidContext if a context a passed command queue belongs to
*     was released;
*   -  clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   -  clblasCompilerNotAvailable if a compiler is not available;
*   -  clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasChemmNative(JNIEnv *env, jclass cls, jint order, jint side, jint uplo, jlong M, jlong N, jfloatArray alpha, jobject A, jlong offa, jlong lda, jobject B, jlong offb, jlong ldb, jfloatArray beta, jobject C, jlong offc, jlong ldc, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // side is primitive
    // uplo is primitive
    // M is primitive
    // N is primitive
    if (alpha == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'alpha' is null for clblasChemm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasChemm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    if (B == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasChemm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offb is primitive
    // ldb is primitive
    if (beta == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'beta' is null for clblasChemm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (C == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'C' is null for clblasChemm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offc is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasChemm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasChemm(order=%d, side=%d, uplo=%d, M=%ld, N=%ld, alpha=%p, A=%p, offa=%ld, lda=%ld, B=%p, offb=%ld, ldb=%ld, beta=%p, C=%p, offc=%ld, ldc=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, side, uplo, M, N, alpha, A, offa, lda, B, offb, ldb, beta, C, offc, ldc, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasSide side_native;
    clblasUplo uplo_native;
    size_t M_native = 0;
    size_t N_native = 0;
    cl_float2 alpha_native;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_mem B_native = nullptr;
    size_t offb_native = 0;
    size_t ldb_native = 0;
    cl_float2 beta_native;
    cl_mem C_native = nullptr;
    size_t offc_native = 0;
    size_t ldc_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    side_native = (clblasSide)side;
    uplo_native = (clblasUplo)uplo;
    M_native = (size_t)M;
    N_native = (size_t)N;
    if (!initNative(env, alpha, alpha_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    if (!initNative(env, B, B_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offb_native = (size_t)offb;
    ldb_native = (size_t)ldb;
    if (!initNative(env, beta, beta_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, C, C_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offc_native = (size_t)offc;
    ldc_native = (size_t)ldc;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasChemm(order_native, side_native, uplo_native, M_native, N_native, alpha_native, A_native, offa_native, lda_native, B_native, offb_native, ldb_native, beta_native, C_native, offc_native, ldc_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // side is primitive
    // uplo is primitive
    // M is primitive
    // N is primitive
    if (!releaseNative(env, alpha_native, alpha, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // B is a read-only native pointer
    // offb is primitive
    // ldb is primitive
    if (!releaseNative(env, beta_native, beta, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // C is a read-only native pointer
    // offc is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* @example example_chemm.cpp
* This is an example of how to use the @ref clblasChemm function.
*/
/**
* Matrix-matrix product of hermitian rectangular matrices with.
* double-complex elements.
*
* Matrix-matrix products:
*   - \f$ C \leftarrow \alpha A B + eta C \f$
*   - \f$ C \leftarrow \alpha B A + eta C \f$
*
* @param order (in)     Row/column order.
* @param side		The (in) side of triangular matrix.
* @param uplo		The (in) triangle in matrix being referenced.
* @param M (in)         Number of rows in matrices  B and  C.
* @param N (in)         Number of columns in matrices  B and  C.
* @param alpha (in)     The factor of matrix  A.
* @param A (in)         Buffer object storing matrix  A.
* @param offa (in)      Offset of the first element of the matrix  A in the
*                      buffer object. Counted in elements.
* @param lda (in)       Leading dimension of matrix  A. It cannot be less
*                      than  M when the  side parameter is set to
*                       clblasLeft,\n or less than  N when the
*                      parameter is set to  clblasRight.
* @param B (in)         Buffer object storing matrix  B.
* @param offb (in)      Offset of the first element of the matrix  B in the
*                      buffer object. Counted in elements.
* @param ldb (in)       Leading dimension of matrix  B. It cannot be less
*                      than  N when the  order parameter is set to
*                       clblasRowMajor,\n or less than  M
*                      when it is set to  clblasColumnMajor.
* @param beta (in)      The factor of matrix  C.
* @param C (out)        Buffer object storing matrix  C.
* @param offc (in)      Offset of the first element of the matrix  C in the
*                      buffer object. Counted in elements.
* @param ldc (in)       Leading dimension of matrix  C. It cannot be less
*                      than  N when the  order parameter is set to
*                       clblasRowMajor,\n or less than  M when
*                      it is set to  clblasColumnMajorOrder.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasInvalidDevice if a target device does not support floating
*     point arithmetic with double precision;
*   - the same error codes as the clblasChemm() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasZhemmNative(JNIEnv *env, jclass cls, jint order, jint side, jint uplo, jlong M, jlong N, jdoubleArray alpha, jobject A, jlong offa, jlong lda, jobject B, jlong offb, jlong ldb, jdoubleArray beta, jobject C, jlong offc, jlong ldc, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // side is primitive
    // uplo is primitive
    // M is primitive
    // N is primitive
    if (alpha == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'alpha' is null for clblasZhemm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasZhemm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    if (B == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasZhemm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offb is primitive
    // ldb is primitive
    if (beta == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'beta' is null for clblasZhemm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (C == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'C' is null for clblasZhemm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offc is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasZhemm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasZhemm(order=%d, side=%d, uplo=%d, M=%ld, N=%ld, alpha=%p, A=%p, offa=%ld, lda=%ld, B=%p, offb=%ld, ldb=%ld, beta=%p, C=%p, offc=%ld, ldc=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, side, uplo, M, N, alpha, A, offa, lda, B, offb, ldb, beta, C, offc, ldc, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasSide side_native;
    clblasUplo uplo_native;
    size_t M_native = 0;
    size_t N_native = 0;
    cl_double2 alpha_native;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_mem B_native = nullptr;
    size_t offb_native = 0;
    size_t ldb_native = 0;
    cl_double2 beta_native;
    cl_mem C_native = nullptr;
    size_t offc_native = 0;
    size_t ldc_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    side_native = (clblasSide)side;
    uplo_native = (clblasUplo)uplo;
    M_native = (size_t)M;
    N_native = (size_t)N;
    if (!initNative(env, alpha, alpha_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    if (!initNative(env, B, B_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offb_native = (size_t)offb;
    ldb_native = (size_t)ldb;
    if (!initNative(env, beta, beta_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, C, C_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offc_native = (size_t)offc;
    ldc_native = (size_t)ldc;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasZhemm(order_native, side_native, uplo_native, M_native, N_native, alpha_native, A_native, offa_native, lda_native, B_native, offb_native, ldb_native, beta_native, C_native, offc_native, ldc_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // side is primitive
    // uplo is primitive
    // M is primitive
    // N is primitive
    if (!releaseNative(env, alpha_native, alpha, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // B is a read-only native pointer
    // offb is primitive
    // ldb is primitive
    if (!releaseNative(env, beta_native, beta, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // C is a read-only native pointer
    // offc is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Rank-k update of a hermitian matrix with float-complex elements..
*
* Rank-k updates:
*   - \f$ C \leftarrow \alpha A A^H + eta C \f$
*   - \f$ C \leftarrow \alpha A^H A + eta C \f$
*
* where  C is a hermitian matrix.
*
* @param order (in)      Row/column order.
* @param uplo (in)       The triangle in matrix  C being referenced.
* @param transA (in)     How matrix  A is to be transposed.
* @param N (in)          Number of rows and columns in matrix  C.
* @param K (in)          Number of columns of the matrix  A if it is not
*                       transposed, and number of rows otherwise.
* @param alpha (in)      The factor of matrix  A.
* @param A (in)          Buffer object storing the matrix  A.
* @param offa (in)       Offset in number of elements for the first element in matrix  A.
* @param lda (in)        Leading dimension of matrix  A. It cannot be
*                       less than  K if  A is
*                       in the row-major format, and less than  N
*                       otherwise.
* @param beta (in)       The factor of the matrix  C.
* @param C (out)         Buffer object storing matrix  C.
* @param offc (in)       Offset in number of elements for the first element in matrix  C.
* @param ldc (in)        Leading dimension of matric  C. It cannot be less
*                       than  N.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasNotInitialized if clblasSetup() was not called;
*   -  clblasInvalidValue if invalid parameters are passed:
*     - either  N or  K is zero, or
*     - any of the leading dimensions is invalid;
*     - the matrix sizes lead to accessing outsize of any of the buffers;
*   -  clblasInvalidMemObject if either  A or  C object is
*     invalid, or an image object rather than the buffer one;
*   -  clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   -  clblasInvalidCommandQueue if the passed command queue is invalid;
*   -  clblasInvalidContext if a context a passed command queue belongs to
*     was released.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasCherkNative(JNIEnv *env, jclass cls, jint order, jint uplo, jint transA, jlong N, jlong K, jfloat alpha, jobject A, jlong offa, jlong lda, jfloat beta, jobject C, jlong offc, jlong ldc, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // transA is primitive
    // N is primitive
    // K is primitive
    // alpha is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasCherk");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    // beta is primitive
    if (C == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'C' is null for clblasCherk");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offc is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasCherk");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasCherk(order=%d, uplo=%d, transA=%d, N=%ld, K=%ld, alpha=%f, A=%p, offa=%ld, lda=%ld, beta=%f, C=%p, offc=%ld, ldc=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, transA, N, K, alpha, A, offa, lda, beta, C, offc, ldc, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    clblasTranspose transA_native;
    size_t N_native = 0;
    size_t K_native = 0;
    float alpha_native = 0.0f;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    float beta_native = 0.0f;
    cl_mem C_native = nullptr;
    size_t offc_native = 0;
    size_t ldc_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    transA_native = (clblasTranspose)transA;
    N_native = (size_t)N;
    K_native = (size_t)K;
    alpha_native = (float)alpha;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    beta_native = (float)beta;
    if (!initNative(env, C, C_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offc_native = (size_t)offc;
    ldc_native = (size_t)ldc;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasCherk(order_native, uplo_native, transA_native, N_native, K_native, alpha_native, A_native, offa_native, lda_native, beta_native, C_native, offc_native, ldc_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // transA is primitive
    // N is primitive
    // K is primitive
    // alpha is primitive
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // beta is primitive
    // C is a read-only native pointer
    // offc is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* @example example_cherk.cpp
* This is an example of how to use the @ref clblasCherk function.
*/
/**
* Rank-k update of a hermitian matrix with double-complex elements..
*
* Rank-k updates:
*   - \f$ C \leftarrow \alpha A A^H + eta C \f$
*   - \f$ C \leftarrow \alpha A^H A + eta C \f$
*
* where  C is a hermitian matrix.
*
* @param order (in)      Row/column order.
* @param uplo (in)       The triangle in matrix  C being referenced.
* @param transA (in)     How matrix  A is to be transposed.
* @param N (in)          Number of rows and columns in matrix  C.
* @param K (in)          Number of columns of the matrix  A if it is not
*                       transposed, and number of rows otherwise.
* @param alpha (in)      The factor of matrix  A.
* @param A (in)          Buffer object storing the matrix  A.
* @param offa (in)       Offset in number of elements for the first element in matrix  A.
* @param lda (in)        Leading dimension of matrix  A. It cannot be
*                       less than  K if  A is
*                       in the row-major format, and less than  N
*                       otherwise.
* @param beta (in)       The factor of the matrix  C.
* @param C (out)         Buffer object storing matrix  C.
* @param offc (in)       Offset in number of elements for the first element in matrix  C.
* @param ldc (in)        Leading dimension of matric  C. It cannot be less
*                       than  N.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasInvalidDevice if a target device does not support floating
*     point arithmetic with double precision;
*   - the same error codes as the clblasCherk() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasZherkNative(JNIEnv *env, jclass cls, jint order, jint uplo, jint transA, jlong N, jlong K, jdouble alpha, jobject A, jlong offa, jlong lda, jdouble beta, jobject C, jlong offc, jlong ldc, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // transA is primitive
    // N is primitive
    // K is primitive
    // alpha is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasZherk");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    // beta is primitive
    if (C == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'C' is null for clblasZherk");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offc is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasZherk");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasZherk(order=%d, uplo=%d, transA=%d, N=%ld, K=%ld, alpha=%lf, A=%p, offa=%ld, lda=%ld, beta=%lf, C=%p, offc=%ld, ldc=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, transA, N, K, alpha, A, offa, lda, beta, C, offc, ldc, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    clblasTranspose transA_native;
    size_t N_native = 0;
    size_t K_native = 0;
    double alpha_native = 0.0;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    double beta_native = 0.0;
    cl_mem C_native = nullptr;
    size_t offc_native = 0;
    size_t ldc_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    transA_native = (clblasTranspose)transA;
    N_native = (size_t)N;
    K_native = (size_t)K;
    alpha_native = (double)alpha;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    beta_native = (double)beta;
    if (!initNative(env, C, C_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offc_native = (size_t)offc;
    ldc_native = (size_t)ldc;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasZherk(order_native, uplo_native, transA_native, N_native, K_native, alpha_native, A_native, offa_native, lda_native, beta_native, C_native, offc_native, ldc_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // transA is primitive
    // N is primitive
    // K is primitive
    // alpha is primitive
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // beta is primitive
    // C is a read-only native pointer
    // offc is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Rank-2k update of a hermitian matrix with float-complex elements..
*
* Rank-k updates:
*   - \f$ C \leftarrow \alpha A B^H + conj( \alpha ) B A^H + eta C \f$
*   - \f$ C \leftarrow \alpha A^H B + conj( \alpha ) B^H A + eta C \f$
*
* where  C is a hermitian matrix.
*
* @param order (in)      Row/column order.
* @param uplo (in)       The triangle in matrix  C being referenced.
* @param trans (in)      How matrix  A is to be transposed.
* @param N (in)          Number of rows and columns in matrix  C.
* @param K (in)          Number of columns of the matrix  A if it is not
*                       transposed, and number of rows otherwise.
* @param alpha (in)      The factor of matrix  A.
* @param A (in)          Buffer object storing the matrix  A.
* @param offa (in)       Offset in number of elements for the first element in matrix  A.
* @param lda (in)        Leading dimension of matrix  A. It cannot be
*                       less than  K if  A is
*                       in the row-major format, and less than  N
*                       otherwise. Vice-versa for transpose case.
* @param B (in)          Buffer object storing the matrix  B.
* @param offb (in)       Offset in number of elements for the first element in matrix  B.
* @param ldb (in)        Leading dimension of matrix  B. It cannot be
*                       less than  K if  B is
*                       in the row-major format, and less than  N
*                       otherwise. Vice-versa for transpose case
* @param beta (in)       The factor of the matrix  C.
* @param C (out)         Buffer object storing matrix  C.
* @param offc (in)       Offset in number of elements for the first element in matrix  C.
* @param ldc (in)        Leading dimension of matric  C. It cannot be less
*                       than  N.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasNotInitialized if clblasSetup() was not called;
*   -  clblasInvalidValue if invalid parameters are passed:
*     - either  N or  K is zero, or
*     - any of the leading dimensions is invalid;
*     - the matrix sizes lead to accessing outsize of any of the buffers;
*   -  clblasInvalidMemObject if either  A ,  B or  C object is
*     invalid, or an image object rather than the buffer one;
*   -  clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   -  clblasInvalidCommandQueue if the passed command queue is invalid;
*   -  clblasInvalidContext if a context a passed command queue belongs to
*     was released.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasCher2kNative(JNIEnv *env, jclass cls, jint order, jint uplo, jint trans, jlong N, jlong K, jfloatArray alpha, jobject A, jlong offa, jlong lda, jobject B, jlong offb, jlong ldb, jfloat beta, jobject C, jlong offc, jlong ldc, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // N is primitive
    // K is primitive
    if (alpha == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'alpha' is null for clblasCher2k");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasCher2k");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    if (B == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasCher2k");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offb is primitive
    // ldb is primitive
    // beta is primitive
    if (C == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'C' is null for clblasCher2k");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offc is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasCher2k");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasCher2k(order=%d, uplo=%d, trans=%d, N=%ld, K=%ld, alpha=%p, A=%p, offa=%ld, lda=%ld, B=%p, offb=%ld, ldb=%ld, beta=%f, C=%p, offc=%ld, ldc=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, trans, N, K, alpha, A, offa, lda, B, offb, ldb, beta, C, offc, ldc, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    clblasTranspose trans_native;
    size_t N_native = 0;
    size_t K_native = 0;
    FloatComplex alpha_native;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_mem B_native = nullptr;
    size_t offb_native = 0;
    size_t ldb_native = 0;
    cl_float beta_native = 0.0f;
    cl_mem C_native = nullptr;
    size_t offc_native = 0;
    size_t ldc_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    trans_native = (clblasTranspose)trans;
    N_native = (size_t)N;
    K_native = (size_t)K;
    if (!initNative(env, alpha, alpha_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    if (!initNative(env, B, B_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offb_native = (size_t)offb;
    ldb_native = (size_t)ldb;
    beta_native = (cl_float)beta;
    if (!initNative(env, C, C_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offc_native = (size_t)offc;
    ldc_native = (size_t)ldc;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasCher2k(order_native, uplo_native, trans_native, N_native, K_native, alpha_native, A_native, offa_native, lda_native, B_native, offb_native, ldb_native, beta_native, C_native, offc_native, ldc_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // N is primitive
    // K is primitive
    if (!releaseNative(env, alpha_native, alpha, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // B is a read-only native pointer
    // offb is primitive
    // ldb is primitive
    // beta is primitive
    // C is a read-only native pointer
    // offc is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* @example example_cher2k.c
* This is an example of how to use the @ref clblasCher2k function.
*/
/**
* Rank-2k update of a hermitian matrix with double-complex elements..
*
* Rank-k updates:
*   - \f$ C \leftarrow \alpha A B^H + conj( \alpha ) B A^H + eta C \f$
*   - \f$ C \leftarrow \alpha A^H B + conj( \alpha ) B^H A + eta C \f$
*
* where  C is a hermitian matrix.
*
* @param order (in)      Row/column order.
* @param uplo (in)       The triangle in matrix  C being referenced.
* @param trans (in)      How matrix  A is to be transposed.
* @param N (in)          Number of rows and columns in matrix  C.
* @param K (in)          Number of columns of the matrix  A if it is not
*                       transposed, and number of rows otherwise.
* @param alpha (in)      The factor of matrix  A.
* @param A (in)          Buffer object storing the matrix  A.
* @param offa (in)       Offset in number of elements for the first element in matrix  A.
* @param lda (in)        Leading dimension of matrix  A. It cannot be
*                       less than  K if  A is
*                       in the row-major format, and less than  N
*                       otherwise. Vice-versa for transpose case.
* @param B (in)          Buffer object storing the matrix  B.
* @param offb (in)       Offset in number of elements for the first element in matrix  B.
* @param ldb (in)        Leading dimension of matrix  B. It cannot be
*                       less than  K if B is
*                       in the row-major format, and less than  N
*                       otherwise. Vice-versa for transpose case.
* @param beta (in)       The factor of the matrix  C.
* @param C (out)         Buffer object storing matrix  C.
* @param offc (in)       Offset in number of elements for the first element in matrix  C.
* @param ldc (in)        Leading dimension of matric  C. It cannot be less
*                       than  N.
* @param numCommandQueues (in)    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param commandQueues (in)       OpenCL command queues.
* @param numEventsInWaitList (in) Number of events in the event wait list.
* @param eventWaitList (in)       Event wait list.
* @param events (in)     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   -  clblasSuccess on success;
*   -  clblasInvalidDevice if a target device does not support floating
*     point arithmetic with double precision;
*   - the same error codes as the clblasCher2k() function otherwise.
*
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasZher2kNative(JNIEnv *env, jclass cls, jint order, jint uplo, jint trans, jlong N, jlong K, jdoubleArray alpha, jobject A, jlong offa, jlong lda, jobject B, jlong offb, jlong ldb, jdouble beta, jobject C, jlong offc, jlong ldc, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // N is primitive
    // K is primitive
    if (alpha == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'alpha' is null for clblasZher2k");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasZher2k");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    if (B == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasZher2k");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offb is primitive
    // ldb is primitive
    // beta is primitive
    if (C == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'C' is null for clblasZher2k");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offc is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (commandQueues == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasZher2k");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasZher2k(order=%d, uplo=%d, trans=%d, N=%ld, K=%ld, alpha=%p, A=%p, offa=%ld, lda=%ld, B=%p, offb=%ld, ldb=%ld, beta=%lf, C=%p, offc=%ld, ldc=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, trans, N, K, alpha, A, offa, lda, B, offb, ldb, beta, C, offc, ldc, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    clblasTranspose trans_native;
    size_t N_native = 0;
    size_t K_native = 0;
    DoubleComplex alpha_native;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_mem B_native = nullptr;
    size_t offb_native = 0;
    size_t ldb_native = 0;
    cl_double beta_native = 0.0;
    cl_mem C_native = nullptr;
    size_t offc_native = 0;
    size_t ldc_native = 0;
    cl_uint numCommandQueues_native = 0;
    cl_command_queue * commandQueues_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    trans_native = (clblasTranspose)trans;
    N_native = (size_t)N;
    K_native = (size_t)K;
    if (!initNative(env, alpha, alpha_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    if (!initNative(env, B, B_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offb_native = (size_t)offb;
    ldb_native = (size_t)ldb;
    beta_native = (cl_double)beta;
    if (!initNative(env, C, C_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offc_native = (size_t)offc;
    ldc_native = (size_t)ldc;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!initNative(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasZher2k(order_native, uplo_native, trans_native, N_native, K_native, alpha_native, A_native, offa_native, lda_native, B_native, offb_native, ldb_native, beta_native, C_native, offc_native, ldc_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // N is primitive
    // K is primitive
    if (!releaseNative(env, alpha_native, alpha, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // B is a read-only native pointer
    // offb is primitive
    // ldb is primitive
    // beta is primitive
    // C is a read-only native pointer
    // offc is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (!releaseNative(env, commandQueues_native, commandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Helper function to compute leading dimension and size of a matrix.
*
* @param order	matrix (in) ordering
* @param rows	number (in) of rows
* @param columns	number (in) of column
* @param elemsize	element (in) size
* @param padding	additional (in) padding on the leading dimension
* @param ld	if (out) non-NULL *ld is filled with the leading dimension
*			in elements
* @param fullsize	if (out) non-NULL *fullsize is filled with the byte size
*
* @return
*   -  clblasSuccess for success
*   -  clblasInvalidValue if:
*	 -  elementsize is 0
*	 -  row and  colums are both equal to 0
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasMatrixSizeInfoNative(JNIEnv *env, jclass cls, jint order, jlong rows, jlong columns, jlong elemsize, jlong padding, jlongArray ld, jlongArray fullsize)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // rows is primitive
    // columns is primitive
    // elemsize is primitive
    // padding is primitive
    // ld may be NULL
    // fullsize may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasMatrixSizeInfo(order=%d, rows=%ld, columns=%ld, elemsize=%ld, padding=%ld, ld=%p, fullsize=%p)\n",
        order, rows, columns, elemsize, padding, ld, fullsize);

    // Native variable declarations
    clblasOrder order_native;
    size_t rows_native = 0;
    size_t columns_native = 0;
    size_t elemsize_native = 0;
    size_t padding_native = 0;
    size_t * ld_native = nullptr;
    size_t * fullsize_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    rows_native = (size_t)rows;
    columns_native = (size_t)columns;
    elemsize_native = (size_t)elemsize;
    padding_native = (size_t)padding;
    if (!initNative(env, ld, ld_native, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, fullsize, fullsize_native, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasMatrixSizeInfo(order_native, rows_native, columns_native, elemsize_native, padding_native, ld_native, fullsize_native);

    // Write back native variable values
    // order is primitive
    // rows is primitive
    // columns is primitive
    // elemsize is primitive
    // padding is primitive
    if (!releaseNative(env, ld_native, ld, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, fullsize_native, fullsize, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Allocates matrix on device and computes ld and size.
*
* @param context	OpenCL (in) context
* @param order	Row/column (in) order.
* @param rows	number (in) of rows
* @param columns	number (in) of columns
* @param elemsize	element (in) size
* @param padding	additional (in) padding on the leading dimension
* @param ld	if (out) non-NULL *ld is filled with the leading dimension
*			in elements
* @param fullsize	if (out) non-NULL *fullsize is filled with the byte size
* @param err	Error (in) code (see  clCreateBuffer() )
*
* @return
*   - OpenCL memory object of the allocated matrix
*/
JNIEXPORT jobject JNICALL Java_org_jocl_blas_CLBLAS_clblasCreateMatrixNative(JNIEnv *env, jclass cls, jobject context, jint order, jlong rows, jlong columns, jlong elemsize, jlong padding, jlongArray ld, jlongArray fullsize, jintArray err)
{
    // Null-checks for non-primitive arguments
    if (context == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'context' is null for clblasCreateMatrix");
        return nullptr;
    }
    // order is primitive
    // rows is primitive
    // columns is primitive
    // elemsize is primitive
    // padding is primitive
    // ld may be NULL
    // fullsize may be NULL
    // err may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasCreateMatrix(context=%p, order=%d, rows=%ld, columns=%ld, elemsize=%ld, padding=%ld, ld=%p, fullsize=%p, err=%p)\n",
        context, order, rows, columns, elemsize, padding, ld, fullsize, err);

    // Native variable declarations
    cl_context context_native = nullptr;
    clblasOrder order_native;
    size_t rows_native = 0;
    size_t columns_native = 0;
    size_t elemsize_native = 0;
    size_t padding_native = 0;
    size_t * ld_native = nullptr;
    size_t * fullsize_native = nullptr;
    cl_int * err_native = nullptr;

    // Obtain native variable values
    if (!initNative(env, context, context_native, true)) return nullptr;
    order_native = (clblasOrder)order;
    rows_native = (size_t)rows;
    columns_native = (size_t)columns;
    elemsize_native = (size_t)elemsize;
    padding_native = (size_t)padding;
    if (!initNative(env, ld, ld_native, false)) return nullptr;
    if (!initNative(env, fullsize, fullsize_native, false)) return nullptr;
    if (!initNative(env, err, err_native, false)) return nullptr;

    // Native function call
    cl_mem jniResult_native = clblasCreateMatrix(context_native, order_native, rows_native, columns_native, elemsize_native, padding_native, ld_native, fullsize_native, err_native);

    // Write back native variable values
    // context is a read-only native pointer
    // order is primitive
    // rows is primitive
    // columns is primitive
    // elemsize is primitive
    // padding is primitive
    if (!releaseNative(env, ld_native, ld, true)) return nullptr;
    if (!releaseNative(env, fullsize_native, fullsize, true)) return nullptr;
    if (!releaseNative(env, err_native, err, true)) return nullptr;

    // Return the result
    return create(env, jniResult_native);
}

/**
* Allocates matrix on device with specified size and ld and computes its size.
*
* @param context	OpenCL (in) context
* @param order	Row/column (in) order.
* @param rows	number (in) of rows
* @param columns	number (in) of columns
* @param elemsize	element (in) size
* @param padding	additional (in) padding on the leading dimension
* @param ld	the (out) length of the leading dimensions. It cannot
*                      be less than  columns when the  order parameter is set to
*                       clblasRowMajor,\n or less than  rows when the
*                      parameter is set to  clblasColumnMajor.
* @param fullsize	if (out) non-NULL *fullsize is filled with the byte size
* @param err	Error (in) code (see  clCreateBuffer() )
*
* @return
*   - OpenCL memory object of the allocated matrix
*/
JNIEXPORT jobject JNICALL Java_org_jocl_blas_CLBLAS_clblasCreateMatrixWithLdNative(JNIEnv *env, jclass cls, jobject context, jint order, jlong rows, jlong columns, jlong elemsize, jlong ld, jlongArray fullsize, jintArray err)
{
    // Null-checks for non-primitive arguments
    if (context == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'context' is null for clblasCreateMatrixWithLd");
        return nullptr;
    }
    // order is primitive
    // rows is primitive
    // columns is primitive
    // elemsize is primitive
    // ld is primitive
    // fullsize may be NULL
    // err may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasCreateMatrixWithLd(context=%p, order=%d, rows=%ld, columns=%ld, elemsize=%ld, ld=%ld, fullsize=%p, err=%p)\n",
        context, order, rows, columns, elemsize, ld, fullsize, err);

    // Native variable declarations
    cl_context context_native = nullptr;
    clblasOrder order_native;
    size_t rows_native = 0;
    size_t columns_native = 0;
    size_t elemsize_native = 0;
    size_t ld_native = 0;
    size_t * fullsize_native = nullptr;
    cl_int * err_native = nullptr;

    // Obtain native variable values
    if (!initNative(env, context, context_native, true)) return nullptr;
    order_native = (clblasOrder)order;
    rows_native = (size_t)rows;
    columns_native = (size_t)columns;
    elemsize_native = (size_t)elemsize;
    ld_native = (size_t)ld;
    if (!initNative(env, fullsize, fullsize_native, false)) return nullptr;
    if (!initNative(env, err, err_native, false)) return nullptr;

    // Native function call
    cl_mem jniResult_native = clblasCreateMatrixWithLd(context_native, order_native, rows_native, columns_native, elemsize_native, ld_native, fullsize_native, err_native);

    // Write back native variable values
    // context is a read-only native pointer
    // order is primitive
    // rows is primitive
    // columns is primitive
    // elemsize is primitive
    // ld is primitive
    if (!releaseNative(env, fullsize_native, fullsize, true)) return nullptr;
    if (!releaseNative(env, err_native, err, true)) return nullptr;

    // Return the result
    return create(env, jniResult_native);
}

/**
* Allocates matrix on device and initialize from existing similar matrix.
*	  on host. See  clblasCreateMatrixBuffer().
*
* @param ld	leading (in) dimension in elements
* @param host (in) 	base address of host matrix data
* @param off_host (in) 	host matrix offset in elements
* @param ld_host (in) 	leading dimension of host matrix in elements
* @param command_queue (in) 		specifies the OpenCL queue
* @param numEventsInWaitList (in) 	specifies the number of OpenCL events
*	   	    		        to wait for
* @param eventWaitList (in) 		specifies the list of OpenCL events to
*					wait for
*
* @return
*   - OpenCL memory object of the allocated matrix
*/
JNIEXPORT jobject JNICALL Java_org_jocl_blas_CLBLAS_clblasCreateMatrixFromHostNative(JNIEnv *env, jclass cls, jobject context, jint order, jlong rows, jlong columns, jlong elemsize, jlong ld, jobject host, jlong off_host, jlong ld_host, jobject command_queue, jint numEventsInWaitList, jobjectArray eventWaitList, jintArray err)
{
    // Null-checks for non-primitive arguments
    if (context == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'context' is null for clblasCreateMatrixFromHost");
        return nullptr;
    }
    // order is primitive
    // rows is primitive
    // columns is primitive
    // elemsize is primitive
    // ld is primitive
    if (host == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'host' is null for clblasCreateMatrixFromHost");
        return nullptr;
    }
    // off_host is primitive
    // ld_host is primitive
    if (command_queue == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'command_queue' is null for clblasCreateMatrixFromHost");
        return nullptr;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // err may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasCreateMatrixFromHost(context=%p, order=%d, rows=%ld, columns=%ld, elemsize=%ld, ld=%ld, host=%p, off_host=%ld, ld_host=%ld, command_queue=%p, numEventsInWaitList=%d, eventWaitList=%p, err=%p)\n",
        context, order, rows, columns, elemsize, ld, host, off_host, ld_host, command_queue, numEventsInWaitList, eventWaitList, err);

    // Native variable declarations
    cl_context context_native = nullptr;
    clblasOrder order_native;
    size_t rows_native = 0;
    size_t columns_native = 0;
    size_t elemsize_native = 0;
    size_t ld_native = 0;
    void * host_native = nullptr;
    size_t off_host_native = 0;
    size_t ld_host_native = 0;
    cl_command_queue command_queue_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_int * err_native = nullptr;

    // Obtain native variable values
    if (!initNative(env, context, context_native, true)) return nullptr;
    order_native = (clblasOrder)order;
    rows_native = (size_t)rows;
    columns_native = (size_t)columns;
    elemsize_native = (size_t)elemsize;
    ld_native = (size_t)ld;
    PointerData *host_pointerData = initPointerData(env, host);
    if (host_pointerData == NULL)
    {
        return nullptr;
    }
    host_native = (void *)host_pointerData->pointer;
    off_host_native = (size_t)off_host;
    ld_host_native = (size_t)ld_host;
    if (!initNative(env, command_queue, command_queue_native, true)) return nullptr;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return nullptr;
    if (!initNative(env, err, err_native, false)) return nullptr;

    // Native function call
    cl_mem jniResult_native = clblasCreateMatrixFromHost(context_native, order_native, rows_native, columns_native, elemsize_native, ld_native, host_native, off_host_native, ld_host_native, command_queue_native, numEventsInWaitList_native, eventWaitList_native, err_native);

    // Write back native variable values
    // context is a read-only native pointer
    // order is primitive
    // rows is primitive
    // columns is primitive
    // elemsize is primitive
    // ld is primitive
    if (!releasePointerData(env, host_pointerData, JNI_ABORT)) return nullptr;
    // off_host is primitive
    // ld_host is primitive
    // command_queue is a read-only native pointer
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return nullptr;
    if (!releaseNative(env, err_native, err, true)) return nullptr;

    // Return the result
    return create(env, jniResult_native);
}

/**
* Copies synchronously a sub-matrix from host (A) to device (B)..
*
* @param order			matrix (in) ordering
* @param element_size		element (in) size
* @param A				specifies (in) the source matrix on the host
* @param offA			specifies (in) the offset of matrix A in
*					elements
* @param ldA			specifies (in) the leading dimension of
* 					matrix A in elements
* @param nrA			specifies (in) the number of rows of A
*					in elements
* @param ncA			specifies (in) the number of columns of A
*					in elements
* @param xA			specifies (in) the top-left x position to
* 					copy from A
* @param yA			specifies (in) the top-left y position to
* 					copy from A
* @param B				specifies (in) the destination matrix on the
*					device
* @param offB			specifies (in) the offset of matrix B in
*					elements
* @param ldB (in) 			specifies the leading dimension of
* 					matrix B in bytes
* @param nrB (in) 			specifies the number of rows of B
*					in elements
* @param ncB (in) 			specifies the number of columns of B
*					in elements
* @param xB (in) 			specifies the top-left x position to
*					copy from B
* @param yB (in) 			specifies the top-left y position to
*					copy from B
* @param nx (in) 			specifies the number of elements to
*					copy according to the x dimension (rows)
* @param ny (in) 			specifies the number of elements to
*					copy according to the y dimension
*					(columns)
* @param command_queue (in) 		specifies the OpenCL queue
* @param numEventsInWaitList (in) 	specifies the number of OpenCL events
*	   	    		        to wait for
* @param eventWaitList (in) 		specifies the list of OpenCL events to
*					wait for
*
* @return
*   -  clblasSuccess for success
*   -  clblasInvalidValue if:
*	-  xA +  offA +  nx is superior to number of columns of A
*      -  xB +  offB +  nx is superior to number of columns of B
*      -  yA +  ny is superior to number of rows of A
*      -  yB +  ny is superior to number of rows of B
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasWriteSubMatrixNative(JNIEnv *env, jclass cls, jint order, jlong element_size, jobject A, jlong offA, jlong ldA, jlong nrA, jlong ncA, jlong xA, jlong yA, jobject B, jlong offB, jlong ldB, jlong nrB, jlong ncB, jlong xB, jlong yB, jlong nx, jlong ny, jobject command_queue, jint numEventsInWaitList, jobjectArray eventWaitList)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // element_size is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasWriteSubMatrix");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // ldA is primitive
    // nrA is primitive
    // ncA is primitive
    // xA is primitive
    // yA is primitive
    if (B == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasWriteSubMatrix");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offB is primitive
    // ldB is primitive
    // nrB is primitive
    // ncB is primitive
    // xB is primitive
    // yB is primitive
    // nx is primitive
    // ny is primitive
    if (command_queue == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'command_queue' is null for clblasWriteSubMatrix");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasWriteSubMatrix(order=%d, element_size=%ld, A=%p, offA=%ld, ldA=%ld, nrA=%ld, ncA=%ld, xA=%ld, yA=%ld, B=%p, offB=%ld, ldB=%ld, nrB=%ld, ncB=%ld, xB=%ld, yB=%ld, nx=%ld, ny=%ld, command_queue=%p, numEventsInWaitList=%d, eventWaitList=%p)\n",
        order, element_size, A, offA, ldA, nrA, ncA, xA, yA, B, offB, ldB, nrB, ncB, xB, yB, nx, ny, command_queue, numEventsInWaitList, eventWaitList);

    // Native variable declarations
    clblasOrder order_native;
    size_t element_size_native = 0;
    void * A_native = nullptr;
    size_t offA_native = 0;
    size_t ldA_native = 0;
    size_t nrA_native = 0;
    size_t ncA_native = 0;
    size_t xA_native = 0;
    size_t yA_native = 0;
    cl_mem B_native = nullptr;
    size_t offB_native = 0;
    size_t ldB_native = 0;
    size_t nrB_native = 0;
    size_t ncB_native = 0;
    size_t xB_native = 0;
    size_t yB_native = 0;
    size_t nx_native = 0;
    size_t ny_native = 0;
    cl_command_queue command_queue_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    element_size_native = (size_t)element_size;
    PointerData *A_pointerData = initPointerData(env, A);
    if (A_pointerData == NULL)
    {
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    A_native = (void *)A_pointerData->pointer;
    offA_native = (size_t)offA;
    ldA_native = (size_t)ldA;
    nrA_native = (size_t)nrA;
    ncA_native = (size_t)ncA;
    xA_native = (size_t)xA;
    yA_native = (size_t)yA;
    if (!initNative(env, B, B_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offB_native = (size_t)offB;
    ldB_native = (size_t)ldB;
    nrB_native = (size_t)nrB;
    ncB_native = (size_t)ncB;
    xB_native = (size_t)xB;
    yB_native = (size_t)yB;
    nx_native = (size_t)nx;
    ny_native = (size_t)ny;
    if (!initNative(env, command_queue, command_queue_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasWriteSubMatrix(order_native, element_size_native, A_native, offA_native, ldA_native, nrA_native, ncA_native, xA_native, yA_native, B_native, offB_native, ldB_native, nrB_native, ncB_native, xB_native, yB_native, nx_native, ny_native, command_queue_native, numEventsInWaitList_native, eventWaitList_native);

    // Write back native variable values
    // order is primitive
    // element_size is primitive
    if (!releasePointerData(env, A_pointerData, JNI_ABORT)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // offA is primitive
    // ldA is primitive
    // nrA is primitive
    // ncA is primitive
    // xA is primitive
    // yA is primitive
    // B is a read-only native pointer
    // offB is primitive
    // ldB is primitive
    // nrB is primitive
    // ncB is primitive
    // xB is primitive
    // yB is primitive
    // nx is primitive
    // ny is primitive
    // command_queue is a read-only native pointer
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Copies asynchronously a sub-matrix from host (A) to device (B). .
*	  See  clblasWriteSubMatrix().
*
* @param event (out) 	Event objects per each command queue that identify a
*			particular kernel execution instance.
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasWriteSubMatrixAsyncNative(JNIEnv *env, jclass cls, jint order, jlong element_size, jobject A, jlong offA, jlong ldA, jlong nrA, jlong ncA, jlong xA, jlong yA, jobject B, jlong offB, jlong ldB, jlong nrB, jlong ncB, jlong xB, jlong yB, jlong nx, jlong ny, jobject command_queue, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray event)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // element_size is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasWriteSubMatrixAsync");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // ldA is primitive
    // nrA is primitive
    // ncA is primitive
    // xA is primitive
    // yA is primitive
    if (B == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasWriteSubMatrixAsync");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offB is primitive
    // ldB is primitive
    // nrB is primitive
    // ncB is primitive
    // xB is primitive
    // yB is primitive
    // nx is primitive
    // ny is primitive
    if (command_queue == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'command_queue' is null for clblasWriteSubMatrixAsync");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // event may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasWriteSubMatrixAsync(order=%d, element_size=%ld, A=%p, offA=%ld, ldA=%ld, nrA=%ld, ncA=%ld, xA=%ld, yA=%ld, B=%p, offB=%ld, ldB=%ld, nrB=%ld, ncB=%ld, xB=%ld, yB=%ld, nx=%ld, ny=%ld, command_queue=%p, numEventsInWaitList=%d, eventWaitList=%p, event=%p)\n",
        order, element_size, A, offA, ldA, nrA, ncA, xA, yA, B, offB, ldB, nrB, ncB, xB, yB, nx, ny, command_queue, numEventsInWaitList, eventWaitList, event);

    // Native variable declarations
    clblasOrder order_native;
    size_t element_size_native = 0;
    void * A_native = nullptr;
    size_t offA_native = 0;
    size_t ldA_native = 0;
    size_t nrA_native = 0;
    size_t ncA_native = 0;
    size_t xA_native = 0;
    size_t yA_native = 0;
    cl_mem B_native = nullptr;
    size_t offB_native = 0;
    size_t ldB_native = 0;
    size_t nrB_native = 0;
    size_t ncB_native = 0;
    size_t xB_native = 0;
    size_t yB_native = 0;
    size_t nx_native = 0;
    size_t ny_native = 0;
    cl_command_queue command_queue_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * event_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    element_size_native = (size_t)element_size;
    PointerData *A_pointerData = initPointerData(env, A);
    if (A_pointerData == NULL)
    {
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    A_native = (void *)A_pointerData->pointer;
    offA_native = (size_t)offA;
    ldA_native = (size_t)ldA;
    nrA_native = (size_t)nrA;
    ncA_native = (size_t)ncA;
    xA_native = (size_t)xA;
    yA_native = (size_t)yA;
    if (!initNative(env, B, B_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offB_native = (size_t)offB;
    ldB_native = (size_t)ldB;
    nrB_native = (size_t)nrB;
    ncB_native = (size_t)ncB;
    xB_native = (size_t)xB;
    yB_native = (size_t)yB;
    nx_native = (size_t)nx;
    ny_native = (size_t)ny;
    if (!initNative(env, command_queue, command_queue_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, event, event_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasWriteSubMatrixAsync(order_native, element_size_native, A_native, offA_native, ldA_native, nrA_native, ncA_native, xA_native, yA_native, B_native, offB_native, ldB_native, nrB_native, ncB_native, xB_native, yB_native, nx_native, ny_native, command_queue_native, numEventsInWaitList_native, eventWaitList_native, event_native);

    // Write back native variable values
    // order is primitive
    // element_size is primitive
    if (!releasePointerData(env, A_pointerData, JNI_ABORT)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // offA is primitive
    // ldA is primitive
    // nrA is primitive
    // ncA is primitive
    // xA is primitive
    // yA is primitive
    // B is a read-only native pointer
    // offB is primitive
    // ldB is primitive
    // nrB is primitive
    // ncB is primitive
    // xB is primitive
    // yB is primitive
    // nx is primitive
    // ny is primitive
    // command_queue is a read-only native pointer
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, event_native, event, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Copies a sub-matrix from device (A) to host (B). .
*	  See  clblasWriteSubMatrix().
*
* @param A		specifies (in) the source matrix on the device
* @param B		specifies (in) the destination matrix on the host
*
* @return
*   - see  clblasWriteSubMatrix()
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasReadSubMatrixNative(JNIEnv *env, jclass cls, jint order, jlong element_size, jobject A, jlong offA, jlong ldA, jlong nrA, jlong ncA, jlong xA, jlong yA, jobject B, jlong offB, jlong ldB, jlong nrB, jlong ncB, jlong xB, jlong yB, jlong nx, jlong ny, jobject command_queue, jint numEventsInWaitList, jobjectArray eventWaitList)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // element_size is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasReadSubMatrix");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // ldA is primitive
    // nrA is primitive
    // ncA is primitive
    // xA is primitive
    // yA is primitive
    if (B == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasReadSubMatrix");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offB is primitive
    // ldB is primitive
    // nrB is primitive
    // ncB is primitive
    // xB is primitive
    // yB is primitive
    // nx is primitive
    // ny is primitive
    if (command_queue == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'command_queue' is null for clblasReadSubMatrix");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasReadSubMatrix(order=%d, element_size=%ld, A=%p, offA=%ld, ldA=%ld, nrA=%ld, ncA=%ld, xA=%ld, yA=%ld, B=%p, offB=%ld, ldB=%ld, nrB=%ld, ncB=%ld, xB=%ld, yB=%ld, nx=%ld, ny=%ld, command_queue=%p, numEventsInWaitList=%d, eventWaitList=%p)\n",
        order, element_size, A, offA, ldA, nrA, ncA, xA, yA, B, offB, ldB, nrB, ncB, xB, yB, nx, ny, command_queue, numEventsInWaitList, eventWaitList);

    // Native variable declarations
    clblasOrder order_native;
    size_t element_size_native = 0;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    size_t ldA_native = 0;
    size_t nrA_native = 0;
    size_t ncA_native = 0;
    size_t xA_native = 0;
    size_t yA_native = 0;
    void * B_native = nullptr;
    size_t offB_native = 0;
    size_t ldB_native = 0;
    size_t nrB_native = 0;
    size_t ncB_native = 0;
    size_t xB_native = 0;
    size_t yB_native = 0;
    size_t nx_native = 0;
    size_t ny_native = 0;
    cl_command_queue command_queue_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    element_size_native = (size_t)element_size;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    ldA_native = (size_t)ldA;
    nrA_native = (size_t)nrA;
    ncA_native = (size_t)ncA;
    xA_native = (size_t)xA;
    yA_native = (size_t)yA;
    PointerData *B_pointerData = initPointerData(env, B);
    if (B_pointerData == NULL)
    {
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    B_native = (void *)B_pointerData->pointer;
    offB_native = (size_t)offB;
    ldB_native = (size_t)ldB;
    nrB_native = (size_t)nrB;
    ncB_native = (size_t)ncB;
    xB_native = (size_t)xB;
    yB_native = (size_t)yB;
    nx_native = (size_t)nx;
    ny_native = (size_t)ny;
    if (!initNative(env, command_queue, command_queue_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasReadSubMatrix(order_native, element_size_native, A_native, offA_native, ldA_native, nrA_native, ncA_native, xA_native, yA_native, B_native, offB_native, ldB_native, nrB_native, ncB_native, xB_native, yB_native, nx_native, ny_native, command_queue_native, numEventsInWaitList_native, eventWaitList_native);

    // Write back native variable values
    // order is primitive
    // element_size is primitive
    // A is a read-only native pointer
    // offA is primitive
    // ldA is primitive
    // nrA is primitive
    // ncA is primitive
    // xA is primitive
    // yA is primitive
    if (!releasePointerData(env, B_pointerData, 0)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // offB is primitive
    // ldB is primitive
    // nrB is primitive
    // ncB is primitive
    // xB is primitive
    // yB is primitive
    // nx is primitive
    // ny is primitive
    // command_queue is a read-only native pointer
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Copies asynchronously a sub-matrix from device (A) to host (B). .
* 	  See  clblasReadSubMatrix() and  clblasWriteSubMatrixAsync().
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasReadSubMatrixAsyncNative(JNIEnv *env, jclass cls, jint order, jlong element_size, jobject A, jlong offA, jlong ldA, jlong nrA, jlong ncA, jlong xA, jlong yA, jobject B, jlong offB, jlong ldB, jlong nrB, jlong ncB, jlong xB, jlong yB, jlong nx, jlong ny, jobject command_queue, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray event)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // element_size is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasReadSubMatrixAsync");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // ldA is primitive
    // nrA is primitive
    // ncA is primitive
    // xA is primitive
    // yA is primitive
    if (B == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasReadSubMatrixAsync");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offB is primitive
    // ldB is primitive
    // nrB is primitive
    // ncB is primitive
    // xB is primitive
    // yB is primitive
    // nx is primitive
    // ny is primitive
    if (command_queue == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'command_queue' is null for clblasReadSubMatrixAsync");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // event may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasReadSubMatrixAsync(order=%d, element_size=%ld, A=%p, offA=%ld, ldA=%ld, nrA=%ld, ncA=%ld, xA=%ld, yA=%ld, B=%p, offB=%ld, ldB=%ld, nrB=%ld, ncB=%ld, xB=%ld, yB=%ld, nx=%ld, ny=%ld, command_queue=%p, numEventsInWaitList=%d, eventWaitList=%p, event=%p)\n",
        order, element_size, A, offA, ldA, nrA, ncA, xA, yA, B, offB, ldB, nrB, ncB, xB, yB, nx, ny, command_queue, numEventsInWaitList, eventWaitList, event);

    // Native variable declarations
    clblasOrder order_native;
    size_t element_size_native = 0;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    size_t ldA_native = 0;
    size_t nrA_native = 0;
    size_t ncA_native = 0;
    size_t xA_native = 0;
    size_t yA_native = 0;
    void * B_native = nullptr;
    size_t offB_native = 0;
    size_t ldB_native = 0;
    size_t nrB_native = 0;
    size_t ncB_native = 0;
    size_t xB_native = 0;
    size_t yB_native = 0;
    size_t nx_native = 0;
    size_t ny_native = 0;
    cl_command_queue command_queue_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * event_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    element_size_native = (size_t)element_size;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    ldA_native = (size_t)ldA;
    nrA_native = (size_t)nrA;
    ncA_native = (size_t)ncA;
    xA_native = (size_t)xA;
    yA_native = (size_t)yA;
    PointerData *B_pointerData = initPointerData(env, B);
    if (B_pointerData == NULL)
    {
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    B_native = (void *)B_pointerData->pointer;
    offB_native = (size_t)offB;
    ldB_native = (size_t)ldB;
    nrB_native = (size_t)nrB;
    ncB_native = (size_t)ncB;
    xB_native = (size_t)xB;
    yB_native = (size_t)yB;
    nx_native = (size_t)nx;
    ny_native = (size_t)ny;
    if (!initNative(env, command_queue, command_queue_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, event, event_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasReadSubMatrixAsync(order_native, element_size_native, A_native, offA_native, ldA_native, nrA_native, ncA_native, xA_native, yA_native, B_native, offB_native, ldB_native, nrB_native, ncB_native, xB_native, yB_native, nx_native, ny_native, command_queue_native, numEventsInWaitList_native, eventWaitList_native, event_native);

    // Write back native variable values
    // order is primitive
    // element_size is primitive
    // A is a read-only native pointer
    // offA is primitive
    // ldA is primitive
    // nrA is primitive
    // ncA is primitive
    // xA is primitive
    // yA is primitive
    if (!releasePointerData(env, B_pointerData, 0)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // offB is primitive
    // ldB is primitive
    // nrB is primitive
    // ncB is primitive
    // xB is primitive
    // yB is primitive
    // nx is primitive
    // ny is primitive
    // command_queue is a read-only native pointer
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, event_native, event, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Copies a sub-matrix from device (A) to device (B). .
*	  See  clblasWriteSubMatrix().
*
* @param A		specifies (in) the source matrix on the device
* @param B		specifies (in) the destination matrix on the device
*
* @return
*   - see  clblasWriteSubMatrix()
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasCopySubMatrixNative(JNIEnv *env, jclass cls, jint order, jlong element_size, jobject A, jlong offA, jlong ldA, jlong nrA, jlong ncA, jlong xA, jlong yA, jobject B, jlong offB, jlong ldB, jlong nrB, jlong ncB, jlong xB, jlong yB, jlong nx, jlong ny, jobject command_queue, jint numEventsInWaitList, jobjectArray eventWaitList)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // element_size is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasCopySubMatrix");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // ldA is primitive
    // nrA is primitive
    // ncA is primitive
    // xA is primitive
    // yA is primitive
    if (B == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasCopySubMatrix");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offB is primitive
    // ldB is primitive
    // nrB is primitive
    // ncB is primitive
    // xB is primitive
    // yB is primitive
    // nx is primitive
    // ny is primitive
    if (command_queue == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'command_queue' is null for clblasCopySubMatrix");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasCopySubMatrix(order=%d, element_size=%ld, A=%p, offA=%ld, ldA=%ld, nrA=%ld, ncA=%ld, xA=%ld, yA=%ld, B=%p, offB=%ld, ldB=%ld, nrB=%ld, ncB=%ld, xB=%ld, yB=%ld, nx=%ld, ny=%ld, command_queue=%p, numEventsInWaitList=%d, eventWaitList=%p)\n",
        order, element_size, A, offA, ldA, nrA, ncA, xA, yA, B, offB, ldB, nrB, ncB, xB, yB, nx, ny, command_queue, numEventsInWaitList, eventWaitList);

    // Native variable declarations
    clblasOrder order_native;
    size_t element_size_native = 0;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    size_t ldA_native = 0;
    size_t nrA_native = 0;
    size_t ncA_native = 0;
    size_t xA_native = 0;
    size_t yA_native = 0;
    cl_mem B_native = nullptr;
    size_t offB_native = 0;
    size_t ldB_native = 0;
    size_t nrB_native = 0;
    size_t ncB_native = 0;
    size_t xB_native = 0;
    size_t yB_native = 0;
    size_t nx_native = 0;
    size_t ny_native = 0;
    cl_command_queue command_queue_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    element_size_native = (size_t)element_size;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    ldA_native = (size_t)ldA;
    nrA_native = (size_t)nrA;
    ncA_native = (size_t)ncA;
    xA_native = (size_t)xA;
    yA_native = (size_t)yA;
    if (!initNative(env, B, B_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offB_native = (size_t)offB;
    ldB_native = (size_t)ldB;
    nrB_native = (size_t)nrB;
    ncB_native = (size_t)ncB;
    xB_native = (size_t)xB;
    yB_native = (size_t)yB;
    nx_native = (size_t)nx;
    ny_native = (size_t)ny;
    if (!initNative(env, command_queue, command_queue_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasCopySubMatrix(order_native, element_size_native, A_native, offA_native, ldA_native, nrA_native, ncA_native, xA_native, yA_native, B_native, offB_native, ldB_native, nrB_native, ncB_native, xB_native, yB_native, nx_native, ny_native, command_queue_native, numEventsInWaitList_native, eventWaitList_native);

    // Write back native variable values
    // order is primitive
    // element_size is primitive
    // A is a read-only native pointer
    // offA is primitive
    // ldA is primitive
    // nrA is primitive
    // ncA is primitive
    // xA is primitive
    // yA is primitive
    // B is a read-only native pointer
    // offB is primitive
    // ldB is primitive
    // nrB is primitive
    // ncB is primitive
    // xB is primitive
    // yB is primitive
    // nx is primitive
    // ny is primitive
    // command_queue is a read-only native pointer
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Copies asynchronously a sub-matrix from device (A) to device (B). .
*        See  clblasCopySubMatrix() and  clblasWriteSubMatrixAsync().
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasCopySubMatrixAsyncNative(JNIEnv *env, jclass cls, jint order, jlong element_size, jobject A, jlong offA, jlong ldA, jlong nrA, jlong ncA, jlong xA, jlong yA, jobject B, jlong offB, jlong ldB, jlong nrB, jlong ncB, jlong xB, jlong yB, jlong nx, jlong ny, jobject command_queue, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray event)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // element_size is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasCopySubMatrixAsync");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // ldA is primitive
    // nrA is primitive
    // ncA is primitive
    // xA is primitive
    // yA is primitive
    if (B == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasCopySubMatrixAsync");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offB is primitive
    // ldB is primitive
    // nrB is primitive
    // ncB is primitive
    // xB is primitive
    // yB is primitive
    // nx is primitive
    // ny is primitive
    if (command_queue == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'command_queue' is null for clblasCopySubMatrixAsync");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // event may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasCopySubMatrixAsync(order=%d, element_size=%ld, A=%p, offA=%ld, ldA=%ld, nrA=%ld, ncA=%ld, xA=%ld, yA=%ld, B=%p, offB=%ld, ldB=%ld, nrB=%ld, ncB=%ld, xB=%ld, yB=%ld, nx=%ld, ny=%ld, command_queue=%p, numEventsInWaitList=%d, eventWaitList=%p, event=%p)\n",
        order, element_size, A, offA, ldA, nrA, ncA, xA, yA, B, offB, ldB, nrB, ncB, xB, yB, nx, ny, command_queue, numEventsInWaitList, eventWaitList, event);

    // Native variable declarations
    clblasOrder order_native;
    size_t element_size_native = 0;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    size_t ldA_native = 0;
    size_t nrA_native = 0;
    size_t ncA_native = 0;
    size_t xA_native = 0;
    size_t yA_native = 0;
    cl_mem B_native = nullptr;
    size_t offB_native = 0;
    size_t ldB_native = 0;
    size_t nrB_native = 0;
    size_t ncB_native = 0;
    size_t xB_native = 0;
    size_t yB_native = 0;
    size_t nx_native = 0;
    size_t ny_native = 0;
    cl_command_queue command_queue_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * event_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    element_size_native = (size_t)element_size;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    ldA_native = (size_t)ldA;
    nrA_native = (size_t)nrA;
    ncA_native = (size_t)ncA;
    xA_native = (size_t)xA;
    yA_native = (size_t)yA;
    if (!initNative(env, B, B_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offB_native = (size_t)offB;
    ldB_native = (size_t)ldB;
    nrB_native = (size_t)nrB;
    ncB_native = (size_t)ncB;
    xB_native = (size_t)xB;
    yB_native = (size_t)yB;
    nx_native = (size_t)nx;
    ny_native = (size_t)ny;
    if (!initNative(env, command_queue, command_queue_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, event, event_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasCopySubMatrixAsync(order_native, element_size_native, A_native, offA_native, ldA_native, nrA_native, ncA_native, xA_native, yA_native, B_native, offB_native, ldB_native, nrB_native, ncB_native, xB_native, yB_native, nx_native, ny_native, command_queue_native, numEventsInWaitList_native, eventWaitList_native, event_native);

    // Write back native variable values
    // order is primitive
    // element_size is primitive
    // A is a read-only native pointer
    // offA is primitive
    // ldA is primitive
    // nrA is primitive
    // ncA is primitive
    // xA is primitive
    // yA is primitive
    // B is a read-only native pointer
    // offB is primitive
    // ldB is primitive
    // nrB is primitive
    // ncB is primitive
    // xB is primitive
    // yB is primitive
    // nx is primitive
    // ny is primitive
    // command_queue is a read-only native pointer
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, event_native, event, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Copies synchronously a vector from host (A) to device (B). .
*	  See  clblasWriteSubMatrix().
*
* @param A		specifies (in) the source vector on the host
* @param B		specifies (in) the destination vector on the device
*
* @return
*   - see  clblasWriteSubMatrix()
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasWriteVectorNative(JNIEnv *env, jclass cls, jlong nb_elem, jlong element_size, jobject A, jlong offA, jobject B, jlong offB, jobject command_queue, jint numEventsInWaitList, jobjectArray eventWaitList)
{
    // Null-checks for non-primitive arguments
    // nb_elem is primitive
    // element_size is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasWriteVector");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    if (B == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasWriteVector");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offB is primitive
    if (command_queue == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'command_queue' is null for clblasWriteVector");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasWriteVector(nb_elem=%ld, element_size=%ld, A=%p, offA=%ld, B=%p, offB=%ld, command_queue=%p, numEventsInWaitList=%d, eventWaitList=%p)\n",
        nb_elem, element_size, A, offA, B, offB, command_queue, numEventsInWaitList, eventWaitList);

    // Native variable declarations
    size_t nb_elem_native = 0;
    size_t element_size_native = 0;
    void * A_native = nullptr;
    size_t offA_native = 0;
    cl_mem B_native = nullptr;
    size_t offB_native = 0;
    cl_command_queue command_queue_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;

    // Obtain native variable values
    nb_elem_native = (size_t)nb_elem;
    element_size_native = (size_t)element_size;
    PointerData *A_pointerData = initPointerData(env, A);
    if (A_pointerData == NULL)
    {
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    A_native = (void *)A_pointerData->pointer;
    offA_native = (size_t)offA;
    if (!initNative(env, B, B_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offB_native = (size_t)offB;
    if (!initNative(env, command_queue, command_queue_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasWriteVector(nb_elem_native, element_size_native, A_native, offA_native, B_native, offB_native, command_queue_native, numEventsInWaitList_native, eventWaitList_native);

    // Write back native variable values
    // nb_elem is primitive
    // element_size is primitive
    if (!releasePointerData(env, A_pointerData, JNI_ABORT)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // offA is primitive
    // B is a read-only native pointer
    // offB is primitive
    // command_queue is a read-only native pointer
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Copies asynchronously a vector from host (A) to device (B). .
* 	  See  clblasWriteVector() and  clblasWriteSubMatrixAsync().
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasWriteVectorAsyncNative(JNIEnv *env, jclass cls, jlong nb_elem, jlong element_size, jobject A, jlong offA, jobject B, jlong offB, jobject command_queue, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // nb_elem is primitive
    // element_size is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasWriteVectorAsync");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    if (B == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasWriteVectorAsync");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offB is primitive
    if (command_queue == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'command_queue' is null for clblasWriteVectorAsync");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasWriteVectorAsync(nb_elem=%ld, element_size=%ld, A=%p, offA=%ld, B=%p, offB=%ld, command_queue=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        nb_elem, element_size, A, offA, B, offB, command_queue, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t nb_elem_native = 0;
    size_t element_size_native = 0;
    void * A_native = nullptr;
    size_t offA_native = 0;
    cl_mem B_native = nullptr;
    size_t offB_native = 0;
    cl_command_queue command_queue_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    nb_elem_native = (size_t)nb_elem;
    element_size_native = (size_t)element_size;
    PointerData *A_pointerData = initPointerData(env, A);
    if (A_pointerData == NULL)
    {
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    A_native = (void *)A_pointerData->pointer;
    offA_native = (size_t)offA;
    if (!initNative(env, B, B_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offB_native = (size_t)offB;
    if (!initNative(env, command_queue, command_queue_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasWriteVectorAsync(nb_elem_native, element_size_native, A_native, offA_native, B_native, offB_native, command_queue_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // nb_elem is primitive
    // element_size is primitive
    if (!releasePointerData(env, A_pointerData, JNI_ABORT)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // offA is primitive
    // B is a read-only native pointer
    // offB is primitive
    // command_queue is a read-only native pointer
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Copies synchronously a vector from device (A) to host (B). .
*	  See  clblasReadSubMatrix().
*
* @param A		specifies (in) the source vector on the device
* @param B		specifies (in) the destination vector on the host
*
* @return
*   - see  clblasReadSubMatrix()
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasReadVectorNative(JNIEnv *env, jclass cls, jlong nb_elem, jlong element_size, jobject A, jlong offA, jobject B, jlong offB, jobject command_queue, jint numEventsInWaitList, jobjectArray eventWaitList)
{
    // Null-checks for non-primitive arguments
    // nb_elem is primitive
    // element_size is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasReadVector");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    if (B == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasReadVector");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offB is primitive
    if (command_queue == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'command_queue' is null for clblasReadVector");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasReadVector(nb_elem=%ld, element_size=%ld, A=%p, offA=%ld, B=%p, offB=%ld, command_queue=%p, numEventsInWaitList=%d, eventWaitList=%p)\n",
        nb_elem, element_size, A, offA, B, offB, command_queue, numEventsInWaitList, eventWaitList);

    // Native variable declarations
    size_t nb_elem_native = 0;
    size_t element_size_native = 0;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    void * B_native = nullptr;
    size_t offB_native = 0;
    cl_command_queue command_queue_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;

    // Obtain native variable values
    nb_elem_native = (size_t)nb_elem;
    element_size_native = (size_t)element_size;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    PointerData *B_pointerData = initPointerData(env, B);
    if (B_pointerData == NULL)
    {
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    B_native = (void *)B_pointerData->pointer;
    offB_native = (size_t)offB;
    if (!initNative(env, command_queue, command_queue_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasReadVector(nb_elem_native, element_size_native, A_native, offA_native, B_native, offB_native, command_queue_native, numEventsInWaitList_native, eventWaitList_native);

    // Write back native variable values
    // nb_elem is primitive
    // element_size is primitive
    // A is a read-only native pointer
    // offA is primitive
    if (!releasePointerData(env, B_pointerData, 0)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // offB is primitive
    // command_queue is a read-only native pointer
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Copies asynchronously a vector from device (A) to host (B). .
* 	  See  clblasReadVector() and  clblasWriteSubMatrixAsync().
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasReadVectorAsyncNative(JNIEnv *env, jclass cls, jlong nb_elem, jlong element_size, jobject A, jlong offA, jobject B, jlong offB, jobject command_queue, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // nb_elem is primitive
    // element_size is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasReadVectorAsync");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    if (B == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasReadVectorAsync");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offB is primitive
    if (command_queue == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'command_queue' is null for clblasReadVectorAsync");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasReadVectorAsync(nb_elem=%ld, element_size=%ld, A=%p, offA=%ld, B=%p, offB=%ld, command_queue=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        nb_elem, element_size, A, offA, B, offB, command_queue, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t nb_elem_native = 0;
    size_t element_size_native = 0;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    void * B_native = nullptr;
    size_t offB_native = 0;
    cl_command_queue command_queue_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    nb_elem_native = (size_t)nb_elem;
    element_size_native = (size_t)element_size;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    PointerData *B_pointerData = initPointerData(env, B);
    if (B_pointerData == NULL)
    {
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    B_native = (void *)B_pointerData->pointer;
    offB_native = (size_t)offB;
    if (!initNative(env, command_queue, command_queue_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasReadVectorAsync(nb_elem_native, element_size_native, A_native, offA_native, B_native, offB_native, command_queue_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // nb_elem is primitive
    // element_size is primitive
    // A is a read-only native pointer
    // offA is primitive
    if (!releasePointerData(env, B_pointerData, 0)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // offB is primitive
    // command_queue is a read-only native pointer
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Copies synchronously a vector from device (A) to device (B). .
*	  See  clblasCopySubMatrix().
*
* @param A		specifies (in) the source vector on the device
* @param B		specifies (in) the destination vector on the device
*
* @return
*   - see  clblasCopySubMatrix()
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasCopyVectorNative(JNIEnv *env, jclass cls, jlong nb_elem, jlong element_size, jobject A, jlong offA, jobject B, jlong offB, jobject command_queue, jint numEventsInWaitList, jobjectArray eventWaitList)
{
    // Null-checks for non-primitive arguments
    // nb_elem is primitive
    // element_size is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasCopyVector");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    if (B == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasCopyVector");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offB is primitive
    if (command_queue == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'command_queue' is null for clblasCopyVector");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasCopyVector(nb_elem=%ld, element_size=%ld, A=%p, offA=%ld, B=%p, offB=%ld, command_queue=%p, numEventsInWaitList=%d, eventWaitList=%p)\n",
        nb_elem, element_size, A, offA, B, offB, command_queue, numEventsInWaitList, eventWaitList);

    // Native variable declarations
    size_t nb_elem_native = 0;
    size_t element_size_native = 0;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    cl_mem B_native = nullptr;
    size_t offB_native = 0;
    cl_command_queue command_queue_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;

    // Obtain native variable values
    nb_elem_native = (size_t)nb_elem;
    element_size_native = (size_t)element_size;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    if (!initNative(env, B, B_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offB_native = (size_t)offB;
    if (!initNative(env, command_queue, command_queue_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasCopyVector(nb_elem_native, element_size_native, A_native, offA_native, B_native, offB_native, command_queue_native, numEventsInWaitList_native, eventWaitList_native);

    // Write back native variable values
    // nb_elem is primitive
    // element_size is primitive
    // A is a read-only native pointer
    // offA is primitive
    // B is a read-only native pointer
    // offB is primitive
    // command_queue is a read-only native pointer
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Copies asynchronously a vector from device (A) to device (B). .
* 	  See  clblasCopyVector() and  clblasWriteSubMatrixAsync().
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasCopyVectorAsyncNative(JNIEnv *env, jclass cls, jlong nb_elem, jlong element_size, jobject A, jlong offA, jobject B, jlong offB, jobject command_queue, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // nb_elem is primitive
    // element_size is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasCopyVectorAsync");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    if (B == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasCopyVectorAsync");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offB is primitive
    if (command_queue == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'command_queue' is null for clblasCopyVectorAsync");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasCopyVectorAsync(nb_elem=%ld, element_size=%ld, A=%p, offA=%ld, B=%p, offB=%ld, command_queue=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        nb_elem, element_size, A, offA, B, offB, command_queue, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t nb_elem_native = 0;
    size_t element_size_native = 0;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    cl_mem B_native = nullptr;
    size_t offB_native = 0;
    cl_command_queue command_queue_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    nb_elem_native = (size_t)nb_elem;
    element_size_native = (size_t)element_size;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    if (!initNative(env, B, B_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offB_native = (size_t)offB;
    if (!initNative(env, command_queue, command_queue_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasCopyVectorAsync(nb_elem_native, element_size_native, A_native, offA_native, B_native, offB_native, command_queue_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // nb_elem is primitive
    // element_size is primitive
    // A is a read-only native pointer
    // offA is primitive
    // B is a read-only native pointer
    // offB is primitive
    // command_queue is a read-only native pointer
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Copies synchronously a whole matrix from host (A) to device (B). .
*        See  clblasWriteSubMatrix().
*
* @param A		specifies (in) the source matrix on the host
* @param B		specifies (in) the destination matrix on the device
*
* @return
*   - see  clblasWriteSubMatrix()
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasWriteMatrixNative(JNIEnv *env, jclass cls, jint order, jlong sx, jlong sy, jlong element_size, jobject A, jlong offA, jlong ldA, jobject B, jlong offB, jlong ldB, jobject command_queue, jint numEventsInWaitList, jobjectArray eventWaitList)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // sx is primitive
    // sy is primitive
    // element_size is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasWriteMatrix");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // ldA is primitive
    if (B == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasWriteMatrix");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offB is primitive
    // ldB is primitive
    if (command_queue == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'command_queue' is null for clblasWriteMatrix");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasWriteMatrix(order=%d, sx=%ld, sy=%ld, element_size=%ld, A=%p, offA=%ld, ldA=%ld, B=%p, offB=%ld, ldB=%ld, command_queue=%p, numEventsInWaitList=%d, eventWaitList=%p)\n",
        order, sx, sy, element_size, A, offA, ldA, B, offB, ldB, command_queue, numEventsInWaitList, eventWaitList);

    // Native variable declarations
    clblasOrder order_native;
    size_t sx_native = 0;
    size_t sy_native = 0;
    size_t element_size_native = 0;
    void * A_native = nullptr;
    size_t offA_native = 0;
    size_t ldA_native = 0;
    cl_mem B_native = nullptr;
    size_t offB_native = 0;
    size_t ldB_native = 0;
    cl_command_queue command_queue_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    sx_native = (size_t)sx;
    sy_native = (size_t)sy;
    element_size_native = (size_t)element_size;
    PointerData *A_pointerData = initPointerData(env, A);
    if (A_pointerData == NULL)
    {
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    A_native = (void *)A_pointerData->pointer;
    offA_native = (size_t)offA;
    ldA_native = (size_t)ldA;
    if (!initNative(env, B, B_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offB_native = (size_t)offB;
    ldB_native = (size_t)ldB;
    if (!initNative(env, command_queue, command_queue_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasWriteMatrix(order_native, sx_native, sy_native, element_size_native, A_native, offA_native, ldA_native, B_native, offB_native, ldB_native, command_queue_native, numEventsInWaitList_native, eventWaitList_native);

    // Write back native variable values
    // order is primitive
    // sx is primitive
    // sy is primitive
    // element_size is primitive
    if (!releasePointerData(env, A_pointerData, JNI_ABORT)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // offA is primitive
    // ldA is primitive
    // B is a read-only native pointer
    // offB is primitive
    // ldB is primitive
    // command_queue is a read-only native pointer
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Copies asynchronously a vector from host (A) to device (B). .
*        See  clblasWriteMatrix() and  clblasWriteSubMatrixAsync().
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasWriteMatrixAsyncNative(JNIEnv *env, jclass cls, jint order, jlong sx, jlong sy, jlong element_size, jobject A, jlong offA, jlong ldA, jobject B, jlong offB, jlong ldB, jobject command_queue, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // sx is primitive
    // sy is primitive
    // element_size is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasWriteMatrixAsync");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // ldA is primitive
    if (B == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasWriteMatrixAsync");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offB is primitive
    // ldB is primitive
    if (command_queue == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'command_queue' is null for clblasWriteMatrixAsync");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasWriteMatrixAsync(order=%d, sx=%ld, sy=%ld, element_size=%ld, A=%p, offA=%ld, ldA=%ld, B=%p, offB=%ld, ldB=%ld, command_queue=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, sx, sy, element_size, A, offA, ldA, B, offB, ldB, command_queue, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    size_t sx_native = 0;
    size_t sy_native = 0;
    size_t element_size_native = 0;
    void * A_native = nullptr;
    size_t offA_native = 0;
    size_t ldA_native = 0;
    cl_mem B_native = nullptr;
    size_t offB_native = 0;
    size_t ldB_native = 0;
    cl_command_queue command_queue_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    sx_native = (size_t)sx;
    sy_native = (size_t)sy;
    element_size_native = (size_t)element_size;
    PointerData *A_pointerData = initPointerData(env, A);
    if (A_pointerData == NULL)
    {
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    A_native = (void *)A_pointerData->pointer;
    offA_native = (size_t)offA;
    ldA_native = (size_t)ldA;
    if (!initNative(env, B, B_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offB_native = (size_t)offB;
    ldB_native = (size_t)ldB;
    if (!initNative(env, command_queue, command_queue_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasWriteMatrixAsync(order_native, sx_native, sy_native, element_size_native, A_native, offA_native, ldA_native, B_native, offB_native, ldB_native, command_queue_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // sx is primitive
    // sy is primitive
    // element_size is primitive
    if (!releasePointerData(env, A_pointerData, JNI_ABORT)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // offA is primitive
    // ldA is primitive
    // B is a read-only native pointer
    // offB is primitive
    // ldB is primitive
    // command_queue is a read-only native pointer
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Copies synchronously a whole matrix from device (A) to host (B). .
*	  See  clblasReadSubMatrix().
*
* @param A		specifies (in) the source vector on the device
* @param B		specifies (in) the destination vector on the host
*
* @return
*   - see  clblasReadSubMatrix()
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasReadMatrixNative(JNIEnv *env, jclass cls, jint order, jlong sx, jlong sy, jlong element_size, jobject A, jlong offA, jlong ldA, jobject B, jlong offB, jlong ldB, jobject command_queue, jint numEventsInWaitList, jobjectArray eventWaitList)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // sx is primitive
    // sy is primitive
    // element_size is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasReadMatrix");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // ldA is primitive
    if (B == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasReadMatrix");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offB is primitive
    // ldB is primitive
    if (command_queue == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'command_queue' is null for clblasReadMatrix");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasReadMatrix(order=%d, sx=%ld, sy=%ld, element_size=%ld, A=%p, offA=%ld, ldA=%ld, B=%p, offB=%ld, ldB=%ld, command_queue=%p, numEventsInWaitList=%d, eventWaitList=%p)\n",
        order, sx, sy, element_size, A, offA, ldA, B, offB, ldB, command_queue, numEventsInWaitList, eventWaitList);

    // Native variable declarations
    clblasOrder order_native;
    size_t sx_native = 0;
    size_t sy_native = 0;
    size_t element_size_native = 0;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    size_t ldA_native = 0;
    void * B_native = nullptr;
    size_t offB_native = 0;
    size_t ldB_native = 0;
    cl_command_queue command_queue_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    sx_native = (size_t)sx;
    sy_native = (size_t)sy;
    element_size_native = (size_t)element_size;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    ldA_native = (size_t)ldA;
    PointerData *B_pointerData = initPointerData(env, B);
    if (B_pointerData == NULL)
    {
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    B_native = (void *)B_pointerData->pointer;
    offB_native = (size_t)offB;
    ldB_native = (size_t)ldB;
    if (!initNative(env, command_queue, command_queue_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasReadMatrix(order_native, sx_native, sy_native, element_size_native, A_native, offA_native, ldA_native, B_native, offB_native, ldB_native, command_queue_native, numEventsInWaitList_native, eventWaitList_native);

    // Write back native variable values
    // order is primitive
    // sx is primitive
    // sy is primitive
    // element_size is primitive
    // A is a read-only native pointer
    // offA is primitive
    // ldA is primitive
    if (!releasePointerData(env, B_pointerData, 0)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // offB is primitive
    // ldB is primitive
    // command_queue is a read-only native pointer
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Copies asynchronously a vector from device (A) to host (B). .
*        See  clblasReadMatrix() and  clblasWriteSubMatrixAsync().
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasReadMatrixAsyncNative(JNIEnv *env, jclass cls, jint order, jlong sx, jlong sy, jlong element_size, jobject A, jlong offA, jlong ldA, jobject B, jlong offB, jlong ldB, jobject command_queue, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // sx is primitive
    // sy is primitive
    // element_size is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasReadMatrixAsync");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // ldA is primitive
    if (B == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasReadMatrixAsync");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offB is primitive
    // ldB is primitive
    if (command_queue == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'command_queue' is null for clblasReadMatrixAsync");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasReadMatrixAsync(order=%d, sx=%ld, sy=%ld, element_size=%ld, A=%p, offA=%ld, ldA=%ld, B=%p, offB=%ld, ldB=%ld, command_queue=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, sx, sy, element_size, A, offA, ldA, B, offB, ldB, command_queue, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    size_t sx_native = 0;
    size_t sy_native = 0;
    size_t element_size_native = 0;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    size_t ldA_native = 0;
    void * B_native = nullptr;
    size_t offB_native = 0;
    size_t ldB_native = 0;
    cl_command_queue command_queue_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    sx_native = (size_t)sx;
    sy_native = (size_t)sy;
    element_size_native = (size_t)element_size;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    ldA_native = (size_t)ldA;
    PointerData *B_pointerData = initPointerData(env, B);
    if (B_pointerData == NULL)
    {
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    B_native = (void *)B_pointerData->pointer;
    offB_native = (size_t)offB;
    ldB_native = (size_t)ldB;
    if (!initNative(env, command_queue, command_queue_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasReadMatrixAsync(order_native, sx_native, sy_native, element_size_native, A_native, offA_native, ldA_native, B_native, offB_native, ldB_native, command_queue_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // sx is primitive
    // sy is primitive
    // element_size is primitive
    // A is a read-only native pointer
    // offA is primitive
    // ldA is primitive
    if (!releasePointerData(env, B_pointerData, 0)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // offB is primitive
    // ldB is primitive
    // command_queue is a read-only native pointer
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Copies synchronously a whole matrix from device (A) to device (B). .
*	  See  clblasCopySubMatrix().
*
* @param A		specifies (in) the source matrix on the device
* @param B		specifies (in) the destination matrix on the device
*
* @return
*   - see  clblasCopySubMatrix()
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasCopyMatrixNative(JNIEnv *env, jclass cls, jint order, jlong sx, jlong sy, jlong element_size, jobject A, jlong offA, jlong ldA, jobject B, jlong offB, jlong ldB, jobject command_queue, jint numEventsInWaitList, jobjectArray eventWaitList)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // sx is primitive
    // sy is primitive
    // element_size is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasCopyMatrix");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // ldA is primitive
    if (B == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasCopyMatrix");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offB is primitive
    // ldB is primitive
    if (command_queue == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'command_queue' is null for clblasCopyMatrix");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasCopyMatrix(order=%d, sx=%ld, sy=%ld, element_size=%ld, A=%p, offA=%ld, ldA=%ld, B=%p, offB=%ld, ldB=%ld, command_queue=%p, numEventsInWaitList=%d, eventWaitList=%p)\n",
        order, sx, sy, element_size, A, offA, ldA, B, offB, ldB, command_queue, numEventsInWaitList, eventWaitList);

    // Native variable declarations
    clblasOrder order_native;
    size_t sx_native = 0;
    size_t sy_native = 0;
    size_t element_size_native = 0;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    size_t ldA_native = 0;
    cl_mem B_native = nullptr;
    size_t offB_native = 0;
    size_t ldB_native = 0;
    cl_command_queue command_queue_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    sx_native = (size_t)sx;
    sy_native = (size_t)sy;
    element_size_native = (size_t)element_size;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    ldA_native = (size_t)ldA;
    if (!initNative(env, B, B_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offB_native = (size_t)offB;
    ldB_native = (size_t)ldB;
    if (!initNative(env, command_queue, command_queue_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasCopyMatrix(order_native, sx_native, sy_native, element_size_native, A_native, offA_native, ldA_native, B_native, offB_native, ldB_native, command_queue_native, numEventsInWaitList_native, eventWaitList_native);

    // Write back native variable values
    // order is primitive
    // sx is primitive
    // sy is primitive
    // element_size is primitive
    // A is a read-only native pointer
    // offA is primitive
    // ldA is primitive
    // B is a read-only native pointer
    // offB is primitive
    // ldB is primitive
    // command_queue is a read-only native pointer
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Copies asynchronously a vector from device (A) to device (B). .
*        See  clblasCopyMatrix() and  clblasWriteSubMatrixAsync().
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasCopyMatrixAsyncNative(JNIEnv *env, jclass cls, jint order, jlong sx, jlong sy, jlong element_size, jobject A, jlong offA, jlong ldA, jobject B, jlong offB, jlong ldB, jobject command_queue, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // sx is primitive
    // sy is primitive
    // element_size is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasCopyMatrixAsync");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // ldA is primitive
    if (B == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasCopyMatrixAsync");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offB is primitive
    // ldB is primitive
    if (command_queue == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'command_queue' is null for clblasCopyMatrixAsync");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasCopyMatrixAsync(order=%d, sx=%ld, sy=%ld, element_size=%ld, A=%p, offA=%ld, ldA=%ld, B=%p, offB=%ld, ldB=%ld, command_queue=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, sx, sy, element_size, A, offA, ldA, B, offB, ldB, command_queue, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    size_t sx_native = 0;
    size_t sy_native = 0;
    size_t element_size_native = 0;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    size_t ldA_native = 0;
    cl_mem B_native = nullptr;
    size_t offB_native = 0;
    size_t ldB_native = 0;
    cl_command_queue command_queue_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * events_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    sx_native = (size_t)sx;
    sy_native = (size_t)sy;
    element_size_native = (size_t)element_size;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    ldA_native = (size_t)ldA;
    if (!initNative(env, B, B_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offB_native = (size_t)offB;
    ldB_native = (size_t)ldB;
    if (!initNative(env, command_queue, command_queue_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, events, events_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasCopyMatrixAsync(order_native, sx_native, sy_native, element_size_native, A_native, offA_native, ldA_native, B_native, offB_native, ldB_native, command_queue_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // sx is primitive
    // sy is primitive
    // element_size is primitive
    // A is a read-only native pointer
    // offA is primitive
    // ldA is primitive
    // B is a read-only native pointer
    // offB is primitive
    // ldB is primitive
    // command_queue is a read-only native pointer
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, events_native, events, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Fill synchronously a vector with a pattern of a size element_size_bytes.
*
* @param nb_elem (in)             specifies the number of element in buffer A
* @param element_size (in)        specifies the size of one element of A. Supported sizes correspond
*                                element size used in clBLAS (1,2,4,8,16)
* @param A		 (in)          specifies the source vector on the device
* @param offA (in)                specifies the offset of matrix A in
*				  elements
* @param pattern (in)             specifies the host address of the pattern to fill with (element_size_bytes)
* @param command_queue (in) 	  specifies the OpenCL queue
* @param numEventsInWaitList (in) specifies the number of OpenCL events
*	   	    		  to wait for
* @param eventWaitList (in) 	  specifies the list of OpenCL events to
*				  wait for
* @return
*   - see  clblasWriteSubMatrix()
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasFillVectorNative(JNIEnv *env, jclass cls, jlong nb_elem, jlong element_size, jobject A, jlong offA, jobject host, jobject command_queue, jint numEventsInWaitList, jobjectArray eventWaitList)
{
    // Null-checks for non-primitive arguments
    // nb_elem is primitive
    // element_size is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasFillVector");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    if (host == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'host' is null for clblasFillVector");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (command_queue == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'command_queue' is null for clblasFillVector");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasFillVector(nb_elem=%ld, element_size=%ld, A=%p, offA=%ld, host=%p, command_queue=%p, numEventsInWaitList=%d, eventWaitList=%p)\n",
        nb_elem, element_size, A, offA, host, command_queue, numEventsInWaitList, eventWaitList);

    // Native variable declarations
    size_t nb_elem_native = 0;
    size_t element_size_native = 0;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    void * host_native = nullptr;
    cl_command_queue command_queue_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;

    // Obtain native variable values
    nb_elem_native = (size_t)nb_elem;
    element_size_native = (size_t)element_size;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    PointerData *host_pointerData = initPointerData(env, host);
    if (host_pointerData == NULL)
    {
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    host_native = (void *)host_pointerData->pointer;
    if (!initNative(env, command_queue, command_queue_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasFillVector(nb_elem_native, element_size_native, A_native, offA_native, host_native, command_queue_native, numEventsInWaitList_native, eventWaitList_native);

    // Write back native variable values
    // nb_elem is primitive
    // element_size is primitive
    // A is a read-only native pointer
    // offA is primitive
    if (!releasePointerData(env, host_pointerData, JNI_ABORT)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // command_queue is a read-only native pointer
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Fill asynchronously a vector with a pattern of a size element_size_bytes.
*	  See  clblasFillVector().
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasFillVectorAsyncNative(JNIEnv *env, jclass cls, jlong nb_elem, jlong element_size, jobject A, jlong offA, jobject pattern, jobject command_queue, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray event)
{
    // Null-checks for non-primitive arguments
    // nb_elem is primitive
    // element_size is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasFillVectorAsync");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    if (pattern == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'pattern' is null for clblasFillVectorAsync");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (command_queue == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'command_queue' is null for clblasFillVectorAsync");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // event may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasFillVectorAsync(nb_elem=%ld, element_size=%ld, A=%p, offA=%ld, pattern=%p, command_queue=%p, numEventsInWaitList=%d, eventWaitList=%p, event=%p)\n",
        nb_elem, element_size, A, offA, pattern, command_queue, numEventsInWaitList, eventWaitList, event);

    // Native variable declarations
    size_t nb_elem_native = 0;
    size_t element_size_native = 0;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    void * pattern_native = nullptr;
    cl_command_queue command_queue_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * event_native = nullptr;

    // Obtain native variable values
    nb_elem_native = (size_t)nb_elem;
    element_size_native = (size_t)element_size;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    PointerData *pattern_pointerData = initPointerData(env, pattern);
    if (pattern_pointerData == NULL)
    {
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    pattern_native = (void *)pattern_pointerData->pointer;
    if (!initNative(env, command_queue, command_queue_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, event, event_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasFillVectorAsync(nb_elem_native, element_size_native, A_native, offA_native, pattern_native, command_queue_native, numEventsInWaitList_native, eventWaitList_native, event_native);

    // Write back native variable values
    // nb_elem is primitive
    // element_size is primitive
    // A is a read-only native pointer
    // offA is primitive
    if (!releasePointerData(env, pattern_pointerData, JNI_ABORT)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // command_queue is a read-only native pointer
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, event_native, event, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Fill synchronously a matrix with a pattern of a size element_size_bytes.
*
* @param order (in)               specifies the matrix order
* @param element_size (in)        specifies the size of one element of A. Supported sizes correspond
*                                element size used in clBLAS (1,2,4,8,16)
* @param A		 (in)          specifies the source vector on the device
* @param offA (in)                specifies the offset of matrix A in
* @param ldA (in)                 specifies the leading dimension of A
* @param nrA (in)                 specifies the number of row in A
* @param ncA (in)                 specifies the number of column in A
* @param pattern (in)             specifies the host address of the pattern to fill with (element_size_bytes)
* @param command_queue (in) 	  specifies the OpenCL queue
* @param numEventsInWaitList (in) specifies the number of OpenCL events to wait for
* @param eventWaitList (in) 	  specifies the list of OpenCL events to wait for
* @return
*   - see  clblasWriteSubMatrix()
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasFillMatrixNative(JNIEnv *env, jclass cls, jint order, jlong element_size, jobject A, jlong offA, jlong ldA, jlong nrA, jlong ncA, jobject pattern, jobject command_queue, jint numEventsInWaitList, jobjectArray eventWaitList)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // element_size is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasFillMatrix");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // ldA is primitive
    // nrA is primitive
    // ncA is primitive
    if (pattern == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'pattern' is null for clblasFillMatrix");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (command_queue == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'command_queue' is null for clblasFillMatrix");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasFillMatrix(order=%d, element_size=%ld, A=%p, offA=%ld, ldA=%ld, nrA=%ld, ncA=%ld, pattern=%p, command_queue=%p, numEventsInWaitList=%d, eventWaitList=%p)\n",
        order, element_size, A, offA, ldA, nrA, ncA, pattern, command_queue, numEventsInWaitList, eventWaitList);

    // Native variable declarations
    clblasOrder order_native;
    size_t element_size_native = 0;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    size_t ldA_native = 0;
    size_t nrA_native = 0;
    size_t ncA_native = 0;
    void * pattern_native = nullptr;
    cl_command_queue command_queue_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    element_size_native = (size_t)element_size;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    ldA_native = (size_t)ldA;
    nrA_native = (size_t)nrA;
    ncA_native = (size_t)ncA;
    PointerData *pattern_pointerData = initPointerData(env, pattern);
    if (pattern_pointerData == NULL)
    {
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    pattern_native = (void *)pattern_pointerData->pointer;
    if (!initNative(env, command_queue, command_queue_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasFillMatrix(order_native, element_size_native, A_native, offA_native, ldA_native, nrA_native, ncA_native, pattern_native, command_queue_native, numEventsInWaitList_native, eventWaitList_native);

    // Write back native variable values
    // order is primitive
    // element_size is primitive
    // A is a read-only native pointer
    // offA is primitive
    // ldA is primitive
    // nrA is primitive
    // ncA is primitive
    if (!releasePointerData(env, pattern_pointerData, JNI_ABORT)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // command_queue is a read-only native pointer
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Partially fill a sub-matrix with a pattern of a size element_size_bytes .
*
*
* @param order (in)               specifies the matrix order
* @param element_size (in)        specifies the size of one element of A. Supported values
*                                are to element sizes used in clBLAS - that is 1, 2, 4, 8 or 16
* @param offA (in)                specifies the offset of matrix A in elements
* @param ldA (in)                 specifies the leading dimension of A in elements
* @param nrA		 (in)  specifies the number of rows of A
*				  in elements
* @param ncA		 (in)  specifies the number of columns of A
*				  in elements
* @param xA		 (in)  specifies the top-left x position to
* 				  copy from A
* @param yA		 (in)  specifies the top-left y position to
* 				  copy from A
* @param nx (in) 		  specifies the number of elements to
*				  copy according to the x dimension (rows)
* @param ny (in) 		  specifies the number of elements to
*				  copy according to the y dimension
*				  (columns)
* @param pattern (in)             specifies the host address of the pattern to fill with (element_size_bytes)
* @param command_queue (in) 	  specifies the OpenCL queue
* @param numEventsInWaitList (in) specifies the number of OpenCL events to wait for
* @param eventWaitList (in) 	  specifies the list of OpenCL events to wait for
* @return
*   - see  clblasWriteSubMatrix()
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasFillSubMatrixNative(JNIEnv *env, jclass cls, jint order, jlong element_size, jobject A, jlong offA, jlong ldA, jlong nrA, jlong ncA, jlong xA, jlong yA, jlong nx, jlong ny, jobject pattern, jobject command_queue, jint numEventsInWaitList, jobjectArray eventWaitList)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // element_size is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasFillSubMatrix");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // ldA is primitive
    // nrA is primitive
    // ncA is primitive
    // xA is primitive
    // yA is primitive
    // nx is primitive
    // ny is primitive
    if (pattern == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'pattern' is null for clblasFillSubMatrix");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (command_queue == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'command_queue' is null for clblasFillSubMatrix");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasFillSubMatrix(order=%d, element_size=%ld, A=%p, offA=%ld, ldA=%ld, nrA=%ld, ncA=%ld, xA=%ld, yA=%ld, nx=%ld, ny=%ld, pattern=%p, command_queue=%p, numEventsInWaitList=%d, eventWaitList=%p)\n",
        order, element_size, A, offA, ldA, nrA, ncA, xA, yA, nx, ny, pattern, command_queue, numEventsInWaitList, eventWaitList);

    // Native variable declarations
    clblasOrder order_native;
    size_t element_size_native = 0;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    size_t ldA_native = 0;
    size_t nrA_native = 0;
    size_t ncA_native = 0;
    size_t xA_native = 0;
    size_t yA_native = 0;
    size_t nx_native = 0;
    size_t ny_native = 0;
    void * pattern_native = nullptr;
    cl_command_queue command_queue_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    element_size_native = (size_t)element_size;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    ldA_native = (size_t)ldA;
    nrA_native = (size_t)nrA;
    ncA_native = (size_t)ncA;
    xA_native = (size_t)xA;
    yA_native = (size_t)yA;
    nx_native = (size_t)nx;
    ny_native = (size_t)ny;
    PointerData *pattern_pointerData = initPointerData(env, pattern);
    if (pattern_pointerData == NULL)
    {
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    pattern_native = (void *)pattern_pointerData->pointer;
    if (!initNative(env, command_queue, command_queue_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasFillSubMatrix(order_native, element_size_native, A_native, offA_native, ldA_native, nrA_native, ncA_native, xA_native, yA_native, nx_native, ny_native, pattern_native, command_queue_native, numEventsInWaitList_native, eventWaitList_native);

    // Write back native variable values
    // order is primitive
    // element_size is primitive
    // A is a read-only native pointer
    // offA is primitive
    // ldA is primitive
    // nrA is primitive
    // ncA is primitive
    // xA is primitive
    // yA is primitive
    // nx is primitive
    // ny is primitive
    if (!releasePointerData(env, pattern_pointerData, JNI_ABORT)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // command_queue is a read-only native pointer
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* Asynchronous asynchronously fill a sub-matrix with a pattern of a size element_size_bytes  .
*	  See  clblasFillSubMatrix().
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasFillSubMatrixAsyncNative(JNIEnv *env, jclass cls, jint order, jlong element_size, jobject A, jlong offA, jlong ldA, jlong sxA, jlong syA, jint xA, jint yA, jlong nx, jlong ny, jobject host, jobject command_queue, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray event)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // element_size is primitive
    if (A == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasFillSubMatrixAsync");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // ldA is primitive
    // sxA is primitive
    // syA is primitive
    // xA is primitive
    // yA is primitive
    // nx is primitive
    // ny is primitive
    if (host == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'host' is null for clblasFillSubMatrixAsync");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (command_queue == nullptr)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'command_queue' is null for clblasFillSubMatrixAsync");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // event may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasFillSubMatrixAsync(order=%d, element_size=%ld, A=%p, offA=%ld, ldA=%ld, sxA=%ld, syA=%ld, xA=%d, yA=%d, nx=%ld, ny=%ld, host=%p, command_queue=%p, numEventsInWaitList=%d, eventWaitList=%p, event=%p)\n",
        order, element_size, A, offA, ldA, sxA, syA, xA, yA, nx, ny, host, command_queue, numEventsInWaitList, eventWaitList, event);

    // Native variable declarations
    clblasOrder order_native;
    size_t element_size_native = 0;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    size_t ldA_native = 0;
    size_t sxA_native = 0;
    size_t syA_native = 0;
    int xA_native = 0;
    int yA_native = 0;
    size_t nx_native = 0;
    size_t ny_native = 0;
    void * host_native = nullptr;
    cl_command_queue command_queue_native = nullptr;
    cl_uint numEventsInWaitList_native = 0;
    cl_event * eventWaitList_native = nullptr;
    cl_event * event_native = nullptr;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    element_size_native = (size_t)element_size;
    if (!initNative(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    ldA_native = (size_t)ldA;
    sxA_native = (size_t)sxA;
    syA_native = (size_t)syA;
    xA_native = (int)xA;
    yA_native = (int)yA;
    nx_native = (size_t)nx;
    ny_native = (size_t)ny;
    PointerData *host_pointerData = initPointerData(env, host);
    if (host_pointerData == NULL)
    {
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    host_native = (void *)host_pointerData->pointer;
    if (!initNative(env, command_queue, command_queue_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!initNative(env, eventWaitList, eventWaitList_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!initNative(env, event, event_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasFillSubMatrixAsync(order_native, element_size_native, A_native, offA_native, ldA_native, sxA_native, syA_native, xA_native, yA_native, nx_native, ny_native, host_native, command_queue_native, numEventsInWaitList_native, eventWaitList_native, event_native);

    // Write back native variable values
    // order is primitive
    // element_size is primitive
    // A is a read-only native pointer
    // offA is primitive
    // ldA is primitive
    // sxA is primitive
    // syA is primitive
    // xA is primitive
    // yA is primitive
    // nx is primitive
    // ny is primitive
    if (!releasePointerData(env, host_pointerData, JNI_ABORT)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // command_queue is a read-only native pointer
    // numEventsInWaitList is primitive
    if (!releaseNative(env, eventWaitList_native, eventWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!releaseNative(env, event_native, event, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult = (jint)jniResult_native;
    return jniResult;
}

