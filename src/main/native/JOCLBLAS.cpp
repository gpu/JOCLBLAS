/*
* JOCLBLAS - Java bindings for clBLAS
*
* Copyright (c) 2015-2016 Marco Hutter - http://www.jocl.org
*
* Permission is hereby granted, free of charge, to any person
* obtaining a copy of this software and associated documentation
* files (the "Software"), to deal in the Software without
* restriction, including without limitation the rights to use,
* copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the
* Software is furnished to do so, subject to the following
* conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
* OTHER DEALINGS IN THE SOFTWARE.
*/

#include "JOCLBLAS.hpp"

#define JOCL_BLAS_STATUS_INTERNAL_ERROR -16384;

#include <string.h>
#include <string>
#include <map>

#include "Logger.hpp"
#include "JOCLCommon.hpp"
#include "JNIUtils.hpp"
#include "PointerUtils.hpp"
#include "CLJNIUtils.hpp"

#include <clBLAS.h>

// Static class and method ID for cl_mem and its constructor
static jclass cl_mem_Class;
static jmethodID cl_mem_Constructor;


/**
* Called when the library is loaded. Will initialize all
* required global class references, field and method IDs
*/
JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM *jvm, void *reserved)
{
    JNIEnv *env = NULL;
    if (jvm->GetEnv((void**)&env, JNI_VERSION_1_4))
    {
        return JNI_ERR;
    }

    Logger::log(LOG_TRACE, "Initializing JOCLBLAS\n");

    // Initialize the utility methods
    if (initJNIUtils(env) == JNI_ERR) return JNI_ERR;
    if (initCLJNIUtils(env) == JNI_ERR) return JNI_ERR;
    if (initPointerUtils(env) == JNI_ERR) return JNI_ERR;

    // Obtain the global class references and the constructor methodIDs
    // for classes which will have to be instantiated
    if (!init(env, "org/jocl/cl_mem", cl_mem_Class, cl_mem_Constructor)) return JNI_ERR;

    return JNI_VERSION_1_4;
}

/**
* Called when the library is unloaded.
*/
JNIEXPORT void JNICALL JNI_OnUnload(JavaVM *vm, void *reserved)
{
    // Nothing to do here
}


bool init_cl_mem(JNIEnv *env, jobject mem, cl_mem& mem_native, bool fillTarget)
{
    if (mem != nullptr)
    {
        mem_native = (cl_mem)env->GetLongField(mem, NativePointerObject_nativePointer);
    }
    return true;
}


bool init_cl_context(JNIEnv *env, jobject context, cl_context& context_native, bool fillTarget)
{
    if (context != nullptr)
    {
        context_native = (cl_context)env->GetLongField(context, NativePointerObject_nativePointer);
    }
    return true;
}


jobject create_cl_mem(JNIEnv *env, cl_mem& mem_native)
{
    if (mem_native == nullptr)
    {
        return nullptr;
    }
    jobject mem = env->NewObject(cl_mem_Class, cl_mem_Constructor);
    if (env->ExceptionCheck())
    {
        return nullptr;
    }
    env->SetLongField(mem, NativePointerObject_nativePointer, (jlong)mem_native);
    return mem;
}


bool init_cl_command_queue(JNIEnv *env, jobject commandQueue, cl_command_queue& commandQueue_native, bool fillTarget)
{
    if (commandQueue != nullptr)
    {
        commandQueue_native = (cl_command_queue)env->GetLongField(commandQueue, NativePointerObject_nativePointer);
    }
    return true;
}

bool release_cl_event(JNIEnv *env, cl_event* &event_native, jobject event, bool writeBack)
{
    if (writeBack)
    {
        if (event_native != nullptr)
        {
            if (event == nullptr)
            {
                ThrowByName(env, "java/lang/NullPointerException",
                    "Trying to write to 'null' object");
                return false;
            }
            env->SetLongField(event, NativePointerObject_nativePointer, (jlong)event_native);
        }
    }
    return true;
}



bool init_cl_command_queue_list(JNIEnv *env, jobjectArray commandQueues, cl_command_queue* &commandQueues_native, bool fillTarget)
{
    if (commandQueues == nullptr)
    {
        commandQueues_native = nullptr;
        return true;
    }
    jsize length = env->GetArrayLength(commandQueues);

    commandQueues_native = new cl_command_queue[length];
    if (commandQueues_native == NULL)
    {
        ThrowByName(env, "java/lang/OutOfMemoryError",
            "Out of memory during array creation");
        return false;
    }

    if (fillTarget)
    {
        for (jsize i = 0; i < length; i++)
        {
            jobject commandQueue = env->GetObjectArrayElement(commandQueues, i);
            if (env->ExceptionCheck())
            {
                delete[] commandQueues_native;
                commandQueues_native = nullptr;
                return false;
            }
            if (commandQueue == nullptr)
            {
                delete[] commandQueues_native;
                commandQueues_native = nullptr;
                ThrowByName(env, "java/lang/NullPointerException",
                    "Array contains 'null' elements");
                return false;
            }
            commandQueues_native[i] =
                (cl_command_queue)env->GetLongField(commandQueue, NativePointerObject_nativePointer);
        }
    }
    return true;
}



bool release_cl_command_queue_list(JNIEnv *env, cl_command_queue* &commandQueues_native, jobjectArray commandQueues, bool writeBack)
{
    if (commandQueues_native == nullptr)
    {
        return true;
    }
    if (commandQueues == nullptr)
    {
        delete[] commandQueues_native;
        commandQueues_native = nullptr;
        ThrowByName(env, "java/lang/NullPointerException",
            "Trying to write to 'null' array");
        return false;
    }
    jsize length = env->GetArrayLength(commandQueues);
    if (writeBack)
    {
        for (jsize i = 0; i < length; i++)
        {
            jobject commandQueue = env->GetObjectArrayElement(commandQueues, i);
            if (env->ExceptionCheck())
            {
                delete[] commandQueues_native;
                commandQueues_native = nullptr;
                return false;
            }
            if (commandQueue == nullptr)
            {
                delete[] commandQueues_native;
                commandQueues_native = nullptr;
                ThrowByName(env, "java/lang/NullPointerException",
                    "Array contains 'null' elements");
                return false;
            }
            env->SetLongField(commandQueue, NativePointerObject_nativePointer, (jlong)commandQueues_native[i]);
        }
    }
    delete[] commandQueues_native;
    commandQueues_native = nullptr;
    return true;
}


bool init_cl_event_list(JNIEnv *env, jobjectArray events, cl_event* &events_native, bool fillTarget)
{
    if (events == nullptr)
    {
        events_native = nullptr;
        return true;
    }
    jsize length = env->GetArrayLength(events);

    events_native = new cl_event[length];
    if (events_native == NULL)
    {
        ThrowByName(env, "java/lang/OutOfMemoryError",
            "Out of memory during array creation");
        return false;
    }

    if (fillTarget)
    {
        for (jsize i = 0; i < length; i++)
        {
            jobject event = env->GetObjectArrayElement(events, i);
            if (env->ExceptionCheck())
            {
                delete[] events_native;
                events_native = nullptr;
                return false;
            }
            if (event == nullptr)
            {
                delete[] events_native;
                events_native = nullptr;
                ThrowByName(env, "java/lang/NullPointerException",
                    "Array contains 'null' elements");
                return false;
            }
            events_native[i] =
                (cl_event)env->GetLongField(event, NativePointerObject_nativePointer);
        }
    }
    return true;
}

bool release_cl_event_list(JNIEnv *env, cl_event* &events_native, jobjectArray events, bool writeBack)
{
    if (events_native == nullptr)
    {
        return true;
    }
    if (events == nullptr)
    {
        delete[] events_native;
        events_native = nullptr;
        ThrowByName(env, "java/lang/NullPointerException",
            "Trying to write to 'null' array");
        return false;
    }
    jsize length = env->GetArrayLength(events);
    if (writeBack)
    {
        for (jsize i = 0; i < length; i++)
        {
            jobject event = env->GetObjectArrayElement(events, i);
            if (env->ExceptionCheck())
            {
                delete[] events_native;
                events_native = nullptr;
                return false;
            }
            if (event == nullptr)
            {
                delete[] events_native;
                events_native = nullptr;
                ThrowByName(env, "java/lang/NullPointerException",
                    "Array contains 'null' elements");
                return false;
            }
            env->SetLongField(event, NativePointerObject_nativePointer, (jlong)events_native[i]);
        }
    }
    delete[] events_native;
    events_native = nullptr;
    return true;
}




bool init_cl_event_list(JNIEnv *env, jobjectArray events, cl_event* &events_native, int expectedLength, bool fillTarget)
{
    if (events == nullptr)
    {
        events_native = nullptr;
        return true;
    }
    jsize length = env->GetArrayLength(events);
    if (length < expectedLength)
    {
        ThrowByName(env, "java/lang/ArrayIndexOutOfBoundsException",
            "Array size is smaller than specified number of elements");
        return false;
    }

    events_native = new cl_event[expectedLength];
    if (events_native == NULL)
    {
        ThrowByName(env, "java/lang/OutOfMemoryError",
            "Out of memory during array creation");
        return false;
    }

    if (fillTarget)
    {
        for (jsize i = 0; i < expectedLength; i++)
        {
            jobject event = env->GetObjectArrayElement(events, i);
            if (env->ExceptionCheck())
            {
                delete[] events_native;
                events_native = nullptr;
                return false;
            }
            if (event == nullptr)
            {
                delete[] events_native;
                events_native = nullptr;
                ThrowByName(env, "java/lang/NullPointerException",
                    "Array contains 'null' elements");
                return false;
            }
            events_native[i] =
                (cl_event)env->GetLongField(event, NativePointerObject_nativePointer);
        }
    }
    return true;
}

bool release_cl_event_list(JNIEnv *env, cl_event* &events_native, jobjectArray events, int expectedLength, bool writeBack)
{
    if (events_native == nullptr)
    {
        return true;
    }
    if (events == nullptr)
    {
        delete[] events_native;
        events_native = nullptr;
        ThrowByName(env, "java/lang/NullPointerException",
            "Trying to write to 'null' array");
        return false;
    }
    jsize length = env->GetArrayLength(events);
    if (length < expectedLength)
    {
        ThrowByName(env, "java/lang/ArrayIndexOutOfBoundsException",
            "Array size is smaller than specified number of elements");
        return false;
    }

    if (writeBack)
    {
        for (jsize i = 0; i < expectedLength; i++)
        {
            jobject event = env->GetObjectArrayElement(events, i);
            if (env->ExceptionCheck())
            {
                delete[] events_native;
                events_native = nullptr;
                return false;
            }
            if (event == nullptr)
            {
                delete[] events_native;
                events_native = nullptr;
                ThrowByName(env, "java/lang/NullPointerException",
                    "Array contains 'null' elements");
                return false;
            }
            env->SetLongField(event, NativePointerObject_nativePointer, (jlong)events_native[i]);
        }
    }
    delete[] events_native;
    events_native = nullptr;
    return true;
}



bool init_cl_float2(JNIEnv *env, jfloatArray values, cl_float2& values_native, bool fillTarget)
{
    if (fillTarget)
    {
        jsize length = env->GetArrayLength(values);
        if (length < 2)
        {
            ThrowByName(env, "java/lang/ArrayIndexOutOfBoundsException",
                "Array length must be at least 2");
        }
        jfloat localValues[2];
        env->GetFloatArrayRegion(values, 0, 2, localValues);
        values_native.x = (cl_float)localValues[0];
        values_native.y = (cl_float)localValues[1];
    }
    return true;
}

bool release_cl_float2(JNIEnv *env, cl_float2& values_native, jfloatArray values, bool writeBack)
{
    if (writeBack)
    {
        jsize length = env->GetArrayLength(values);
        if (length < 2)
        {
            ThrowByName(env, "java/lang/ArrayIndexOutOfBoundsException",
                "Array length must be at least 2");
        }
        jfloat localValues[2];
        localValues[0] = (jfloat)values_native.x;
        localValues[1] = (jfloat)values_native.y;
        env->SetFloatArrayRegion(values, 0, 2, localValues);
    }
    return true;
}


bool init_cl_double2(JNIEnv *env, jdoubleArray values, cl_double2& values_native, bool fillTarget)
{
    if (fillTarget)
    {
        jsize length = env->GetArrayLength(values);
        if (length < 2)
        {
            ThrowByName(env, "java/lang/ArrayIndexOutOfBoundsException",
                "Array length must be at least 2");
        }
        jdouble localValues[2];
        env->GetDoubleArrayRegion(values, 0, 2, localValues);
        values_native.x = (cl_double)localValues[0];
        values_native.y = (cl_double)localValues[1];
    }
    return true;
}

bool release_cl_double2(JNIEnv *env, cl_double2& values_native, jdoubleArray values, bool writeBack)
{
    if (writeBack)
    {
        jsize length = env->GetArrayLength(values);
        if (length < 2)
        {
            ThrowByName(env, "java/lang/ArrayIndexOutOfBoundsException",
                "Array length must be at least 2");
        }
        jdouble localValues[2];
        localValues[0] = (jdouble)values_native.x;
        localValues[1] = (jdouble)values_native.y;
        env->SetDoubleArrayRegion(values, 0, 2, localValues);
    }
    return true;
}


bool init_FloatComplex(JNIEnv *env, jfloatArray values, FloatComplex& values_native, bool fillTarget)
{
    if (fillTarget)
    {
        jsize length = env->GetArrayLength(values);
        if (length < 2)
        {
            ThrowByName(env, "java/lang/ArrayIndexOutOfBoundsException",
                "Array length must be at least 2");
        }
        jfloat localValues[2];
        env->GetFloatArrayRegion(values, 0, 2, localValues);
        values_native.x = (cl_float)localValues[0];
        values_native.y = (cl_float)localValues[1];
    }
    return true;
}

bool release_FloatComplex(JNIEnv *env, FloatComplex& values_native, jfloatArray values, bool writeBack)
{
    if (writeBack)
    {
        jsize length = env->GetArrayLength(values);
        if (length < 2)
        {
            ThrowByName(env, "java/lang/ArrayIndexOutOfBoundsException",
                "Array length must be at least 2");
        }
        jfloat localValues[2];
        localValues[0] = (jfloat)values_native.x;
        localValues[1] = (jfloat)values_native.y;
        env->SetFloatArrayRegion(values, 0, 2, localValues);
    }
    return true;
}


bool init_DoubleComplex(JNIEnv *env, jdoubleArray values, DoubleComplex& values_native, bool fillTarget)
{
    if (fillTarget)
    {
        jsize length = env->GetArrayLength(values);
        if (length < 2)
        {
            ThrowByName(env, "java/lang/ArrayIndexOutOfBoundsException",
                "Array length must be at least 2");
        }
        jdouble localValues[2];
        env->GetDoubleArrayRegion(values, 0, 2, localValues);
        values_native.x = (cl_double)localValues[0];
        values_native.y = (cl_double)localValues[1];
    }
    return true;
}

bool release_DoubleComplex(JNIEnv *env, DoubleComplex& values_native, jdoubleArray values, bool writeBack)
{
    if (writeBack)
    {
        jsize length = env->GetArrayLength(values);
        if (length < 2)
        {
            ThrowByName(env, "java/lang/ArrayIndexOutOfBoundsException",
                "Array length must be at least 2");
        }
        jdouble localValues[2];
        localValues[0] = (jdouble)values_native.x;
        localValues[1] = (jdouble)values_native.y;
        env->SetDoubleArrayRegion(values, 0, 2, localValues);
    }
    return true;
}


/**@}*/
/**
* @defgroup VERSION Version information
*/
/**@{*/
/**
* <pre>
* Get the clblas library version info.
*
* @param (out) major        Location to store library's major version.
* @param (out) minor        Location to store library's minor version.
* @param (out) patch        Location to store library's patch version.
*
* @returns always \b clblasSuccess.
*
* @ingroup VERSION
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasGetVersionNative(JNIEnv *env, jclass cls, jintArray major, jintArray minor, jintArray patch)
{
    // Null-checks for non-primitive arguments
    // major may be NULL
    // minor may be NULL
    // patch may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasGetVersion(major=%p, minor=%p, patch=%p)\n",
        major, minor, patch);

    // Native variable declarations
    cl_uint major_native;
    cl_uint minor_native;
    cl_uint patch_native;

    // Obtain native variable values
    // major is set here
    // minor is set here
    // patch is set here

    // Native function call
    clblasStatus jniResult_native = clblasGetVersion(&major_native, &minor_native, &patch_native);

    // Write back native variable values
    if (!set(env, major, 0, (jint)major_native)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!set(env, minor, 0, (jint)minor_native)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!set(env, patch, 0, (jint)patch_native)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**@}*/
/**
* @defgroup INIT Initialize library
*/
/**@{*/
/**
* <pre>
* Initialize the clblas library.
*
* Must be called before any other clblas API function is invoked.
* @note This function is not thread-safe.
*
* @return
*   - \b clblasSucces on success;
*   - \b clblasOutOfHostMemory if there is not enough of memory to allocate
*     library's internal structures;
*   - \b clblasOutOfResources in case of requested resources scarcity.
*
* @ingroup INIT
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasSetupNative(JNIEnv *env, jclass cls)
{
    // Log message
    Logger::log(LOG_TRACE, "Executing clblasSetup()\n");

    // Native function call
    clblasStatus jniResult_native = clblasSetup();

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* Finalize the usage of the clblas library.
*
* Frees all memory allocated for different computational kernel and other
* internal data.
* @note This function is not thread-safe.
*
* @ingroup INIT
* </pre>
*/
JNIEXPORT void JNICALL Java_org_jocl_blas_CLBLAS_clblasTeardownNative(JNIEnv *env, jclass cls)
{
    // Log message
    Logger::log(LOG_TRACE, "Executing clblasTeardown()\n");

    // Native function call
    clblasTeardown();

}

/**@}*/
/**
* <pre>
* @defgroup BLAS1 BLAS-1 functions
*
* The Level 1 Basic Linear Algebra Subprograms are functions that perform
* vector-vector operations.
* </pre>
*/
/**@{*/
/**@}*/
/**
* <pre>
* @defgroup SWAP SWAP  - Swap elements from 2 vectors
* @ingroup BLAS1
* </pre>
*/
/**@{*/
/**
* <pre>
* interchanges two vectors of float.
*
*
* @param (in) N         Number of elements in vector \b X.
* @param (out) X        Buffer object storing vector \b X.
* @param (in) offx      Offset of first element of vector \b X in buffer object.
*                      Counted in elements.
* @param (in) incx      Increment for the elements of \b X. Must not be zero.
* @param (out) Y        Buffer object storing the vector \b Y.
* @param (in) offy      Offset of first element of vector \b Y in buffer object.
*                      Counted in elements.
* @param (in) incy      Increment for the elements of \b Y. Must not be zero.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasNotInitialized if clblasSetup() was not called;
*   - \b clblasInvalidValue if invalid parameters are passed:
*     - \b N is zero, or
*     - either \b incx or \b incy is zero, or
*     - the vector sizes along with the increments lead to
*       accessing outside of any of the buffers;
*   - \b clblasInvalidMemObject if either \b X, or \b Y object is
*     Invalid, or an image object rather than the buffer one;
*   - \b clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   - \b clblasInvalidCommandQueue if the passed command queue is invalid;
*   - \b clblasInvalidContext if a context a passed command queue belongs
*     to was released;
*   - \b clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   - \b clblasCompilerNotAvailable if a compiler is not available;
*   - \b clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
* @ingroup SWAP
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasSswapNative(JNIEnv *env, jclass cls, jlong N, jobject X, jlong offx, jint incx, jobject Y, jlong offy, jint incy, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasSswap");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (Y == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasSswap");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasSswap");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasSswap(N=%ld, X=%p, offx=%ld, incx=%d, Y=%p, offy=%ld, incy=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, X, offx, incx, Y, offy, incy, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    N_native = (size_t)N;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_cl_mem(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasSswap(N_native, X_native, offx_native, incx_native, Y_native, offy_native, incy_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* @example example_sswap.c
* Example of how to use the @ref clblasSswap function.
* </pre>
*/
/**
* <pre>
* interchanges two vectors of double.
*
*
* @param (in) N         Number of elements in vector \b X.
* @param (out) X        Buffer object storing vector \b X.
* @param (in) offx      Offset of first element of vector \b X in buffer object.
*                      Counted in elements.
* @param (in) incx      Increment for the elements of \b X. Must not be zero.
* @param (out) Y        Buffer object storing the vector \b Y.
* @param (in) offy      Offset of first element of vector \b Y in buffer object.
*                      Counted in elements.
* @param (in) incy      Increment for the elements of \b Y. Must not be zero.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasInvalidDevice if a target device does not support the
*     floating point arithmetic with double precision;
*   - the same error codes as the clblasSswap() function otherwise.
*
* @ingroup SWAP
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasDswapNative(JNIEnv *env, jclass cls, jlong N, jobject X, jlong offx, jint incx, jobject Y, jlong offy, jint incy, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasDswap");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (Y == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasDswap");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasDswap");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasDswap(N=%ld, X=%p, offx=%ld, incx=%d, Y=%p, offy=%ld, incy=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, X, offx, incx, Y, offy, incy, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    N_native = (size_t)N;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_cl_mem(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasDswap(N_native, X_native, offx_native, incx_native, Y_native, offy_native, incy_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* interchanges two vectors of complex-float elements.
*
*
* @param (in) N         Number of elements in vector \b X.
* @param (out) X        Buffer object storing vector \b X.
* @param (in) offx      Offset of first element of vector \b X in buffer object.
*                      Counted in elements.
* @param (in) incx      Increment for the elements of \b X. Must not be zero.
* @param (out) Y        Buffer object storing the vector \b Y.
* @param (in) offy      Offset of first element of vector \b Y in buffer object.
*                      Counted in elements.
* @param (in) incy      Increment for the elements of \b Y. Must not be zero.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - the same error codes as the clblasSwap() function otherwise.
*
* @ingroup SWAP
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasCswapNative(JNIEnv *env, jclass cls, jlong N, jobject X, jlong offx, jint incx, jobject Y, jlong offy, jint incy, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasCswap");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (Y == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasCswap");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasCswap");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasCswap(N=%ld, X=%p, offx=%ld, incx=%d, Y=%p, offy=%ld, incy=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, X, offx, incx, Y, offy, incy, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    N_native = (size_t)N;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_cl_mem(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasCswap(N_native, X_native, offx_native, incx_native, Y_native, offy_native, incy_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* interchanges two vectors of double-complex elements.
*
*
* @param (in) N         Number of elements in vector \b X.
* @param (out) X        Buffer object storing vector \b X.
* @param (in) offx      Offset of first element of vector \b X in buffer object.
*                      Counted in elements.
* @param (in) incx      Increment for the elements of \b X. Must not be zero.
* @param (out) Y        Buffer object storing the vector \b Y.
* @param (in) offy      Offset of first element of vector \b Y in buffer object.
*                      Counted in elements.
* @param (in) incy      Increment for the elements of \b Y. Must not be zero.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - the same error codes as the clblasDwap() function otherwise.
*
* @ingroup SWAP
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasZswapNative(JNIEnv *env, jclass cls, jlong N, jobject X, jlong offx, jint incx, jobject Y, jlong offy, jint incy, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasZswap");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (Y == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasZswap");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasZswap");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasZswap(N=%ld, X=%p, offx=%ld, incx=%d, Y=%p, offy=%ld, incy=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, X, offx, incx, Y, offy, incy, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    N_native = (size_t)N;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_cl_mem(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasZswap(N_native, X_native, offx_native, incx_native, Y_native, offy_native, incy_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**@}*/
/**
* <pre>
* @defgroup SCAL SCAL  - Scales a vector by a constant
* @ingroup BLAS1
* </pre>
*/
/**@{*/
/**
* <pre>
* Scales a float vector by a float constant
*
*   - \f$ X \leftarrow \alpha X \f$
*
* @param (in) N         Number of elements in vector \b X.
* @param (in) alpha     The constant factor for vector \b X.
* @param (out) X        Buffer object storing vector \b X.
* @param (in) offx      Offset of first element of vector \b X in buffer object.
*                      Counted in elements.
* @param (in) incx      Increment for the elements of \b X. Must not be zero.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasNotInitialized if clblasSetup() was not called;
*   - \b clblasInvalidValue if invalid parameters are passed:
*     - \b N is zero, or
*     - \b incx zero, or
*     - the vector sizes along with the increments lead to
*       accessing outside of any of the buffers;
*   - \b clblasInvalidMemObject if either \b X, or \b Y object is
*     Invalid, or an image object rather than the buffer one;
*   - \b clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   - \b clblasInvalidCommandQueue if the passed command queue is invalid;
*   - \b clblasInvalidContext if a context a passed command queue belongs
*     to was released;
*   - \b clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   - \b clblasCompilerNotAvailable if a compiler is not available;
*   - \b clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
* @ingroup SCAL
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasSscalNative(JNIEnv *env, jclass cls, jlong N, jfloat alpha, jobject X, jlong offx, jint incx, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    // alpha is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasSscal");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasSscal");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasSscal(N=%ld, alpha=%f, X=%p, offx=%ld, incx=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, alpha, X, offx, incx, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_float alpha_native;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    N_native = (size_t)N;
    alpha_native = (cl_float)alpha;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasSscal(N_native, alpha_native, X_native, offx_native, incx_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    // alpha is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* @example example_sscal.c
* Example of how to use the @ref clblasSscal function.
* </pre>
*/
/**
* <pre>
* Scales a double vector by a double constant
*
*   - \f$ X \leftarrow \alpha X \f$
*
* @param (in) N         Number of elements in vector \b X.
* @param (in) alpha     The constant factor for vector \b X.
* @param (out) X        Buffer object storing vector \b X.
* @param (in) offx      Offset of first element of vector \b X in buffer object.
*                      Counted in elements.
* @param (in) incx      Increment for the elements of \b X. Must not be zero.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasInvalidDevice if a target device does not support the
*     floating point arithmetic with double precision;
*   - the same error codes as the clblasSscal() function otherwise.
*
* @ingroup SCAL
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasDscalNative(JNIEnv *env, jclass cls, jlong N, jdouble alpha, jobject X, jlong offx, jint incx, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    // alpha is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasDscal");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasDscal");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasDscal(N=%ld, alpha=%lf, X=%p, offx=%ld, incx=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, alpha, X, offx, incx, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_double alpha_native;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    N_native = (size_t)N;
    alpha_native = (cl_double)alpha;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasDscal(N_native, alpha_native, X_native, offx_native, incx_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    // alpha is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* Scales a complex-float vector by a complex-float constant
*
*   - \f$ X \leftarrow \alpha X \f$
*
* @param (in) N         Number of elements in vector \b X.
* @param (in) alpha     The constant factor for vector \b X.
* @param (out) X        Buffer object storing vector \b X.
* @param (in) offx      Offset of first element of vector \b X in buffer object.
*                      Counted in elements.
* @param (in) incx      Increment for the elements of \b X. Must not be zero.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - the same error codes as the clblasSscal() function otherwise.
*
* @ingroup SCAL
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasCscalNative(JNIEnv *env, jclass cls, jlong N, jfloatArray alpha, jobject X, jlong offx, jint incx, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    if (alpha == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'alpha' is null for clblasCscal");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasCscal");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasCscal");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasCscal(N=%ld, alpha=%p, X=%p, offx=%ld, incx=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, alpha, X, offx, incx, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_float2 alpha_native;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    N_native = (size_t)N;
    if (!init_cl_float2(env, alpha, alpha_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasCscal(N_native, alpha_native, X_native, offx_native, incx_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    if (!release_cl_float2(env, alpha_native, alpha, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* Scales a complex-double vector by a complex-double constant
*
*   - \f$ X \leftarrow \alpha X \f$
*
* @param (in) N         Number of elements in vector \b X.
* @param (in) alpha     The constant factor for vector \b X.
* @param (out) X        Buffer object storing vector \b X.
* @param (in) offx      Offset of first element of vector \b X in buffer object.
*                      Counted in elements.
* @param (in) incx      Increment for the elements of \b X. Must not be zero.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - the same error codes as the clblasDscal() function otherwise.
*
* @ingroup SCAL
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasZscalNative(JNIEnv *env, jclass cls, jlong N, jdoubleArray alpha, jobject X, jlong offx, jint incx, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    if (alpha == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'alpha' is null for clblasZscal");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasZscal");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasZscal");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasZscal(N=%ld, alpha=%p, X=%p, offx=%ld, incx=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, alpha, X, offx, incx, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_double2 alpha_native;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    N_native = (size_t)N;
    if (!init_cl_double2(env, alpha, alpha_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasZscal(N_native, alpha_native, X_native, offx_native, incx_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    if (!release_cl_double2(env, alpha_native, alpha, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**@}*/
/**
* <pre>
* @defgroup SSCAL SSCAL  - Scales a complex vector by a real constant
* @ingroup BLAS1
* </pre>
*/
/**@{*/
/**
* <pre>
* Scales a complex-float vector by a float constant
*
*   - \f$ X \leftarrow \alpha X \f$
*
* @param (in) N         Number of elements in vector \b X.
* @param (in) alpha     The constant factor for vector \b X.
* @param (out) X        Buffer object storing vector \b X.
* @param (in) offx      Offset of first element of vector \b X in buffer object.
*                      Counted in elements.
* @param (in) incx      Increment for the elements of \b X. Must not be zero.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasNotInitialized if clblasSetup() was not called;
*   - \b clblasInvalidValue if invalid parameters are passed:
*     - \b N is zero, or
*     - \b incx zero, or
*     - the vector sizes along with the increments lead to
*       accessing outside of any of the buffers;
*   - \b clblasInvalidMemObject if either \b X, or \b Y object is
*     Invalid, or an image object rather than the buffer one;
*   - \b clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   - \b clblasInvalidCommandQueue if the passed command queue is invalid;
*   - \b clblasInvalidContext if a context a passed command queue belongs
*     to was released;
*   - \b clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   - \b clblasCompilerNotAvailable if a compiler is not available;
*   - \b clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
* @ingroup SSCAL
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasCsscalNative(JNIEnv *env, jclass cls, jlong N, jfloat alpha, jobject X, jlong offx, jint incx, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    // alpha is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasCsscal");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasCsscal");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasCsscal(N=%ld, alpha=%f, X=%p, offx=%ld, incx=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, alpha, X, offx, incx, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_float alpha_native;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    N_native = (size_t)N;
    alpha_native = (cl_float)alpha;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasCsscal(N_native, alpha_native, X_native, offx_native, incx_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    // alpha is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* @example example_csscal.c
* Example of how to use the @ref clblasCsscal function.
* </pre>
*/
/**
* <pre>
* Scales a complex-double vector by a double constant
*
*   - \f$ X \leftarrow \alpha X \f$
*
* @param (in) N         Number of elements in vector \b X.
* @param (in) alpha     The constant factor for vector \b X.
* @param (out) X        Buffer object storing vector \b X.
* @param (in) offx      Offset of first element of vector \b X in buffer object.
*                      Counted in elements.
* @param (in) incx      Increment for the elements of \b X. Must not be zero.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasInvalidDevice if a target device does not support the
*     floating point arithmetic with double precision;
*   - the same error codes as the clblasCsscal() function otherwise.
*
* @ingroup SSCAL
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasZdscalNative(JNIEnv *env, jclass cls, jlong N, jdouble alpha, jobject X, jlong offx, jint incx, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    // alpha is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasZdscal");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasZdscal");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasZdscal(N=%ld, alpha=%lf, X=%p, offx=%ld, incx=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, alpha, X, offx, incx, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_double alpha_native;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    N_native = (size_t)N;
    alpha_native = (cl_double)alpha;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasZdscal(N_native, alpha_native, X_native, offx_native, incx_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    // alpha is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**@}*/
/**
* <pre>
* @defgroup COPY COPY  - Copies elements from vector X to vector Y
* @ingroup BLAS1
* </pre>
*/
/**@{*/
/**
* <pre>
* Copies float elements from vector X to vector Y
*
*   - \f$ Y \leftarrow X \f$
*
* @param (in) N         Number of elements in vector \b X.
* @param (in) X         Buffer object storing vector \b X.
* @param (in) offx      Offset of first element of vector \b X in buffer object.
*                      Counted in elements.
* @param (in) incx      Increment for the elements of \b X. Must not be zero.
* @param (out) Y        Buffer object storing the vector \b Y.
* @param (in) offy      Offset of first element of vector \b Y in buffer object.
*                      Counted in elements.
* @param (in) incy      Increment for the elements of \b Y. Must not be zero.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasNotInitialized if clblasSetup() was not called;
*   - \b clblasInvalidValue if invalid parameters are passed:
*     - \b N is zero, or
*     - either \b incx or \b incy is zero, or
*     - the vector sizes along with the increments lead to
*       accessing outside of any of the buffers;
*   - \b clblasInvalidMemObject if either \b X, or \b Y object is
*     Invalid, or an image object rather than the buffer one;
*   - \b clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   - \b clblasInvalidCommandQueue if the passed command queue is invalid;
*   - \b clblasInvalidContext if a context a passed command queue belongs
*     to was released;
*   - \b clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   - \b clblasCompilerNotAvailable if a compiler is not available;
*   - \b clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
* @ingroup COPY
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasScopyNative(JNIEnv *env, jclass cls, jlong N, jobject X, jlong offx, jint incx, jobject Y, jlong offy, jint incy, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasScopy");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (Y == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasScopy");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasScopy");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasScopy(N=%ld, X=%p, offx=%ld, incx=%d, Y=%p, offy=%ld, incy=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, X, offx, incx, Y, offy, incy, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    N_native = (size_t)N;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_cl_mem(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasScopy(N_native, X_native, offx_native, incx_native, Y_native, offy_native, incy_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* @example example_scopy.c
* Example of how to use the @ref clblasScopy function.
* </pre>
*/
/**
* <pre>
* Copies double elements from vector X to vector Y
*
*   - \f$ Y \leftarrow X \f$
*
* @param (in) N         Number of elements in vector \b X.
* @param (in) X         Buffer object storing vector \b X.
* @param (in) offx      Offset of first element of vector \b X in buffer object.
*                      Counted in elements.
* @param (in) incx      Increment for the elements of \b X. Must not be zero.
* @param (out) Y        Buffer object storing the vector \b Y.
* @param (in) offy      Offset of first element of vector \b Y in buffer object.
*                      Counted in elements.
* @param (in) incy      Increment for the elements of \b Y. Must not be zero.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasInvalidDevice if a target device does not support the
*     floating point arithmetic with double precision;
*   - the same error codes as the clblasScopy() function otherwise.
*
* @ingroup COPY
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasDcopyNative(JNIEnv *env, jclass cls, jlong N, jobject X, jlong offx, jint incx, jobject Y, jlong offy, jint incy, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasDcopy");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (Y == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasDcopy");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasDcopy");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasDcopy(N=%ld, X=%p, offx=%ld, incx=%d, Y=%p, offy=%ld, incy=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, X, offx, incx, Y, offy, incy, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    N_native = (size_t)N;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_cl_mem(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasDcopy(N_native, X_native, offx_native, incx_native, Y_native, offy_native, incy_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* Copies complex-float elements from vector X to vector Y
*
*   - \f$ Y \leftarrow X \f$
*
* @param (in) N         Number of elements in vector \b X.
* @param (in) X         Buffer object storing vector \b X.
* @param (in) offx      Offset of first element of vector \b X in buffer object.
*                      Counted in elements.
* @param (in) incx      Increment for the elements of \b X. Must not be zero.
* @param (out) Y        Buffer object storing the vector \b Y.
* @param (in) offy      Offset of first element of vector \b Y in buffer object.
*                      Counted in elements.
* @param (in) incy      Increment for the elements of \b Y. Must not be zero.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - the same error codes as the clblasScopy() function otherwise.
*
* @ingroup COPY
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasCcopyNative(JNIEnv *env, jclass cls, jlong N, jobject X, jlong offx, jint incx, jobject Y, jlong offy, jint incy, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasCcopy");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (Y == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasCcopy");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasCcopy");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasCcopy(N=%ld, X=%p, offx=%ld, incx=%d, Y=%p, offy=%ld, incy=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, X, offx, incx, Y, offy, incy, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    N_native = (size_t)N;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_cl_mem(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasCcopy(N_native, X_native, offx_native, incx_native, Y_native, offy_native, incy_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* Copies complex-double elements from vector X to vector Y
*
*   - \f$ Y \leftarrow X \f$
*
* @param (in) N         Number of elements in vector \b X.
* @param (in) X         Buffer object storing vector \b X.
* @param (in) offx      Offset of first element of vector \b X in buffer object.
*                      Counted in elements.
* @param (in) incx      Increment for the elements of \b X. Must not be zero.
* @param (out) Y        Buffer object storing the vector \b Y.
* @param (in) offy      Offset of first element of vector \b Y in buffer object.
*                      Counted in elements.
* @param (in) incy      Increment for the elements of \b Y. Must not be zero.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - the same error codes as the clblasDcopy() function otherwise.
*
* @ingroup COPY
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasZcopyNative(JNIEnv *env, jclass cls, jlong N, jobject X, jlong offx, jint incx, jobject Y, jlong offy, jint incy, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasZcopy");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (Y == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasZcopy");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasZcopy");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasZcopy(N=%ld, X=%p, offx=%ld, incx=%d, Y=%p, offy=%ld, incy=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, X, offx, incx, Y, offy, incy, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    N_native = (size_t)N;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_cl_mem(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasZcopy(N_native, X_native, offx_native, incx_native, Y_native, offy_native, incy_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**@}*/
/**
* <pre>
* @defgroup AXPY AXPY  - Scale X and add to Y
* @ingroup BLAS1
* </pre>
*/
/**@{*/
/**
* <pre>
* Scale vector X of float elements and add to Y
*
*   - \f$ Y \leftarrow \alpha X + Y \f$
*
* @param (in) N         Number of elements in vector \b X.
* @param (in) alpha     The constant factor for vector \b X.
* @param (in) X         Buffer object storing vector \b X.
* @param (in) offx      Offset of first element of vector \b X in buffer object.
*                      Counted in elements.
* @param (in) incx      Increment for the elements of \b X. Must not be zero.
* @param (out) Y        Buffer object storing the vector \b Y.
* @param (in) offy      Offset of first element of vector \b Y in buffer object.
*                      Counted in elements.
* @param (in) incy      Increment for the elements of \b Y. Must not be zero.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasNotInitialized if clblasSetup() was not called;
*   - \b clblasInvalidValue if invalid parameters are passed:
*     - \b N is zero, or
*     - either \b incx or \b incy is zero, or
*     - the vector sizes along with the increments lead to
*       accessing outside of any of the buffers;
*   - \b clblasInvalidMemObject if either \b X, or \b Y object is
*     Invalid, or an image object rather than the buffer one;
*   - \b clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   - \b clblasInvalidCommandQueue if the passed command queue is invalid;
*   - \b clblasInvalidContext if a context a passed command queue belongs
*     to was released;
*   - \b clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   - \b clblasCompilerNotAvailable if a compiler is not available;
*   - \b clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
* @ingroup AXPY
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasSaxpyNative(JNIEnv *env, jclass cls, jlong N, jfloat alpha, jobject X, jlong offx, jint incx, jobject Y, jlong offy, jint incy, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    // alpha is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasSaxpy");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (Y == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasSaxpy");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasSaxpy");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasSaxpy(N=%ld, alpha=%f, X=%p, offx=%ld, incx=%d, Y=%p, offy=%ld, incy=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, alpha, X, offx, incx, Y, offy, incy, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_float alpha_native;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    N_native = (size_t)N;
    alpha_native = (cl_float)alpha;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_cl_mem(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasSaxpy(N_native, alpha_native, X_native, offx_native, incx_native, Y_native, offy_native, incy_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    // alpha is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* @example example_saxpy.c
* Example of how to use the @ref clblasSaxpy function.
* </pre>
*/
/**
* <pre>
* Scale vector X of double elements and add to Y
*
*   - \f$ Y \leftarrow \alpha X + Y \f$
*
* @param (in) N         Number of elements in vector \b X.
* @param (in) alpha     The constant factor for vector \b X.
* @param (in) X         Buffer object storing vector \b X.
* @param (in) offx      Offset of first element of vector \b X in buffer object.
*                      Counted in elements.
* @param (in) incx      Increment for the elements of \b X. Must not be zero.
* @param (out) Y        Buffer object storing the vector \b Y.
* @param (in) offy      Offset of first element of vector \b Y in buffer object.
*                      Counted in elements.
* @param (in) incy      Increment for the elements of \b Y. Must not be zero.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasInvalidDevice if a target device does not support the
*     floating point arithmetic with double precision;
*   - the same error codes as the clblasSaxpy() function otherwise.
*
* @ingroup AXPY
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasDaxpyNative(JNIEnv *env, jclass cls, jlong N, jdouble alpha, jobject X, jlong offx, jint incx, jobject Y, jlong offy, jint incy, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    // alpha is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasDaxpy");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (Y == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasDaxpy");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasDaxpy");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasDaxpy(N=%ld, alpha=%lf, X=%p, offx=%ld, incx=%d, Y=%p, offy=%ld, incy=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, alpha, X, offx, incx, Y, offy, incy, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_double alpha_native;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    N_native = (size_t)N;
    alpha_native = (cl_double)alpha;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_cl_mem(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasDaxpy(N_native, alpha_native, X_native, offx_native, incx_native, Y_native, offy_native, incy_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    // alpha is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* Scale vector X of complex-float elements and add to Y
*
*   - \f$ Y \leftarrow \alpha X + Y \f$
*
* @param (in) N         Number of elements in vector \b X.
* @param (in) alpha     The constant factor for vector \b X.
* @param (in) X         Buffer object storing vector \b X.
* @param (in) offx      Offset of first element of vector \b X in buffer object.
*                      Counted in elements.
* @param (in) incx      Increment for the elements of \b X. Must not be zero.
* @param (out) Y        Buffer object storing the vector \b Y.
* @param (in) offy      Offset of first element of vector \b Y in buffer object.
*                      Counted in elements.
* @param (in) incy      Increment for the elements of \b Y. Must not be zero.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - the same error codes as the clblasSaxpy() function otherwise.
*
* @ingroup AXPY
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasCaxpyNative(JNIEnv *env, jclass cls, jlong N, jfloatArray alpha, jobject X, jlong offx, jint incx, jobject Y, jlong offy, jint incy, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    if (alpha == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'alpha' is null for clblasCaxpy");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasCaxpy");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (Y == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasCaxpy");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasCaxpy");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasCaxpy(N=%ld, alpha=%p, X=%p, offx=%ld, incx=%d, Y=%p, offy=%ld, incy=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, alpha, X, offx, incx, Y, offy, incy, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_float2 alpha_native;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    N_native = (size_t)N;
    if (!init_cl_float2(env, alpha, alpha_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_cl_mem(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasCaxpy(N_native, alpha_native, X_native, offx_native, incx_native, Y_native, offy_native, incy_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    if (!release_cl_float2(env, alpha_native, alpha, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* Scale vector X of double-complex elements and add to Y
*
*   - \f$ Y \leftarrow \alpha X + Y \f$
*
* @param (in) N         Number of elements in vector \b X.
* @param (in) alpha     The constant factor for vector \b X.
* @param (in) X         Buffer object storing vector \b X.
* @param (in) offx      Offset of first element of vector \b X in buffer object.
*                      Counted in elements.
* @param (in) incx      Increment for the elements of \b X. Must not be zero.
* @param (out) Y        Buffer object storing the vector \b Y.
* @param (in) offy      Offset of first element of vector \b Y in buffer object.
*                      Counted in elements.
* @param (in) incy      Increment for the elements of \b Y. Must not be zero.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - the same error codes as the clblasDaxpy() function otherwise.
*
* @ingroup AXPY
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasZaxpyNative(JNIEnv *env, jclass cls, jlong N, jdoubleArray alpha, jobject X, jlong offx, jint incx, jobject Y, jlong offy, jint incy, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    if (alpha == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'alpha' is null for clblasZaxpy");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasZaxpy");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (Y == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasZaxpy");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasZaxpy");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasZaxpy(N=%ld, alpha=%p, X=%p, offx=%ld, incx=%d, Y=%p, offy=%ld, incy=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, alpha, X, offx, incx, Y, offy, incy, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_double2 alpha_native;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    N_native = (size_t)N;
    if (!init_cl_double2(env, alpha, alpha_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_cl_mem(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasZaxpy(N_native, alpha_native, X_native, offx_native, incx_native, Y_native, offy_native, incy_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    if (!release_cl_double2(env, alpha_native, alpha, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**@}*/
/**
* <pre>
* @defgroup DOT DOT  - Dot product of two vectors
* @ingroup BLAS1
* </pre>
*/
/**@{*/
/**
* <pre>
* dot product of two vectors containing float elements
*
* @param (in) N             Number of elements in vector \b X.
* @param (out) dotProduct   Buffer object that will contain the dot-product value
* @param (in) offDP         Offset to dot-product in \b dotProduct buffer object.
*                          Counted in elements.
* @param (in) X             Buffer object storing vector \b X.
* @param (in) offx          Offset of first element of vector \b X in buffer object.
*                          Counted in elements.
* @param (in) incx          Increment for the elements of \b X. Must not be zero.
* @param (in) Y             Buffer object storing the vector \b Y.
* @param (in) offy          Offset of first element of vector \b Y in buffer object.
*                          Counted in elements.
* @param (in) incy          Increment for the elements of \b Y. Must not be zero.
* @param (in) scratchBuff	Temporary cl_mem scratch buffer object of minimum size N
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasNotInitialized if clblasSetup() was not called;
*   - \b clblasInvalidValue if invalid parameters are passed:
*     - \b N is zero, or
*     - either \b incx or \b incy is zero, or
*     - the vector sizes along with the increments lead to
*       accessing outside of any of the buffers;
*   - \b clblasInvalidMemObject if either \b X, \b Y or \b dotProduct object is
*     Invalid, or an image object rather than the buffer one;
*   - \b clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   - \b clblasInvalidCommandQueue if the passed command queue is invalid;
*   - \b clblasInvalidContext if a context a passed command queue belongs
*     to was released;
*   - \b clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   - \b clblasCompilerNotAvailable if a compiler is not available;
*   - \b clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
* @ingroup DOT
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasSdotNative(JNIEnv *env, jclass cls, jlong N, jobject dotProduct, jlong offDP, jobject X, jlong offx, jint incx, jobject Y, jlong offy, jint incy, jobject scratchBuff, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    if (dotProduct == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'dotProduct' is null for clblasSdot");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offDP is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasSdot");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (Y == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasSdot");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    if (scratchBuff == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'scratchBuff' is null for clblasSdot");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasSdot");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasSdot(N=%ld, dotProduct=%p, offDP=%ld, X=%p, offx=%ld, incx=%d, Y=%p, offy=%ld, incy=%d, scratchBuff=%p, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, dotProduct, offDP, X, offx, incx, Y, offy, incy, scratchBuff, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_mem dotProduct_native = nullptr;
    size_t offDP_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_mem scratchBuff_native = nullptr;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    N_native = (size_t)N;
    if (!init_cl_mem(env, dotProduct, dotProduct_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offDP_native = (size_t)offDP;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_cl_mem(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    if (!init_cl_mem(env, scratchBuff, scratchBuff_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasSdot(N_native, dotProduct_native, offDP_native, X_native, offx_native, incx_native, Y_native, offy_native, incy_native, scratchBuff_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    // dotProduct is a read-only native pointer
    // offDP is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // scratchBuff is a read-only native pointer
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* @example example_sdot.c
* Example of how to use the @ref clblasSdot function.
* </pre>
*/
/**
* <pre>
* dot product of two vectors containing double elements
*
* @param (in) N             Number of elements in vector \b X.
* @param (out) dotProduct   Buffer object that will contain the dot-product value
* @param (in) offDP         Offset to dot-product in \b dotProduct buffer object.
*                          Counted in elements.
* @param (in) X             Buffer object storing vector \b X.
* @param (in) offx          Offset of first element of vector \b X in buffer object.
*                          Counted in elements.
* @param (in) incx          Increment for the elements of \b X. Must not be zero.
* @param (in) Y             Buffer object storing the vector \b Y.
* @param (in) offy          Offset of first element of vector \b Y in buffer object.
*                          Counted in elements.
* @param (in) incy          Increment for the elements of \b Y. Must not be zero.
* @param (in) scratchBuff	Temporary cl_mem scratch buffer object of minimum size N
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasInvalidDevice if a target device does not support the
*     floating point arithmetic with double precision;
*   - the same error codes as the clblasSdot() function otherwise.
*
* @ingroup DOT
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasDdotNative(JNIEnv *env, jclass cls, jlong N, jobject dotProduct, jlong offDP, jobject X, jlong offx, jint incx, jobject Y, jlong offy, jint incy, jobject scratchBuff, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    if (dotProduct == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'dotProduct' is null for clblasDdot");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offDP is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasDdot");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (Y == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasDdot");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    if (scratchBuff == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'scratchBuff' is null for clblasDdot");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasDdot");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasDdot(N=%ld, dotProduct=%p, offDP=%ld, X=%p, offx=%ld, incx=%d, Y=%p, offy=%ld, incy=%d, scratchBuff=%p, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, dotProduct, offDP, X, offx, incx, Y, offy, incy, scratchBuff, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_mem dotProduct_native = nullptr;
    size_t offDP_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_mem scratchBuff_native = nullptr;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    N_native = (size_t)N;
    if (!init_cl_mem(env, dotProduct, dotProduct_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offDP_native = (size_t)offDP;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_cl_mem(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    if (!init_cl_mem(env, scratchBuff, scratchBuff_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasDdot(N_native, dotProduct_native, offDP_native, X_native, offx_native, incx_native, Y_native, offy_native, incy_native, scratchBuff_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    // dotProduct is a read-only native pointer
    // offDP is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // scratchBuff is a read-only native pointer
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* dot product of two vectors containing float-complex elements
*
* @param (in) N             Number of elements in vector \b X.
* @param (out) dotProduct   Buffer object that will contain the dot-product value
* @param (in) offDP         Offset to dot-product in \b dotProduct buffer object.
*                          Counted in elements.
* @param (in) X             Buffer object storing vector \b X.
* @param (in) offx          Offset of first element of vector \b X in buffer object.
*                          Counted in elements.
* @param (in) incx          Increment for the elements of \b X. Must not be zero.
* @param (in) Y             Buffer object storing the vector \b Y.
* @param (in) offy          Offset of first element of vector \b Y in buffer object.
*                          Counted in elements.
* @param (in) incy          Increment for the elements of \b Y. Must not be zero.
* @param (in) scratchBuff   Temporary cl_mem scratch buffer object of minimum size N
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - the same error codes as the clblasSdot() function otherwise.
*
* @ingroup DOT
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasCdotuNative(JNIEnv *env, jclass cls, jlong N, jobject dotProduct, jlong offDP, jobject X, jlong offx, jint incx, jobject Y, jlong offy, jint incy, jobject scratchBuff, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    if (dotProduct == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'dotProduct' is null for clblasCdotu");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offDP is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasCdotu");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (Y == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasCdotu");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    if (scratchBuff == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'scratchBuff' is null for clblasCdotu");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasCdotu");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasCdotu(N=%ld, dotProduct=%p, offDP=%ld, X=%p, offx=%ld, incx=%d, Y=%p, offy=%ld, incy=%d, scratchBuff=%p, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, dotProduct, offDP, X, offx, incx, Y, offy, incy, scratchBuff, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_mem dotProduct_native = nullptr;
    size_t offDP_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_mem scratchBuff_native = nullptr;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    N_native = (size_t)N;
    if (!init_cl_mem(env, dotProduct, dotProduct_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offDP_native = (size_t)offDP;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_cl_mem(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    if (!init_cl_mem(env, scratchBuff, scratchBuff_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasCdotu(N_native, dotProduct_native, offDP_native, X_native, offx_native, incx_native, Y_native, offy_native, incy_native, scratchBuff_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    // dotProduct is a read-only native pointer
    // offDP is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // scratchBuff is a read-only native pointer
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* dot product of two vectors containing double-complex elements
*
* @param (in) N             Number of elements in vector \b X.
* @param (out) dotProduct   Buffer object that will contain the dot-product value
* @param (in) offDP         Offset to dot-product in \b dotProduct buffer object.
*                          Counted in elements.
* @param (in) X             Buffer object storing vector \b X.
* @param (in) offx          Offset of first element of vector \b X in buffer object.
*                          Counted in elements.
* @param (in) incx          Increment for the elements of \b X. Must not be zero.
* @param (in) Y             Buffer object storing the vector \b Y.
* @param (in) offy          Offset of first element of vector \b Y in buffer object.
*                          Counted in elements.
* @param (in) incy          Increment for the elements of \b Y. Must not be zero.
* @param (in) scratchBuff   Temporary cl_mem scratch buffer object of minimum size N
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasInvalidDevice if a target device does not support the
*     floating point arithmetic with double precision;
*   - the same error codes as the clblasSdot() function otherwise.
*
* @ingroup DOT
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasZdotuNative(JNIEnv *env, jclass cls, jlong N, jobject dotProduct, jlong offDP, jobject X, jlong offx, jint incx, jobject Y, jlong offy, jint incy, jobject scratchBuff, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    if (dotProduct == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'dotProduct' is null for clblasZdotu");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offDP is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasZdotu");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (Y == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasZdotu");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    if (scratchBuff == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'scratchBuff' is null for clblasZdotu");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasZdotu");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasZdotu(N=%ld, dotProduct=%p, offDP=%ld, X=%p, offx=%ld, incx=%d, Y=%p, offy=%ld, incy=%d, scratchBuff=%p, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, dotProduct, offDP, X, offx, incx, Y, offy, incy, scratchBuff, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_mem dotProduct_native = nullptr;
    size_t offDP_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_mem scratchBuff_native = nullptr;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    N_native = (size_t)N;
    if (!init_cl_mem(env, dotProduct, dotProduct_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offDP_native = (size_t)offDP;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_cl_mem(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    if (!init_cl_mem(env, scratchBuff, scratchBuff_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasZdotu(N_native, dotProduct_native, offDP_native, X_native, offx_native, incx_native, Y_native, offy_native, incy_native, scratchBuff_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    // dotProduct is a read-only native pointer
    // offDP is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // scratchBuff is a read-only native pointer
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* dot product of two vectors containing float-complex elements conjugating the first vector
*
* @param (in) N             Number of elements in vector \b X.
* @param (out) dotProduct   Buffer object that will contain the dot-product value
* @param (in) offDP         Offset to dot-product in \b dotProduct buffer object.
*                          Counted in elements.
* @param (in) X             Buffer object storing vector \b X.
* @param (in) offx          Offset of first element of vector \b X in buffer object.
*                          Counted in elements.
* @param (in) incx          Increment for the elements of \b X. Must not be zero.
* @param (in) Y             Buffer object storing the vector \b Y.
* @param (in) offy          Offset of first element of vector \b Y in buffer object.
*                          Counted in elements.
* @param (in) incy          Increment for the elements of \b Y. Must not be zero.
* @param (in) scratchBuff   Temporary cl_mem scratch buffer object of minimum size N
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - the same error codes as the clblasSdot() function otherwise.
*
* @ingroup DOT
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasCdotcNative(JNIEnv *env, jclass cls, jlong N, jobject dotProduct, jlong offDP, jobject X, jlong offx, jint incx, jobject Y, jlong offy, jint incy, jobject scratchBuff, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    if (dotProduct == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'dotProduct' is null for clblasCdotc");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offDP is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasCdotc");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (Y == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasCdotc");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    if (scratchBuff == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'scratchBuff' is null for clblasCdotc");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasCdotc");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasCdotc(N=%ld, dotProduct=%p, offDP=%ld, X=%p, offx=%ld, incx=%d, Y=%p, offy=%ld, incy=%d, scratchBuff=%p, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, dotProduct, offDP, X, offx, incx, Y, offy, incy, scratchBuff, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_mem dotProduct_native = nullptr;
    size_t offDP_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_mem scratchBuff_native = nullptr;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    N_native = (size_t)N;
    if (!init_cl_mem(env, dotProduct, dotProduct_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offDP_native = (size_t)offDP;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_cl_mem(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    if (!init_cl_mem(env, scratchBuff, scratchBuff_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasCdotc(N_native, dotProduct_native, offDP_native, X_native, offx_native, incx_native, Y_native, offy_native, incy_native, scratchBuff_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    // dotProduct is a read-only native pointer
    // offDP is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // scratchBuff is a read-only native pointer
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* dot product of two vectors containing double-complex elements conjugating the first vector
*
* @param (in) N             Number of elements in vector \b X.
* @param (out) dotProduct   Buffer object that will contain the dot-product value
* @param (in) offDP         Offset to dot-product in \b dotProduct buffer object.
*                          Counted in elements.
* @param (in) X             Buffer object storing vector \b X.
* @param (in) offx          Offset of first element of vector \b X in buffer object.
*                          Counted in elements.
* @param (in) incx          Increment for the elements of \b X. Must not be zero.
* @param (in) Y             Buffer object storing the vector \b Y.
* @param (in) offy          Offset of first element of vector \b Y in buffer object.
*                          Counted in elements.
* @param (in) incy          Increment for the elements of \b Y. Must not be zero.
* @param (in) scratchBuff   Temporary cl_mem scratch buffer object of minimum size N
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasInvalidDevice if a target device does not support the
*     floating point arithmetic with double precision;
*   - the same error codes as the clblasSdot() function otherwise.
*
* @ingroup DOT
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasZdotcNative(JNIEnv *env, jclass cls, jlong N, jobject dotProduct, jlong offDP, jobject X, jlong offx, jint incx, jobject Y, jlong offy, jint incy, jobject scratchBuff, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    if (dotProduct == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'dotProduct' is null for clblasZdotc");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offDP is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasZdotc");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (Y == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasZdotc");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    if (scratchBuff == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'scratchBuff' is null for clblasZdotc");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasZdotc");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasZdotc(N=%ld, dotProduct=%p, offDP=%ld, X=%p, offx=%ld, incx=%d, Y=%p, offy=%ld, incy=%d, scratchBuff=%p, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, dotProduct, offDP, X, offx, incx, Y, offy, incy, scratchBuff, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_mem dotProduct_native = nullptr;
    size_t offDP_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_mem scratchBuff_native = nullptr;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    N_native = (size_t)N;
    if (!init_cl_mem(env, dotProduct, dotProduct_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offDP_native = (size_t)offDP;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_cl_mem(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    if (!init_cl_mem(env, scratchBuff, scratchBuff_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasZdotc(N_native, dotProduct_native, offDP_native, X_native, offx_native, incx_native, Y_native, offy_native, incy_native, scratchBuff_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    // dotProduct is a read-only native pointer
    // offDP is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // scratchBuff is a read-only native pointer
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**@}*/
/**
* <pre>
* @defgroup ROTG ROTG  - Constructs givens plane rotation
* @ingroup BLAS1
* </pre>
*/
/**@{*/
/**
* <pre>
* construct givens plane rotation on float elements
*
* @param (out) SA           Buffer object that contains SA
* @param (in) offSA         Offset to SA in \b SA buffer object.
*                          Counted in elements.
* @param (out) SB           Buffer object that contains SB
* @param (in) offSB         Offset to SB in \b SB buffer object.
*                          Counted in elements.
* @param (out) C            Buffer object that contains C
* @param (in) offC          Offset to C in \b C buffer object.
*                          Counted in elements.
* @param (out) S            Buffer object that contains S
* @param (in) offS          Offset to S in \b S buffer object.
*                          Counted in elements.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasNotInitialized if clblasSetup() was not called;
*   - \b clblasInvalidMemObject if either \b SA, \b SB, \b C or \b S object is
*     Invalid, or an image object rather than the buffer one;
*   - \b clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   - \b clblasInvalidCommandQueue if the passed command queue is invalid;
*   - \b clblasInvalidContext if a context a passed command queue belongs
*     to was released;
*   - \b clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   - \b clblasCompilerNotAvailable if a compiler is not available;
*   - \b clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
* @ingroup ROTG
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasSrotgNative(JNIEnv *env, jclass cls, jobject SA, jlong offSA, jobject SB, jlong offSB, jobject C, jlong offC, jobject S, jlong offS, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    if (SA == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'SA' is null for clblasSrotg");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offSA is primitive
    if (SB == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'SB' is null for clblasSrotg");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offSB is primitive
    if (C == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'C' is null for clblasSrotg");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offC is primitive
    if (S == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'S' is null for clblasSrotg");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offS is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasSrotg");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasSrotg(SA=%p, offSA=%ld, SB=%p, offSB=%ld, C=%p, offC=%ld, S=%p, offS=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        SA, offSA, SB, offSB, C, offC, S, offS, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    cl_mem SA_native = nullptr;
    size_t offSA_native = 0;
    cl_mem SB_native = nullptr;
    size_t offSB_native = 0;
    cl_mem C_native = nullptr;
    size_t offC_native = 0;
    cl_mem S_native = nullptr;
    size_t offS_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    if (!init_cl_mem(env, SA, SA_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offSA_native = (size_t)offSA;
    if (!init_cl_mem(env, SB, SB_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offSB_native = (size_t)offSB;
    if (!init_cl_mem(env, C, C_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offC_native = (size_t)offC;
    if (!init_cl_mem(env, S, S_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offS_native = (size_t)offS;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasSrotg(SA_native, offSA_native, SB_native, offSB_native, C_native, offC_native, S_native, offS_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // SA is a read-only native pointer
    // offSA is primitive
    // SB is a read-only native pointer
    // offSB is primitive
    // C is a read-only native pointer
    // offC is primitive
    // S is a read-only native pointer
    // offS is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* @example example_srotg.c
* Example of how to use the @ref clblasSrotg function.
* </pre>
*/
/**
* <pre>
* construct givens plane rotation on double elements
*
* @param (out) DA           Buffer object that contains DA
* @param (in) offDA         Offset to DA in \b DA buffer object.
*                          Counted in elements.
* @param (out) DB           Buffer object that contains DB
* @param (in) offDB         Offset to DB in \b DB buffer object.
*                          Counted in elements.
* @param (out) C            Buffer object that contains C
* @param (in) offC          Offset to C in \b C buffer object.
*                          Counted in elements.
* @param (out) S            Buffer object that contains S
* @param (in) offS          Offset to S in \b S buffer object.
*                          Counted in elements.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasInvalidDevice if a target device does not support the
*     floating point arithmetic with double precision;
*   - the same error codes as the clblasSrotg() function otherwise.
*
* @ingroup ROTG
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasDrotgNative(JNIEnv *env, jclass cls, jobject DA, jlong offDA, jobject DB, jlong offDB, jobject C, jlong offC, jobject S, jlong offS, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    if (DA == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'DA' is null for clblasDrotg");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offDA is primitive
    if (DB == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'DB' is null for clblasDrotg");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offDB is primitive
    if (C == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'C' is null for clblasDrotg");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offC is primitive
    if (S == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'S' is null for clblasDrotg");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offS is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasDrotg");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasDrotg(DA=%p, offDA=%ld, DB=%p, offDB=%ld, C=%p, offC=%ld, S=%p, offS=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        DA, offDA, DB, offDB, C, offC, S, offS, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    cl_mem DA_native = nullptr;
    size_t offDA_native = 0;
    cl_mem DB_native = nullptr;
    size_t offDB_native = 0;
    cl_mem C_native = nullptr;
    size_t offC_native = 0;
    cl_mem S_native = nullptr;
    size_t offS_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    if (!init_cl_mem(env, DA, DA_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offDA_native = (size_t)offDA;
    if (!init_cl_mem(env, DB, DB_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offDB_native = (size_t)offDB;
    if (!init_cl_mem(env, C, C_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offC_native = (size_t)offC;
    if (!init_cl_mem(env, S, S_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offS_native = (size_t)offS;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasDrotg(DA_native, offDA_native, DB_native, offDB_native, C_native, offC_native, S_native, offS_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // DA is a read-only native pointer
    // offDA is primitive
    // DB is a read-only native pointer
    // offDB is primitive
    // C is a read-only native pointer
    // offC is primitive
    // S is a read-only native pointer
    // offS is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* construct givens plane rotation on float-complex elements
*
* @param (out) CA           Buffer object that contains CA
* @param (in) offCA         Offset to CA in \b CA buffer object.
*                          Counted in elements.
* @param (out) CB           Buffer object that contains CB
* @param (in) offCB         Offset to CB in \b CB buffer object.
*                          Counted in elements.
* @param (out) C            Buffer object that contains C. C is real.
* @param (in) offC          Offset to C in \b C buffer object.
*                          Counted in elements.
* @param (out) S            Buffer object that contains S
* @param (in) offS          Offset to S in \b S buffer object.
*                          Counted in elements.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - the same error codes as the clblasSrotg() function otherwise.
*
* @ingroup ROTG
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasCrotgNative(JNIEnv *env, jclass cls, jobject CA, jlong offCA, jobject CB, jlong offCB, jobject C, jlong offC, jobject S, jlong offS, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    if (CA == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'CA' is null for clblasCrotg");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offCA is primitive
    if (CB == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'CB' is null for clblasCrotg");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offCB is primitive
    if (C == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'C' is null for clblasCrotg");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offC is primitive
    if (S == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'S' is null for clblasCrotg");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offS is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasCrotg");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasCrotg(CA=%p, offCA=%ld, CB=%p, offCB=%ld, C=%p, offC=%ld, S=%p, offS=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        CA, offCA, CB, offCB, C, offC, S, offS, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    cl_mem CA_native = nullptr;
    size_t offCA_native = 0;
    cl_mem CB_native = nullptr;
    size_t offCB_native = 0;
    cl_mem C_native = nullptr;
    size_t offC_native = 0;
    cl_mem S_native = nullptr;
    size_t offS_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    if (!init_cl_mem(env, CA, CA_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offCA_native = (size_t)offCA;
    if (!init_cl_mem(env, CB, CB_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offCB_native = (size_t)offCB;
    if (!init_cl_mem(env, C, C_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offC_native = (size_t)offC;
    if (!init_cl_mem(env, S, S_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offS_native = (size_t)offS;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasCrotg(CA_native, offCA_native, CB_native, offCB_native, C_native, offC_native, S_native, offS_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // CA is a read-only native pointer
    // offCA is primitive
    // CB is a read-only native pointer
    // offCB is primitive
    // C is a read-only native pointer
    // offC is primitive
    // S is a read-only native pointer
    // offS is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* construct givens plane rotation on double-complex elements
*
* @param (out) CA           Buffer object that contains CA
* @param (in) offCA         Offset to CA in \b CA buffer object.
*                          Counted in elements.
* @param (out) CB           Buffer object that contains CB
* @param (in) offCB         Offset to CB in \b CB buffer object.
*                          Counted in elements.
* @param (out) C            Buffer object that contains C. C is real.
* @param (in) offC          Offset to C in \b C buffer object.
*                          Counted in elements.
* @param (out) S            Buffer object that contains S
* @param (in) offS          Offset to S in \b S buffer object.
*                          Counted in elements.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - the same error codes as the clblasDrotg() function otherwise.
*
* @ingroup ROTG
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasZrotgNative(JNIEnv *env, jclass cls, jobject CA, jlong offCA, jobject CB, jlong offCB, jobject C, jlong offC, jobject S, jlong offS, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    if (CA == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'CA' is null for clblasZrotg");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offCA is primitive
    if (CB == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'CB' is null for clblasZrotg");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offCB is primitive
    if (C == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'C' is null for clblasZrotg");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offC is primitive
    if (S == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'S' is null for clblasZrotg");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offS is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasZrotg");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasZrotg(CA=%p, offCA=%ld, CB=%p, offCB=%ld, C=%p, offC=%ld, S=%p, offS=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        CA, offCA, CB, offCB, C, offC, S, offS, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    cl_mem CA_native = nullptr;
    size_t offCA_native = 0;
    cl_mem CB_native = nullptr;
    size_t offCB_native = 0;
    cl_mem C_native = nullptr;
    size_t offC_native = 0;
    cl_mem S_native = nullptr;
    size_t offS_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    if (!init_cl_mem(env, CA, CA_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offCA_native = (size_t)offCA;
    if (!init_cl_mem(env, CB, CB_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offCB_native = (size_t)offCB;
    if (!init_cl_mem(env, C, C_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offC_native = (size_t)offC;
    if (!init_cl_mem(env, S, S_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offS_native = (size_t)offS;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasZrotg(CA_native, offCA_native, CB_native, offCB_native, C_native, offC_native, S_native, offS_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // CA is a read-only native pointer
    // offCA is primitive
    // CB is a read-only native pointer
    // offCB is primitive
    // C is a read-only native pointer
    // offC is primitive
    // S is a read-only native pointer
    // offS is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**@}*/
/**
* <pre>
* @defgroup ROTMG ROTMG  - Constructs the modified givens rotation
* @ingroup BLAS1
* </pre>
*/
/**@{*/
/**
* <pre>
* construct the modified givens rotation on float elements
*
* @param (out) SD1          Buffer object that contains SD1
* @param (in) offSD1        Offset to SD1 in \b SD1 buffer object.
*                          Counted in elements.
* @param (out) SD2          Buffer object that contains SD2
* @param (in) offSD2        Offset to SD2 in \b SD2 buffer object.
*                          Counted in elements.
* @param (out) SX1          Buffer object that contains SX1
* @param (in) offSX1        Offset to SX1 in \b SX1 buffer object.
*                          Counted in elements.
* @param (in) SY1           Buffer object that contains SY1
* @param (in) offSY1        Offset to SY1 in \b SY1 buffer object.
*                          Counted in elements.
* @param (out) SPARAM       Buffer object that contains SPARAM array of minimum length 5
SPARAM(0) = SFLAG
SPARAM(1) = SH11
SPARAM(2) = SH21
SPARAM(3) = SH12
SPARAM(4) = SH22

* @param (in) offSparam     Offset to SPARAM in \b SPARAM buffer object.
*                          Counted in elements.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasNotInitialized if clblasSetup() was not called;
*   - \b clblasInvalidMemObject if either \b SX1, \b SY1, \b SD1, \b SD2 or \b SPARAM object is
*     Invalid, or an image object rather than the buffer one;
*   - \b clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   - \b clblasInvalidCommandQueue if the passed command queue is invalid;
*   - \b clblasInvalidContext if a context a passed command queue belongs
*     to was released;
*   - \b clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   - \b clblasCompilerNotAvailable if a compiler is not available;
*   - \b clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
* @ingroup ROTMG
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasSrotmgNative(JNIEnv *env, jclass cls, jobject SD1, jlong offSD1, jobject SD2, jlong offSD2, jobject SX1, jlong offSX1, jobject SY1, jlong offSY1, jobject SPARAM, jlong offSparam, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    if (SD1 == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'SD1' is null for clblasSrotmg");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offSD1 is primitive
    if (SD2 == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'SD2' is null for clblasSrotmg");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offSD2 is primitive
    if (SX1 == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'SX1' is null for clblasSrotmg");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offSX1 is primitive
    if (SY1 == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'SY1' is null for clblasSrotmg");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offSY1 is primitive
    if (SPARAM == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'SPARAM' is null for clblasSrotmg");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offSparam is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasSrotmg");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasSrotmg(SD1=%p, offSD1=%ld, SD2=%p, offSD2=%ld, SX1=%p, offSX1=%ld, SY1=%p, offSY1=%ld, SPARAM=%p, offSparam=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        SD1, offSD1, SD2, offSD2, SX1, offSX1, SY1, offSY1, SPARAM, offSparam, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    cl_mem SD1_native = nullptr;
    size_t offSD1_native = 0;
    cl_mem SD2_native = nullptr;
    size_t offSD2_native = 0;
    cl_mem SX1_native = nullptr;
    size_t offSX1_native = 0;
    cl_mem SY1_native = nullptr;
    size_t offSY1_native = 0;
    cl_mem SPARAM_native = nullptr;
    size_t offSparam_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    if (!init_cl_mem(env, SD1, SD1_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offSD1_native = (size_t)offSD1;
    if (!init_cl_mem(env, SD2, SD2_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offSD2_native = (size_t)offSD2;
    if (!init_cl_mem(env, SX1, SX1_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offSX1_native = (size_t)offSX1;
    if (!init_cl_mem(env, SY1, SY1_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offSY1_native = (size_t)offSY1;
    if (!init_cl_mem(env, SPARAM, SPARAM_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offSparam_native = (size_t)offSparam;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasSrotmg(SD1_native, offSD1_native, SD2_native, offSD2_native, SX1_native, offSX1_native, SY1_native, offSY1_native, SPARAM_native, offSparam_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // SD1 is a read-only native pointer
    // offSD1 is primitive
    // SD2 is a read-only native pointer
    // offSD2 is primitive
    // SX1 is a read-only native pointer
    // offSX1 is primitive
    // SY1 is a read-only native pointer
    // offSY1 is primitive
    // SPARAM is a read-only native pointer
    // offSparam is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* @example example_srotmg.c
* Example of how to use the @ref clblasSrotmg function.
* </pre>
*/
/**
* <pre>
* construct the modified givens rotation on double elements
*
* @param (out) DD1          Buffer object that contains DD1
* @param (in) offDD1        Offset to DD1 in \b DD1 buffer object.
*                          Counted in elements.
* @param (out) DD2          Buffer object that contains DD2
* @param (in) offDD2        Offset to DD2 in \b DD2 buffer object.
*                          Counted in elements.
* @param (out) DX1          Buffer object that contains DX1
* @param (in) offDX1        Offset to DX1 in \b DX1 buffer object.
*                          Counted in elements.
* @param (in) DY1           Buffer object that contains DY1
* @param (in) offDY1        Offset to DY1 in \b DY1 buffer object.
*                          Counted in elements.
* @param (out) DPARAM       Buffer object that contains DPARAM array of minimum length 5
DPARAM(0) = DFLAG
DPARAM(1) = DH11
DPARAM(2) = DH21
DPARAM(3) = DH12
DPARAM(4) = DH22

* @param (in) offDparam     Offset to DPARAM in \b DPARAM buffer object.
*                          Counted in elements.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasInvalidDevice if a target device does not support the
*     floating point arithmetic with double precision;
*   - the same error codes as the clblasSrotmg() function otherwise.
*
* @ingroup ROTMG
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasDrotmgNative(JNIEnv *env, jclass cls, jobject DD1, jlong offDD1, jobject DD2, jlong offDD2, jobject DX1, jlong offDX1, jobject DY1, jlong offDY1, jobject DPARAM, jlong offDparam, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    if (DD1 == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'DD1' is null for clblasDrotmg");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offDD1 is primitive
    if (DD2 == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'DD2' is null for clblasDrotmg");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offDD2 is primitive
    if (DX1 == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'DX1' is null for clblasDrotmg");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offDX1 is primitive
    if (DY1 == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'DY1' is null for clblasDrotmg");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offDY1 is primitive
    if (DPARAM == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'DPARAM' is null for clblasDrotmg");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offDparam is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasDrotmg");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasDrotmg(DD1=%p, offDD1=%ld, DD2=%p, offDD2=%ld, DX1=%p, offDX1=%ld, DY1=%p, offDY1=%ld, DPARAM=%p, offDparam=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        DD1, offDD1, DD2, offDD2, DX1, offDX1, DY1, offDY1, DPARAM, offDparam, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    cl_mem DD1_native = nullptr;
    size_t offDD1_native = 0;
    cl_mem DD2_native = nullptr;
    size_t offDD2_native = 0;
    cl_mem DX1_native = nullptr;
    size_t offDX1_native = 0;
    cl_mem DY1_native = nullptr;
    size_t offDY1_native = 0;
    cl_mem DPARAM_native = nullptr;
    size_t offDparam_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    if (!init_cl_mem(env, DD1, DD1_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offDD1_native = (size_t)offDD1;
    if (!init_cl_mem(env, DD2, DD2_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offDD2_native = (size_t)offDD2;
    if (!init_cl_mem(env, DX1, DX1_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offDX1_native = (size_t)offDX1;
    if (!init_cl_mem(env, DY1, DY1_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offDY1_native = (size_t)offDY1;
    if (!init_cl_mem(env, DPARAM, DPARAM_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offDparam_native = (size_t)offDparam;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasDrotmg(DD1_native, offDD1_native, DD2_native, offDD2_native, DX1_native, offDX1_native, DY1_native, offDY1_native, DPARAM_native, offDparam_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // DD1 is a read-only native pointer
    // offDD1 is primitive
    // DD2 is a read-only native pointer
    // offDD2 is primitive
    // DX1 is a read-only native pointer
    // offDX1 is primitive
    // DY1 is a read-only native pointer
    // offDY1 is primitive
    // DPARAM is a read-only native pointer
    // offDparam is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**@}*/
/**
* <pre>
* @defgroup ROT ROT  - Apply givens rotation
* @ingroup BLAS1
* </pre>
*/
/**@{*/
/**
* <pre>
* applies a plane rotation for float elements
*
* @param (in) N         Number of elements in vector \b X and \b Y.
* @param (out) X        Buffer object storing vector \b X.
* @param (in) offx      Offset of first element of vector \b X in buffer object.
*                      Counted in elements.
* @param (in) incx      Increment for the elements of \b X. Must not be zero.
* @param (out) Y        Buffer object storing the vector \b Y.
* @param (in) offy      Offset of first element of vector \b Y in buffer object.
*                      Counted in elements.
* @param (in) incy      Increment for the elements of \b Y. Must not be zero.
* @param (in) C         C specifies the cosine, cos.
* @param (in) S         S specifies the sine, sin.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasNotInitialized if clblasSetup() was not called;
*   - \b clblasInvalidValue if invalid parameters are passed:
*     - \b N is zero, or
*     - either \b incx or \b incy is zero, or
*     - the vector sizes along with the increments lead to
*       accessing outside of any of the buffers;
*   - \b clblasInvalidMemObject if either \b X, or \b Y object is
*     Invalid, or an image object rather than the buffer one;
*   - \b clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   - \b clblasInvalidCommandQueue if the passed command queue is invalid;
*   - \b clblasInvalidContext if a context a passed command queue belongs
*     to was released;
*   - \b clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   - \b clblasCompilerNotAvailable if a compiler is not available;
*   - \b clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
* @ingroup ROT
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasSrotNative(JNIEnv *env, jclass cls, jlong N, jobject X, jlong offx, jint incx, jobject Y, jlong offy, jint incy, jfloat C, jfloat S, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasSrot");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (Y == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasSrot");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    // C is primitive
    // S is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasSrot");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasSrot(N=%ld, X=%p, offx=%ld, incx=%d, Y=%p, offy=%ld, incy=%d, C=%f, S=%f, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, X, offx, incx, Y, offy, incy, C, S, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_float C_native;
    cl_float S_native;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    N_native = (size_t)N;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_cl_mem(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    C_native = (cl_float)C;
    S_native = (cl_float)S;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasSrot(N_native, X_native, offx_native, incx_native, Y_native, offy_native, incy_native, C_native, S_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // C is primitive
    // S is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* @example example_srot.c
* Example of how to use the @ref clblasSrot function.
* </pre>
*/
/**
* <pre>
* applies a plane rotation for double elements
*
* @param (in) N         Number of elements in vector \b X and \b Y.
* @param (out) X        Buffer object storing vector \b X.
* @param (in) offx      Offset of first element of vector \b X in buffer object.
*                      Counted in elements.
* @param (in) incx      Increment for the elements of \b X. Must not be zero.
* @param (out) Y        Buffer object storing the vector \b Y.
* @param (in) offy      Offset of first element of vector \b Y in buffer object.
*                      Counted in elements.
* @param (in) incy      Increment for the elements of \b Y. Must not be zero.
* @param (in) C         C specifies the cosine, cos.
* @param (in) S         S specifies the sine, sin.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasInvalidDevice if a target device does not support the
*     floating point arithmetic with double precision;
*   - the same error codes as the clblasSrot() function otherwise.
*
* @ingroup ROT
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasDrotNative(JNIEnv *env, jclass cls, jlong N, jobject X, jlong offx, jint incx, jobject Y, jlong offy, jint incy, jdouble C, jdouble S, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasDrot");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (Y == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasDrot");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    // C is primitive
    // S is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasDrot");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasDrot(N=%ld, X=%p, offx=%ld, incx=%d, Y=%p, offy=%ld, incy=%d, C=%lf, S=%lf, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, X, offx, incx, Y, offy, incy, C, S, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_double C_native;
    cl_double S_native;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    N_native = (size_t)N;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_cl_mem(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    C_native = (cl_double)C;
    S_native = (cl_double)S;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasDrot(N_native, X_native, offx_native, incx_native, Y_native, offy_native, incy_native, C_native, S_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // C is primitive
    // S is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* applies a plane rotation for float-complex elements
*
* @param (in) N         Number of elements in vector \b X and \b Y.
* @param (out) X        Buffer object storing vector \b X.
* @param (in) offx      Offset of first element of vector \b X in buffer object.
*                      Counted in elements.
* @param (in) incx      Increment for the elements of \b X. Must not be zero.
* @param (out) Y        Buffer object storing the vector \b Y.
* @param (in) offy      Offset of first element of vector \b Y in buffer object.
*                      Counted in elements.
* @param (in) incy      Increment for the elements of \b Y. Must not be zero.
* @param (in) C         C specifies the cosine, cos. This number is real
* @param (in) S         S specifies the sine, sin. This number is real
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - the same error codes as the clblasSrot() function otherwise.
*
* @ingroup ROT
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasCsrotNative(JNIEnv *env, jclass cls, jlong N, jobject X, jlong offx, jint incx, jobject Y, jlong offy, jint incy, jfloat C, jfloat S, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasCsrot");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (Y == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasCsrot");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    // C is primitive
    // S is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasCsrot");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasCsrot(N=%ld, X=%p, offx=%ld, incx=%d, Y=%p, offy=%ld, incy=%d, C=%f, S=%f, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, X, offx, incx, Y, offy, incy, C, S, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_float C_native;
    cl_float S_native;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    N_native = (size_t)N;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_cl_mem(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    C_native = (cl_float)C;
    S_native = (cl_float)S;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasCsrot(N_native, X_native, offx_native, incx_native, Y_native, offy_native, incy_native, C_native, S_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // C is primitive
    // S is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* applies a plane rotation for double-complex elements
*
* @param (in) N         Number of elements in vector \b X and \b Y.
* @param (out) X        Buffer object storing vector \b X.
* @param (in) offx      Offset of first element of vector \b X in buffer object.
*                      Counted in elements.
* @param (in) incx      Increment for the elements of \b X. Must not be zero.
* @param (out) Y        Buffer object storing the vector \b Y.
* @param (in) offy      Offset of first element of vector \b Y in buffer object.
*                      Counted in elements.
* @param (in) incy      Increment for the elements of \b Y. Must not be zero.
* @param (in) C         C specifies the cosine, cos. This number is real
* @param (in) S         S specifies the sine, sin. This number is real
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasInvalidDevice if a target device does not support the
*     floating point arithmetic with double precision;
*   - the same error codes as the clblasSrot() function otherwise.
*
* @ingroup ROT
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasZdrotNative(JNIEnv *env, jclass cls, jlong N, jobject X, jlong offx, jint incx, jobject Y, jlong offy, jint incy, jdouble C, jdouble S, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasZdrot");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (Y == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasZdrot");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    // C is primitive
    // S is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasZdrot");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasZdrot(N=%ld, X=%p, offx=%ld, incx=%d, Y=%p, offy=%ld, incy=%d, C=%lf, S=%lf, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, X, offx, incx, Y, offy, incy, C, S, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_double C_native;
    cl_double S_native;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    N_native = (size_t)N;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_cl_mem(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    C_native = (cl_double)C;
    S_native = (cl_double)S;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasZdrot(N_native, X_native, offx_native, incx_native, Y_native, offy_native, incy_native, C_native, S_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // C is primitive
    // S is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**@}*/
/**
* <pre>
* @defgroup ROTM ROTM  - Apply modified givens rotation for points in the plane
* @ingroup BLAS1
* </pre>
*/
/**@{*/
/**
* <pre>
* modified givens rotation for float elements
*
* @param (in) N         Number of elements in vector \b X and \b Y.
* @param (out) X        Buffer object storing vector \b X.
* @param (in) offx      Offset of first element of vector \b X in buffer object.
*                      Counted in elements.
* @param (in) incx      Increment for the elements of \b X. Must not be zero.
* @param (out) Y        Buffer object storing the vector \b Y.
* @param (in) offy      Offset of first element of vector \b Y in buffer object.
*                      Counted in elements.
* @param (in) incy      Increment for the elements of \b Y. Must not be zero.
* @param (in) SPARAM    Buffer object that contains SPARAM array of minimum length 5
*                      SPARAM(1)=SFLAG
*                      SPARAM(2)=SH11
*                      SPARAM(3)=SH21
*                      SPARAM(4)=SH12
*                      SPARAM(5)=SH22
* @param (in) offSparam Offset of first element of array \b SPARAM in buffer object.
*                      Counted in elements.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasNotInitialized if clblasSetup() was not called;
*   - \b clblasInvalidValue if invalid parameters are passed:
*     - \b N is zero, or
*     - either \b incx or \b incy is zero, or
*     - the vector sizes along with the increments lead to
*       accessing outside of any of the buffers;
*   - \b clblasInvalidMemObject if either \b X, \b Y or \b SPARAM object is
*     Invalid, or an image object rather than the buffer one;
*   - \b clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   - \b clblasInvalidCommandQueue if the passed command queue is invalid;
*   - \b clblasInvalidContext if a context a passed command queue belongs
*     to was released;
*   - \b clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   - \b clblasCompilerNotAvailable if a compiler is not available;
*   - \b clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
* @ingroup ROTM
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasSrotmNative(JNIEnv *env, jclass cls, jlong N, jobject X, jlong offx, jint incx, jobject Y, jlong offy, jint incy, jobject SPARAM, jlong offSparam, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasSrotm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (Y == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasSrotm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    if (SPARAM == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'SPARAM' is null for clblasSrotm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offSparam is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasSrotm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasSrotm(N=%ld, X=%p, offx=%ld, incx=%d, Y=%p, offy=%ld, incy=%d, SPARAM=%p, offSparam=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, X, offx, incx, Y, offy, incy, SPARAM, offSparam, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_mem SPARAM_native = nullptr;
    size_t offSparam_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    N_native = (size_t)N;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_cl_mem(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    if (!init_cl_mem(env, SPARAM, SPARAM_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offSparam_native = (size_t)offSparam;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasSrotm(N_native, X_native, offx_native, incx_native, Y_native, offy_native, incy_native, SPARAM_native, offSparam_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // SPARAM is a read-only native pointer
    // offSparam is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* @example example_srotm.c
* Example of how to use the @ref clblasSrotm function.
* </pre>
*/
/**
* <pre>
* modified givens rotation for double elements
*
* @param (in) N         Number of elements in vector \b X and \b Y.
* @param (out) X        Buffer object storing vector \b X.
* @param (in) offx      Offset of first element of vector \b X in buffer object.
*                      Counted in elements.
* @param (in) incx      Increment for the elements of \b X. Must not be zero.
* @param (out) Y        Buffer object storing the vector \b Y.
* @param (in) offy      Offset of first element of vector \b Y in buffer object.
*                      Counted in elements.
* @param (in) incy      Increment for the elements of \b Y. Must not be zero.
* @param (in) DPARAM    Buffer object that contains SPARAM array of minimum length 5
*                      DPARAM(1)=DFLAG
*                      DPARAM(2)=DH11
*                      DPARAM(3)=DH21
*                      DPARAM(4)=DH12
*                      DPARAM(5)=DH22
* @param (in) offDparam Offset of first element of array \b DPARAM in buffer object.
*                      Counted in elements.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasInvalidDevice if a target device does not support the
*     floating point arithmetic with double precision;
*   - the same error codes as the clblasSrotm() function otherwise.
*
* @ingroup ROTM
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasDrotmNative(JNIEnv *env, jclass cls, jlong N, jobject X, jlong offx, jint incx, jobject Y, jlong offy, jint incy, jobject DPARAM, jlong offDparam, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasDrotm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (Y == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasDrotm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    if (DPARAM == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'DPARAM' is null for clblasDrotm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offDparam is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasDrotm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasDrotm(N=%ld, X=%p, offx=%ld, incx=%d, Y=%p, offy=%ld, incy=%d, DPARAM=%p, offDparam=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, X, offx, incx, Y, offy, incy, DPARAM, offDparam, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_mem DPARAM_native = nullptr;
    size_t offDparam_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    N_native = (size_t)N;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_cl_mem(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    if (!init_cl_mem(env, DPARAM, DPARAM_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offDparam_native = (size_t)offDparam;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasDrotm(N_native, X_native, offx_native, incx_native, Y_native, offy_native, incy_native, DPARAM_native, offDparam_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // DPARAM is a read-only native pointer
    // offDparam is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**@}*/
/**
* <pre>
* @defgroup NRM2 NRM2  - Euclidean norm of a vector
* @ingroup BLAS1
* </pre>
*/
/**@{*/
/**
* <pre>
* computes the euclidean norm of vector containing float elements
*
*  NRM2 = sqrt( X' * X )
*
* @param (in) N             Number of elements in vector \b X.
* @param (out) NRM2         Buffer object that will contain the NRM2 value
* @param (in) offNRM2       Offset to NRM2 value in \b NRM2 buffer object.
*                          Counted in elements.
* @param (in) X             Buffer object storing vector \b X.
* @param (in) offx          Offset of first element of vector \b X in buffer object.
*                          Counted in elements.
* @param (in) incx          Increment for the elements of \b X. Must not be zero.
* @param (in) scratchBuff	Temporary cl_mem scratch buffer object that can hold minimum of (2*N) elements
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasNotInitialized if clblasSetup() was not called;
*   - \b clblasInvalidValue if invalid parameters are passed:
*     - \b N is zero, or
*     - either \b incx is zero, or
*     - the vector sizes along with the increments lead to
*       accessing outside of any of the buffers;
*   - \b clblasInvalidMemObject if any of \b X or \b NRM2 or \b scratchBuff object is
*     Invalid, or an image object rather than the buffer one;
*   - \b clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   - \b clblasInvalidCommandQueue if the passed command queue is invalid;
*   - \b clblasInvalidContext if a context a passed command queue belongs
*     to was released;
*   - \b clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   - \b clblasCompilerNotAvailable if a compiler is not available;
*   - \b clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
* @ingroup NRM2
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasSnrm2Native(JNIEnv *env, jclass cls, jlong N, jobject NRM2, jlong offNRM2, jobject X, jlong offx, jint incx, jobject scratchBuff, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    if (NRM2 == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'NRM2' is null for clblasSnrm2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offNRM2 is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasSnrm2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (scratchBuff == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'scratchBuff' is null for clblasSnrm2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasSnrm2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasSnrm2(N=%ld, NRM2=%p, offNRM2=%ld, X=%p, offx=%ld, incx=%d, scratchBuff=%p, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, NRM2, offNRM2, X, offx, incx, scratchBuff, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_mem NRM2_native = nullptr;
    size_t offNRM2_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem scratchBuff_native = nullptr;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    N_native = (size_t)N;
    if (!init_cl_mem(env, NRM2, NRM2_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offNRM2_native = (size_t)offNRM2;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_cl_mem(env, scratchBuff, scratchBuff_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasSnrm2(N_native, NRM2_native, offNRM2_native, X_native, offx_native, incx_native, scratchBuff_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    // NRM2 is a read-only native pointer
    // offNRM2 is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // scratchBuff is a read-only native pointer
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* @example example_snrm2.c
* Example of how to use the @ref clblasSnrm2 function.
* </pre>
*/
/**
* <pre>
* computes the euclidean norm of vector containing double elements
*
*  NRM2 = sqrt( X' * X )
*
* @param (in) N             Number of elements in vector \b X.
* @param (out) NRM2         Buffer object that will contain the NRM2 value
* @param (in) offNRM2       Offset to NRM2 value in \b NRM2 buffer object.
*                          Counted in elements.
* @param (in) X             Buffer object storing vector \b X.
* @param (in) offx          Offset of first element of vector \b X in buffer object.
*                          Counted in elements.
* @param (in) incx          Increment for the elements of \b X. Must not be zero.
* @param (in) scratchBuff	Temporary cl_mem scratch buffer object that can hold minimum of (2*N) elements
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasInvalidDevice if a target device does not support the
*     floating point arithmetic with double precision;
*   - the same error codes as the clblasSnrm2() function otherwise.
*
* @ingroup NRM2
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasDnrm2Native(JNIEnv *env, jclass cls, jlong N, jobject NRM2, jlong offNRM2, jobject X, jlong offx, jint incx, jobject scratchBuff, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    if (NRM2 == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'NRM2' is null for clblasDnrm2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offNRM2 is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasDnrm2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (scratchBuff == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'scratchBuff' is null for clblasDnrm2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasDnrm2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasDnrm2(N=%ld, NRM2=%p, offNRM2=%ld, X=%p, offx=%ld, incx=%d, scratchBuff=%p, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, NRM2, offNRM2, X, offx, incx, scratchBuff, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_mem NRM2_native = nullptr;
    size_t offNRM2_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem scratchBuff_native = nullptr;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    N_native = (size_t)N;
    if (!init_cl_mem(env, NRM2, NRM2_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offNRM2_native = (size_t)offNRM2;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_cl_mem(env, scratchBuff, scratchBuff_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasDnrm2(N_native, NRM2_native, offNRM2_native, X_native, offx_native, incx_native, scratchBuff_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    // NRM2 is a read-only native pointer
    // offNRM2 is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // scratchBuff is a read-only native pointer
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* computes the euclidean norm of vector containing float-complex elements
*
*  NRM2 = sqrt( X**H * X )
*
* @param (in) N             Number of elements in vector \b X.
* @param (out) NRM2         Buffer object that will contain the NRM2 value.
*                          Note that the answer of Scnrm2 is a real value.
* @param (in) offNRM2       Offset to NRM2 value in \b NRM2 buffer object.
*                          Counted in elements.
* @param (in) X             Buffer object storing vector \b X.
* @param (in) offx          Offset of first element of vector \b X in buffer object.
*                          Counted in elements.
* @param (in) incx          Increment for the elements of \b X. Must not be zero.
* @param (in) scratchBuff	Temporary cl_mem scratch buffer object that can hold minimum of (2*N) elements
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - the same error codes as the clblasSnrm2() function otherwise.
*
* @ingroup NRM2
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasScnrm2Native(JNIEnv *env, jclass cls, jlong N, jobject NRM2, jlong offNRM2, jobject X, jlong offx, jint incx, jobject scratchBuff, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    if (NRM2 == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'NRM2' is null for clblasScnrm2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offNRM2 is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasScnrm2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (scratchBuff == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'scratchBuff' is null for clblasScnrm2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasScnrm2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasScnrm2(N=%ld, NRM2=%p, offNRM2=%ld, X=%p, offx=%ld, incx=%d, scratchBuff=%p, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, NRM2, offNRM2, X, offx, incx, scratchBuff, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_mem NRM2_native = nullptr;
    size_t offNRM2_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem scratchBuff_native = nullptr;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    N_native = (size_t)N;
    if (!init_cl_mem(env, NRM2, NRM2_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offNRM2_native = (size_t)offNRM2;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_cl_mem(env, scratchBuff, scratchBuff_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasScnrm2(N_native, NRM2_native, offNRM2_native, X_native, offx_native, incx_native, scratchBuff_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    // NRM2 is a read-only native pointer
    // offNRM2 is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // scratchBuff is a read-only native pointer
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* computes the euclidean norm of vector containing double-complex elements
*
*  NRM2 = sqrt( X**H * X )
*
* @param (in) N             Number of elements in vector \b X.
* @param (out) NRM2         Buffer object that will contain the NRM2 value.
*                          Note that the answer of Dznrm2 is a real value.
* @param (in) offNRM2       Offset to NRM2 value in \b NRM2 buffer object.
*                          Counted in elements.
* @param (in) X             Buffer object storing vector \b X.
* @param (in) offx          Offset of first element of vector \b X in buffer object.
*                          Counted in elements.
* @param (in) incx          Increment for the elements of \b X. Must not be zero.
* @param (in) scratchBuff	Temporary cl_mem scratch buffer object that can hold minimum of (2*N) elements
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasInvalidDevice if a target device does not support the
*     floating point arithmetic with double precision;
*   - the same error codes as the clblasSnrm2() function otherwise.
*     executable.
*
* @ingroup NRM2
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasDznrm2Native(JNIEnv *env, jclass cls, jlong N, jobject NRM2, jlong offNRM2, jobject X, jlong offx, jint incx, jobject scratchBuff, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    if (NRM2 == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'NRM2' is null for clblasDznrm2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offNRM2 is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasDznrm2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (scratchBuff == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'scratchBuff' is null for clblasDznrm2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasDznrm2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasDznrm2(N=%ld, NRM2=%p, offNRM2=%ld, X=%p, offx=%ld, incx=%d, scratchBuff=%p, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, NRM2, offNRM2, X, offx, incx, scratchBuff, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_mem NRM2_native = nullptr;
    size_t offNRM2_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem scratchBuff_native = nullptr;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    N_native = (size_t)N;
    if (!init_cl_mem(env, NRM2, NRM2_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offNRM2_native = (size_t)offNRM2;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_cl_mem(env, scratchBuff, scratchBuff_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasDznrm2(N_native, NRM2_native, offNRM2_native, X_native, offx_native, incx_native, scratchBuff_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    // NRM2 is a read-only native pointer
    // offNRM2 is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // scratchBuff is a read-only native pointer
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**@}*/
/**
* <pre>
* @defgroup iAMAX iAMAX  - Index of max absolute value
* @ingroup BLAS1
* </pre>
*/
/**@{*/
/**
* <pre>
* index of max absolute value in a float array
*
* @param (in) N             Number of elements in vector \b X.
* @param (out) iMax         Buffer object storing the index of first absolute max.
*                          The index will be of type unsigned int
* @param (in) offiMax       Offset for storing index in the buffer iMax
*                          Counted in elements.
* @param (in) X             Buffer object storing vector \b X.
* @param (in) offx          Offset of first element of vector \b X in buffer object.
*                          Counted in elements.
* @param (in) incx          Increment for the elements of \b X. Must not be zero.
* @param (in) scratchBuff   Temprory cl_mem object to store intermediate results
It should be able to hold minimum of (2*N) elements
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasNotInitialized if clblasSetup() was not called;
*   - \b clblasInvalidValue if invalid parameters are passed:
*     - \b N is zero, or
*     - either \b incx is zero, or
*     - the vector sizes along with the increments lead to
*       accessing outside of any of the buffers;
*   - \b clblasInvalidMemObject if any of \b iMax \b X or \b scratchBuff object is
*     Invalid, or an image object rather than the buffer one;
*   - \b clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   - \b clblasInvalidCommandQueue if the passed command queue is invalid;
*   - \b clblasInvalidContext if the context, the passed command queue belongs
*     to was released;
*   - \b clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   - \b clblasCompilerNotAvailable if a compiler is not available;
*   - \b clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
* @ingroup iAMAX
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasiSamaxNative(JNIEnv *env, jclass cls, jlong N, jobject iMax, jlong offiMax, jobject X, jlong offx, jint incx, jobject scratchBuff, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    if (iMax == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'iMax' is null for clblasiSamax");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offiMax is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasiSamax");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (scratchBuff == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'scratchBuff' is null for clblasiSamax");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasiSamax");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasiSamax(N=%ld, iMax=%p, offiMax=%ld, X=%p, offx=%ld, incx=%d, scratchBuff=%p, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, iMax, offiMax, X, offx, incx, scratchBuff, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_mem iMax_native = nullptr;
    size_t offiMax_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem scratchBuff_native = nullptr;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    N_native = (size_t)N;
    if (!init_cl_mem(env, iMax, iMax_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offiMax_native = (size_t)offiMax;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_cl_mem(env, scratchBuff, scratchBuff_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasiSamax(N_native, iMax_native, offiMax_native, X_native, offx_native, incx_native, scratchBuff_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    // iMax is a read-only native pointer
    // offiMax is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // scratchBuff is a read-only native pointer
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* @example example_isamax.c
* Example of how to use the @ref clblasiSamax function.
* </pre>
*/
/**
* <pre>
* index of max absolute value in a double array
*
* @param (in) N             Number of elements in vector \b X.
* @param (out) iMax         Buffer object storing the index of first absolute max.
*                          The index will be of type unsigned int
* @param (in) offiMax       Offset for storing index in the buffer iMax
*                          Counted in elements.
* @param (in) X             Buffer object storing vector \b X.
* @param (in) offx          Offset of first element of vector \b X in buffer object.
*                          Counted in elements.
* @param (in) incx          Increment for the elements of \b X. Must not be zero.
* @param (in) scratchBuff   Temprory cl_mem object to store intermediate results
It should be able to hold minimum of (2*N) elements
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasInvalidDevice if a target device does not support the
*     floating point arithmetic with double precision;
*   - the same error codes as the clblasiSamax() function otherwise.
*
* @ingroup iAMAX
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasiDamaxNative(JNIEnv *env, jclass cls, jlong N, jobject iMax, jlong offiMax, jobject X, jlong offx, jint incx, jobject scratchBuff, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    if (iMax == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'iMax' is null for clblasiDamax");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offiMax is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasiDamax");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (scratchBuff == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'scratchBuff' is null for clblasiDamax");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasiDamax");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasiDamax(N=%ld, iMax=%p, offiMax=%ld, X=%p, offx=%ld, incx=%d, scratchBuff=%p, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, iMax, offiMax, X, offx, incx, scratchBuff, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_mem iMax_native = nullptr;
    size_t offiMax_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem scratchBuff_native = nullptr;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    N_native = (size_t)N;
    if (!init_cl_mem(env, iMax, iMax_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offiMax_native = (size_t)offiMax;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_cl_mem(env, scratchBuff, scratchBuff_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasiDamax(N_native, iMax_native, offiMax_native, X_native, offx_native, incx_native, scratchBuff_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    // iMax is a read-only native pointer
    // offiMax is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // scratchBuff is a read-only native pointer
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* index of max absolute value in a complex float array
*
* @param (in) N             Number of elements in vector \b X.
* @param (out) iMax         Buffer object storing the index of first absolute max.
*                          The index will be of type unsigned int
* @param (in) offiMax       Offset for storing index in the buffer iMax
*                          Counted in elements.
* @param (in) X             Buffer object storing vector \b X.
* @param (in) offx          Offset of first element of vector \b X in buffer object.
*                          Counted in elements.
* @param (in) incx          Increment for the elements of \b X. Must not be zero.
* @param (in) scratchBuff   Temprory cl_mem object to store intermediate results
It should be able to hold minimum of (2*N) elements
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - the same error codes as the clblasiSamax() function otherwise.
*
* @ingroup iAMAX
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasiCamaxNative(JNIEnv *env, jclass cls, jlong N, jobject iMax, jlong offiMax, jobject X, jlong offx, jint incx, jobject scratchBuff, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    if (iMax == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'iMax' is null for clblasiCamax");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offiMax is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasiCamax");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (scratchBuff == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'scratchBuff' is null for clblasiCamax");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasiCamax");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasiCamax(N=%ld, iMax=%p, offiMax=%ld, X=%p, offx=%ld, incx=%d, scratchBuff=%p, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, iMax, offiMax, X, offx, incx, scratchBuff, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_mem iMax_native = nullptr;
    size_t offiMax_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem scratchBuff_native = nullptr;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    N_native = (size_t)N;
    if (!init_cl_mem(env, iMax, iMax_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offiMax_native = (size_t)offiMax;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_cl_mem(env, scratchBuff, scratchBuff_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasiCamax(N_native, iMax_native, offiMax_native, X_native, offx_native, incx_native, scratchBuff_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    // iMax is a read-only native pointer
    // offiMax is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // scratchBuff is a read-only native pointer
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* index of max absolute value in a complex double array
*
* @param (in) N             Number of elements in vector \b X.
* @param (out) iMax         Buffer object storing the index of first absolute max.
*                          The index will be of type unsigned int
* @param (in) offiMax       Offset for storing index in the buffer iMax
*                          Counted in elements.
* @param (in) X             Buffer object storing vector \b X.
* @param (in) offx          Offset of first element of vector \b X in buffer object.
*                          Counted in elements.
* @param (in) incx          Increment for the elements of \b X. Must not be zero.
* @param (in) scratchBuff   Temprory cl_mem object to store intermediate results
It should be able to hold minimum of (2*N) elements
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
* @return
*   - \b clblasSuccess on success;
*   - \b clblasInvalidDevice if a target device does not support the
*     floating point arithmetic with double precision;
*   - the same error codes as the clblasiSamax() function otherwise.
*
* @ingroup iAMAX
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasiZamaxNative(JNIEnv *env, jclass cls, jlong N, jobject iMax, jlong offiMax, jobject X, jlong offx, jint incx, jobject scratchBuff, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    if (iMax == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'iMax' is null for clblasiZamax");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offiMax is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasiZamax");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (scratchBuff == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'scratchBuff' is null for clblasiZamax");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasiZamax");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasiZamax(N=%ld, iMax=%p, offiMax=%ld, X=%p, offx=%ld, incx=%d, scratchBuff=%p, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, iMax, offiMax, X, offx, incx, scratchBuff, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_mem iMax_native = nullptr;
    size_t offiMax_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem scratchBuff_native = nullptr;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    N_native = (size_t)N;
    if (!init_cl_mem(env, iMax, iMax_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offiMax_native = (size_t)offiMax;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_cl_mem(env, scratchBuff, scratchBuff_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasiZamax(N_native, iMax_native, offiMax_native, X_native, offx_native, incx_native, scratchBuff_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    // iMax is a read-only native pointer
    // offiMax is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // scratchBuff is a read-only native pointer
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**@}*/
/**
* <pre>
* @defgroup ASUM ASUM  - Sum of absolute values
* @ingroup BLAS1
* </pre>
*/
/**@{*/
/**
* <pre>
* absolute sum of values of a vector containing float elements
*
* @param (in) N             Number of elements in vector \b X.
* @param (out) asum         Buffer object that will contain the absoule sum value
* @param (in) offAsum       Offset to absolute sum in \b asum buffer object.
*                          Counted in elements.
* @param (in) X             Buffer object storing vector \b X.
* @param (in) offx          Offset of first element of vector \b X in buffer object.
*                          Counted in elements.
* @param (in) incx          Increment for the elements of \b X. Must not be zero.
* @param (in) scratchBuff   Temporary cl_mem scratch buffer object of minimum size N
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasNotInitialized if clblasSetup() was not called;
*   - \b clblasInvalidValue if invalid parameters are passed:
*     - \b N is zero, or
*     - either \b incx is zero, or
*     - the vector sizes along with the increments lead to
*       accessing outside of any of the buffers;
*   - \b clblasInvalidMemObject if any of \b X or \b asum or \b scratchBuff object is
*     Invalid, or an image object rather than the buffer one;
*   - \b clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   - \b clblasInvalidCommandQueue if the passed command queue is invalid;
*   - \b clblasInvalidContext if a context a passed command queue belongs
*     to was released;
*   - \b clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   - \b clblasCompilerNotAvailable if a compiler is not available;
*   - \b clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
* @ingroup ASUM
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasSasumNative(JNIEnv *env, jclass cls, jlong N, jobject asum, jlong offAsum, jobject X, jlong offx, jint incx, jobject scratchBuff, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    if (asum == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'asum' is null for clblasSasum");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offAsum is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasSasum");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (scratchBuff == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'scratchBuff' is null for clblasSasum");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasSasum");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasSasum(N=%ld, asum=%p, offAsum=%ld, X=%p, offx=%ld, incx=%d, scratchBuff=%p, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, asum, offAsum, X, offx, incx, scratchBuff, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_mem asum_native = nullptr;
    size_t offAsum_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem scratchBuff_native = nullptr;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    N_native = (size_t)N;
    if (!init_cl_mem(env, asum, asum_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offAsum_native = (size_t)offAsum;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_cl_mem(env, scratchBuff, scratchBuff_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasSasum(N_native, asum_native, offAsum_native, X_native, offx_native, incx_native, scratchBuff_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    // asum is a read-only native pointer
    // offAsum is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // scratchBuff is a read-only native pointer
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* @example example_sasum.c
* Example of how to use the @ref clblasSasum function.
* </pre>
*/
/**
* <pre>
* absolute sum of values of a vector containing double elements
*
* @param (in) N             Number of elements in vector \b X.
* @param (out) asum         Buffer object that will contain the absoulte sum value
* @param (in) offAsum       Offset to absoule sum in \b asum buffer object.
*                          Counted in elements.
* @param (in) X             Buffer object storing vector \b X.
* @param (in) offx          Offset of first element of vector \b X in buffer object.
*                          Counted in elements.
* @param (in) incx          Increment for the elements of \b X. Must not be zero.
* @param (in) scratchBuff   Temporary cl_mem scratch buffer object of minimum size N
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasInvalidDevice if a target device does not support the
*     floating point arithmetic with double precision;
*   - the same error codes as the clblasSasum() function otherwise.
*
* @ingroup ASUM
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasDasumNative(JNIEnv *env, jclass cls, jlong N, jobject asum, jlong offAsum, jobject X, jlong offx, jint incx, jobject scratchBuff, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    if (asum == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'asum' is null for clblasDasum");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offAsum is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasDasum");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (scratchBuff == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'scratchBuff' is null for clblasDasum");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasDasum");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasDasum(N=%ld, asum=%p, offAsum=%ld, X=%p, offx=%ld, incx=%d, scratchBuff=%p, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, asum, offAsum, X, offx, incx, scratchBuff, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_mem asum_native = nullptr;
    size_t offAsum_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem scratchBuff_native = nullptr;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    N_native = (size_t)N;
    if (!init_cl_mem(env, asum, asum_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offAsum_native = (size_t)offAsum;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_cl_mem(env, scratchBuff, scratchBuff_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasDasum(N_native, asum_native, offAsum_native, X_native, offx_native, incx_native, scratchBuff_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    // asum is a read-only native pointer
    // offAsum is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // scratchBuff is a read-only native pointer
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* absolute sum of values of a vector containing float-complex elements
*
* @param (in) N             Number of elements in vector \b X.
* @param (out) asum         Buffer object that will contain the absolute sum value
* @param (in) offAsum       Offset to absolute sum in \b asum buffer object.
*                          Counted in elements.
* @param (in) X             Buffer object storing vector \b X.
* @param (in) offx          Offset of first element of vector \b X in buffer object.
*                          Counted in elements.
* @param (in) incx          Increment for the elements of \b X. Must not be zero.
* @param (in) scratchBuff   Temporary cl_mem scratch buffer object of minimum size N
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - the same error codes as the clblasSasum() function otherwise.
*
* @ingroup ASUM
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasScasumNative(JNIEnv *env, jclass cls, jlong N, jobject asum, jlong offAsum, jobject X, jlong offx, jint incx, jobject scratchBuff, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    if (asum == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'asum' is null for clblasScasum");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offAsum is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasScasum");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (scratchBuff == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'scratchBuff' is null for clblasScasum");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasScasum");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasScasum(N=%ld, asum=%p, offAsum=%ld, X=%p, offx=%ld, incx=%d, scratchBuff=%p, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, asum, offAsum, X, offx, incx, scratchBuff, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_mem asum_native = nullptr;
    size_t offAsum_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem scratchBuff_native = nullptr;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    N_native = (size_t)N;
    if (!init_cl_mem(env, asum, asum_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offAsum_native = (size_t)offAsum;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_cl_mem(env, scratchBuff, scratchBuff_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasScasum(N_native, asum_native, offAsum_native, X_native, offx_native, incx_native, scratchBuff_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    // asum is a read-only native pointer
    // offAsum is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // scratchBuff is a read-only native pointer
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* absolute sum of values of a vector containing double-complex elements
*
* @param (in) N             Number of elements in vector \b X.
* @param (out) asum         Buffer object that will contain the absolute sum value
* @param (in) offAsum       Offset to absolute sum in \b asum buffer object.
*                          Counted in elements.
* @param (in) X             Buffer object storing vector \b X.
* @param (in) offx          Offset of first element of vector \b X in buffer object.
*                          Counted in elements.
* @param (in) incx          Increment for the elements of \b X. Must not be zero.
* @param (in) scratchBuff   Temporary cl_mem scratch buffer object of minimum size N
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasInvalidDevice if a target device does not support the
*     floating point arithmetic with double precision;
*   - the same error codes as the clblasSasum() function otherwise.
*
* @ingroup ASUM
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasDzasumNative(JNIEnv *env, jclass cls, jlong N, jobject asum, jlong offAsum, jobject X, jlong offx, jint incx, jobject scratchBuff, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // N is primitive
    if (asum == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'asum' is null for clblasDzasum");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offAsum is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasDzasum");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (scratchBuff == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'scratchBuff' is null for clblasDzasum");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasDzasum");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasDzasum(N=%ld, asum=%p, offAsum=%ld, X=%p, offx=%ld, incx=%d, scratchBuff=%p, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        N, asum, offAsum, X, offx, incx, scratchBuff, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t N_native = 0;
    cl_mem asum_native = nullptr;
    size_t offAsum_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem scratchBuff_native = nullptr;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    N_native = (size_t)N;
    if (!init_cl_mem(env, asum, asum_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offAsum_native = (size_t)offAsum;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_cl_mem(env, scratchBuff, scratchBuff_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasDzasum(N_native, asum_native, offAsum_native, X_native, offx_native, incx_native, scratchBuff_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // N is primitive
    // asum is a read-only native pointer
    // offAsum is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // scratchBuff is a read-only native pointer
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**@}*/
/**
* <pre>
* @defgroup BLAS2 BLAS-2 functions
*
* The Level 2 Basic Linear Algebra Subprograms are functions that perform
* matrix-vector operations.
* </pre>
*/
/**@{*/
/**@}*/
/**
* <pre>
* @defgroup GEMV GEMV  - General matrix-Vector multiplication
* @ingroup BLAS2
* </pre>
*/
/**@{*/
/**
* <pre>
* Matrix-vector product with a general rectangular matrix and
*        float elements. Extended version.
*
* Matrix-vector products:
*   - \f$ y \leftarrow \alpha A x + \beta y \f$
*   - \f$ y \leftarrow \alpha A^T x + \beta y \f$
*
* @param (in) order     Row/column order.
* @param (in) transA    How matrix \b A is to be transposed.
* @param (in) M         Number of rows in matrix \b A.
* @param (in) N         Number of columns in matrix \b A.
* @param (in) alpha     The factor of matrix \b A.
* @param (in) A         Buffer object storing matrix \b A.
* @param (in) offA      Offset of the first element of the matrix \b A in
*                      the buffer object. Counted in elements.
* @param (in) lda       Leading dimension of matrix \b A. It cannot be less
*                      than \b N when the \b order parameter is set to
*                      \b clblasRowMajor,\n or less than \b M when the
*                      parameter is set to \b clblasColumnMajor.
* @param (in) x         Buffer object storing vector \b x.
* @param (in) offx      Offset of first element of vector \b x in buffer object.
*                      Counted in elements.
* @param (in) incx      Increment for the elements of \b x. It cannot be zero.
* @param (in) beta      The factor of the vector \b y.
* @param (out) y        Buffer object storing the vector \b y.
* @param (in) offy      Offset of first element of vector \b y in buffer object.
*                      Counted in elements.
* @param (in) incy      Increment for the elements of \b y. It cannot be zero.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasInvalidValue if \b offA exceeds the size of \b A buffer
*     object;
*   - the same error codes as the clblasSgemv() function otherwise.
*
* @ingroup GEMV
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasSgemvNative(JNIEnv *env, jclass cls, jint order, jint transA, jlong M, jlong N, jfloat alpha, jobject A, jlong offA, jlong lda, jobject x, jlong offx, jint incx, jfloat beta, jobject y, jlong offy, jint incy, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // transA is primitive
    // M is primitive
    // N is primitive
    // alpha is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasSgemv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // lda is primitive
    if (x == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'x' is null for clblasSgemv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    // beta is primitive
    if (y == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'y' is null for clblasSgemv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasSgemv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasSgemv(order=%d, transA=%d, M=%ld, N=%ld, alpha=%f, A=%p, offA=%ld, lda=%ld, x=%p, offx=%ld, incx=%d, beta=%f, y=%p, offy=%ld, incy=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, transA, M, N, alpha, A, offA, lda, x, offx, incx, beta, y, offy, incy, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasTranspose transA_native;
    size_t M_native = 0;
    size_t N_native = 0;
    cl_float alpha_native;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    size_t lda_native = 0;
    cl_mem x_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_float beta_native;
    cl_mem y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    transA_native = (clblasTranspose)transA;
    M_native = (size_t)M;
    N_native = (size_t)N;
    alpha_native = (cl_float)alpha;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    lda_native = (size_t)lda;
    if (!init_cl_mem(env, x, x_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    beta_native = (cl_float)beta;
    if (!init_cl_mem(env, y, y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasSgemv(order_native, transA_native, M_native, N_native, alpha_native, A_native, offA_native, lda_native, x_native, offx_native, incx_native, beta_native, y_native, offy_native, incy_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // transA is primitive
    // M is primitive
    // N is primitive
    // alpha is primitive
    // A is a read-only native pointer
    // offA is primitive
    // lda is primitive
    // x is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // beta is primitive
    // y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* @example example_sgemv.c
* This is an example of how to use the @ref clblasSgemvEx function.
* </pre>
*/
/**
* <pre>
* Matrix-vector product with a general rectangular matrix and
*        double elements. Extended version.
*
* Matrix-vector products:
*   - \f$ y \leftarrow \alpha A x + \beta y \f$
*   - \f$ y \leftarrow \alpha A^T x + \beta y \f$
*
* @param (in) order     Row/column order.
* @param (in) transA    How matrix \b A is to be transposed.
* @param (in) M         Number of rows in matrix \b A.
* @param (in) N         Number of columns in matrix \b A.
* @param (in) alpha     The factor of matrix \b A.
* @param (in) A         Buffer object storing matrix \b A.
* @param (in) offA      Offset of the first element of \b A in the buffer
*                      object. Counted in elements.
* @param (in) lda       Leading dimension of matrix \b A. For a detailed description,
*                      see clblasSgemv().
* @param (in) x         Buffer object storing vector \b x.
* @param (in) offx      Offset of first element of vector \b x in buffer object.
*                      Counted in elements.
* @param (in) incx      Increment for the elements of \b x. It cannot be zero.
* @param (in) beta      The factor of the vector \b y.
* @param (out) y        Buffer object storing the vector \b y.
* @param (in) offy      Offset of first element of vector \b y in buffer object.
*                      Counted in elements.
* @param (in) incy      Increment for the elements of \b y. It cannot be zero.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasInvalidDevice if a target device does not support the
*     floating point arithmetic with double precision;
*   - \b clblasInvalidValue if \b offA exceeds the size of \b A buffer
*     object;
*   - the same error codes as the clblasSgemv() function otherwise.
*
* @ingroup GEMV
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasDgemvNative(JNIEnv *env, jclass cls, jint order, jint transA, jlong M, jlong N, jdouble alpha, jobject A, jlong offA, jlong lda, jobject x, jlong offx, jint incx, jdouble beta, jobject y, jlong offy, jint incy, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // transA is primitive
    // M is primitive
    // N is primitive
    // alpha is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasDgemv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // lda is primitive
    if (x == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'x' is null for clblasDgemv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    // beta is primitive
    if (y == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'y' is null for clblasDgemv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasDgemv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasDgemv(order=%d, transA=%d, M=%ld, N=%ld, alpha=%lf, A=%p, offA=%ld, lda=%ld, x=%p, offx=%ld, incx=%d, beta=%lf, y=%p, offy=%ld, incy=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, transA, M, N, alpha, A, offA, lda, x, offx, incx, beta, y, offy, incy, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasTranspose transA_native;
    size_t M_native = 0;
    size_t N_native = 0;
    cl_double alpha_native;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    size_t lda_native = 0;
    cl_mem x_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_double beta_native;
    cl_mem y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    transA_native = (clblasTranspose)transA;
    M_native = (size_t)M;
    N_native = (size_t)N;
    alpha_native = (cl_double)alpha;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    lda_native = (size_t)lda;
    if (!init_cl_mem(env, x, x_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    beta_native = (cl_double)beta;
    if (!init_cl_mem(env, y, y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasDgemv(order_native, transA_native, M_native, N_native, alpha_native, A_native, offA_native, lda_native, x_native, offx_native, incx_native, beta_native, y_native, offy_native, incy_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // transA is primitive
    // M is primitive
    // N is primitive
    // alpha is primitive
    // A is a read-only native pointer
    // offA is primitive
    // lda is primitive
    // x is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // beta is primitive
    // y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* Matrix-vector product with a general rectangular matrix and
*        float complex elements. Extended version.
*
* Matrix-vector products:
*   - \f$ y \leftarrow \alpha A x + \beta y \f$
*   - \f$ y \leftarrow \alpha A^T x + \beta y \f$
*
* @param (in) order     Row/column order.
* @param (in) transA    How matrix \b A is to be transposed.
* @param (in) M         Number of rows in matrix \b A.
* @param (in) N         Number of columns in matrix \b A.
* @param (in) alpha     The factor of matrix \b A.
* @param (in) A         Buffer object storing matrix \b A.
* @param (in) offA      Offset of the first element of the matrix \b A in
*                      the buffer object. Counted in elements
* @param (in) lda       Leading dimension of matrix \b A. For a detailed description,
*                      see clblasSgemv().
* @param (in) x         Buffer object storing vector \b x.
* @param (in) offx      Offset of first element of vector \b x in buffer object.
*                      Counted in elements.
* @param (in) incx      Increment for the elements of \b x. It cannot be zero.
* @param (in) beta      The factor of the vector \b y.
* @param (out) y        Buffer object storing the vector \b y.
* @param (in) offy      Offset of first element of vector \b y in buffer object.
*                      Counted in elements.
* @param (in) incy      Increment for the elements of \b y. It cannot be zero.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasInvalidValue if \b offA exceeds the size of \b A buffer
*     object;
*   - the same error codes as the clblasSgemv() function otherwise.
*
* @ingroup GEMV
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasCgemvNative(JNIEnv *env, jclass cls, jint order, jint transA, jlong M, jlong N, jfloatArray alpha, jobject A, jlong offA, jlong lda, jobject x, jlong offx, jint incx, jfloatArray beta, jobject y, jlong offy, jint incy, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // transA is primitive
    // M is primitive
    // N is primitive
    if (alpha == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'alpha' is null for clblasCgemv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasCgemv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // lda is primitive
    if (x == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'x' is null for clblasCgemv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (beta == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'beta' is null for clblasCgemv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (y == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'y' is null for clblasCgemv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasCgemv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasCgemv(order=%d, transA=%d, M=%ld, N=%ld, alpha=%p, A=%p, offA=%ld, lda=%ld, x=%p, offx=%ld, incx=%d, beta=%p, y=%p, offy=%ld, incy=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, transA, M, N, alpha, A, offA, lda, x, offx, incx, beta, y, offy, incy, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasTranspose transA_native;
    size_t M_native = 0;
    size_t N_native = 0;
    FloatComplex alpha_native;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    size_t lda_native = 0;
    cl_mem x_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    FloatComplex beta_native;
    cl_mem y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    transA_native = (clblasTranspose)transA;
    M_native = (size_t)M;
    N_native = (size_t)N;
    if (!init_FloatComplex(env, alpha, alpha_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    lda_native = (size_t)lda;
    if (!init_cl_mem(env, x, x_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_FloatComplex(env, beta, beta_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_mem(env, y, y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasCgemv(order_native, transA_native, M_native, N_native, alpha_native, A_native, offA_native, lda_native, x_native, offx_native, incx_native, beta_native, y_native, offy_native, incy_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // transA is primitive
    // M is primitive
    // N is primitive
    if (!release_FloatComplex(env, alpha_native, alpha, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // A is a read-only native pointer
    // offA is primitive
    // lda is primitive
    // x is a read-only native pointer
    // offx is primitive
    // incx is primitive
    if (!release_FloatComplex(env, beta_native, beta, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* Matrix-vector product with a general rectangular matrix and
*        double complex elements. Extended version.
*
* Matrix-vector products:
*   - \f$ y \leftarrow \alpha A x + \beta y \f$
*   - \f$ y \leftarrow \alpha A^T x + \beta y \f$
*
* @param (in) order     Row/column order.
* @param (in) transA    How matrix \b A is to be transposed.
* @param (in) M         Number of rows in matrix \b A.
* @param (in) N         Number of columns in matrix \b A.
* @param (in) alpha     The factor of matrix \b A.
* @param (in) A         Buffer object storing matrix \b A.
* @param (in) offA      Offset of the first element of the matrix \b A in
*                      the buffer object. Counted in elements.
* @param (in) lda       Leading dimension of matrix \b A. For a detailed description,
*                      see clblasSgemv().
* @param (in) x         Buffer object storing vector \b x.
* @param (in) offx      Offset of first element of vector \b x in buffer object.
*                      Counted in elements.
* @param (in) incx      Increment for the elements of \b x. It cannot be zero.
* @param (in) beta      The factor of the vector \b y.
* @param (out) y        Buffer object storing the vector \b y.
* @param (in) offy      Offset of first element of vector \b y in buffer object.
*                      Counted in elements.
* @param (in) incy      Increment for the elements of \b y. It cannot be zero.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasInvalidDevice if a target device does not support the
*     floating point arithmetic with double precision;
*   - \b clblasInvalidValue if \b offA exceeds the size of \b A buffer
*     object;
*   - the same error codes as the clblasSgemv() function otherwise.
*
* @ingroup GEMV
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasZgemvNative(JNIEnv *env, jclass cls, jint order, jint transA, jlong M, jlong N, jdoubleArray alpha, jobject A, jlong offA, jlong lda, jobject x, jlong offx, jint incx, jdoubleArray beta, jobject y, jlong offy, jint incy, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // transA is primitive
    // M is primitive
    // N is primitive
    if (alpha == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'alpha' is null for clblasZgemv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasZgemv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // lda is primitive
    if (x == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'x' is null for clblasZgemv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (beta == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'beta' is null for clblasZgemv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (y == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'y' is null for clblasZgemv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasZgemv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasZgemv(order=%d, transA=%d, M=%ld, N=%ld, alpha=%p, A=%p, offA=%ld, lda=%ld, x=%p, offx=%ld, incx=%d, beta=%p, y=%p, offy=%ld, incy=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, transA, M, N, alpha, A, offA, lda, x, offx, incx, beta, y, offy, incy, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasTranspose transA_native;
    size_t M_native = 0;
    size_t N_native = 0;
    DoubleComplex alpha_native;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    size_t lda_native = 0;
    cl_mem x_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    DoubleComplex beta_native;
    cl_mem y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    transA_native = (clblasTranspose)transA;
    M_native = (size_t)M;
    N_native = (size_t)N;
    if (!init_DoubleComplex(env, alpha, alpha_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    lda_native = (size_t)lda;
    if (!init_cl_mem(env, x, x_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_DoubleComplex(env, beta, beta_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_mem(env, y, y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasZgemv(order_native, transA_native, M_native, N_native, alpha_native, A_native, offA_native, lda_native, x_native, offx_native, incx_native, beta_native, y_native, offy_native, incy_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // transA is primitive
    // M is primitive
    // N is primitive
    if (!release_DoubleComplex(env, alpha_native, alpha, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // A is a read-only native pointer
    // offA is primitive
    // lda is primitive
    // x is a read-only native pointer
    // offx is primitive
    // incx is primitive
    if (!release_DoubleComplex(env, beta_native, beta, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**@}*/
/**
* <pre>
* @defgroup SYMV SYMV  - Symmetric matrix-Vector multiplication
* @ingroup BLAS2
* </pre>
*/
/**@{*/
/**
* <pre>
* Matrix-vector product with a symmetric matrix and float elements.
*
*
* Matrix-vector products:
* - \f$ y \leftarrow \alpha A x + \beta y \f$
*
* @param (in) order     Row/columns order.
* @param (in) uplo      The triangle in matrix being referenced.
* @param (in) N         Number of rows and columns in matrix \b A.
* @param (in) alpha     The factor of matrix \b A.
* @param (in) A         Buffer object storing matrix \b A.
* @param (in) offA      Offset of the first element of the matrix \b A in
*                      the buffer object. Counted in elements.
* @param (in) lda       Leading dimension of matrix \b A. It cannot less
*                      than \b N.
* @param (in) x         Buffer object storing vector \b x.
* @param (in) offx      Offset of first element of vector \b x in buffer object.
*                      Counted in elements.
* @param (in) incx      Increment for the elements of vector \b x. It cannot be zero.
* @param (in) beta      The factor of vector \b y.
* @param (out) y        Buffer object storing vector \b y.
* @param (in) offy      Offset of first element of vector \b y in buffer object.
*                      Counted in elements.
* @param (in) incy      Increment for the elements of vector \b y. It cannot be zero.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasInvalidValue if \b offA exceeds the size of \b A buffer
*     object;
*   - the same error codes as the clblasSgemv() function otherwise.
*
* @ingroup SYMV
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasSsymvNative(JNIEnv *env, jclass cls, jint order, jint uplo, jlong N, jfloat alpha, jobject A, jlong offA, jlong lda, jobject x, jlong offx, jint incx, jfloat beta, jobject y, jlong offy, jint incy, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // N is primitive
    // alpha is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasSsymv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // lda is primitive
    if (x == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'x' is null for clblasSsymv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    // beta is primitive
    if (y == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'y' is null for clblasSsymv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasSsymv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasSsymv(order=%d, uplo=%d, N=%ld, alpha=%f, A=%p, offA=%ld, lda=%ld, x=%p, offx=%ld, incx=%d, beta=%f, y=%p, offy=%ld, incy=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, N, alpha, A, offA, lda, x, offx, incx, beta, y, offy, incy, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    size_t N_native = 0;
    cl_float alpha_native;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    size_t lda_native = 0;
    cl_mem x_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_float beta_native;
    cl_mem y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    N_native = (size_t)N;
    alpha_native = (cl_float)alpha;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    lda_native = (size_t)lda;
    if (!init_cl_mem(env, x, x_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    beta_native = (cl_float)beta;
    if (!init_cl_mem(env, y, y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasSsymv(order_native, uplo_native, N_native, alpha_native, A_native, offA_native, lda_native, x_native, offx_native, incx_native, beta_native, y_native, offy_native, incy_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // N is primitive
    // alpha is primitive
    // A is a read-only native pointer
    // offA is primitive
    // lda is primitive
    // x is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // beta is primitive
    // y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* @example example_ssymv.c
* This is an example of how to use the @ref clblasSsymv function.
* </pre>
*/
/**
* <pre>
* Matrix-vector product with a symmetric matrix and double elements.
*
*
* Matrix-vector products:
* - \f$ y \leftarrow \alpha A x + \beta y \f$
*
* @param (in) order     Row/columns order.
* @param (in) uplo      The triangle in matrix being referenced.
* @param (in) N         Number of rows and columns in matrix \b A.
* @param (in) alpha     The factor of matrix \b A.
* @param (in) A         Buffer object storing matrix \b A.
* @param (in) offA      Offset of the first element of the matrix \b A in
*                      the buffer object. Counted in elements.
* @param (in) lda       Leading dimension of matrix \b A. It cannot less
*                      than \b N.
* @param (in) x         Buffer object storing vector \b x.
* @param (in) offx      Offset of first element of vector \b x in buffer object.
*                      Counted in elements.
* @param (in) incx      Increment for the elements of vector \b x. It cannot be zero.
* @param (in) beta      The factor of vector \b y.
* @param (out) y        Buffer object storing vector \b y.
* @param (in) offy      Offset of first element of vector \b y in buffer object.
*                      Counted in elements.
* @param (in) incy      Increment for the elements of vector \b y. It cannot be zero.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasInvalidDevice if a target device does not support floating
*     point arithmetic with double precision;
*   - \b clblasInvalidValue if \b offA exceeds the size of \b A buffer
*     object;
*   - the same error codes as the clblasSsymv() function otherwise.
*
* @ingroup SYMV
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasDsymvNative(JNIEnv *env, jclass cls, jint order, jint uplo, jlong N, jdouble alpha, jobject A, jlong offA, jlong lda, jobject x, jlong offx, jint incx, jdouble beta, jobject y, jlong offy, jint incy, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // N is primitive
    // alpha is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasDsymv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // lda is primitive
    if (x == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'x' is null for clblasDsymv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    // beta is primitive
    if (y == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'y' is null for clblasDsymv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasDsymv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasDsymv(order=%d, uplo=%d, N=%ld, alpha=%lf, A=%p, offA=%ld, lda=%ld, x=%p, offx=%ld, incx=%d, beta=%lf, y=%p, offy=%ld, incy=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, N, alpha, A, offA, lda, x, offx, incx, beta, y, offy, incy, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    size_t N_native = 0;
    cl_double alpha_native;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    size_t lda_native = 0;
    cl_mem x_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_double beta_native;
    cl_mem y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    N_native = (size_t)N;
    alpha_native = (cl_double)alpha;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    lda_native = (size_t)lda;
    if (!init_cl_mem(env, x, x_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    beta_native = (cl_double)beta;
    if (!init_cl_mem(env, y, y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasDsymv(order_native, uplo_native, N_native, alpha_native, A_native, offA_native, lda_native, x_native, offx_native, incx_native, beta_native, y_native, offy_native, incy_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // N is primitive
    // alpha is primitive
    // A is a read-only native pointer
    // offA is primitive
    // lda is primitive
    // x is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // beta is primitive
    // y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**@}*/
/**
* <pre>
* @defgroup HEMV HEMV  - Hermitian matrix-vector multiplication
* @ingroup BLAS2
* </pre>
*/
/**@{*/
/**
* <pre>
* Matrix-vector product with a hermitian matrix and float-complex elements.
*
* Matrix-vector products:
* - \f$ Y \leftarrow \alpha A X + \beta Y \f$
*
* @param (in) order     Row/columns order.
* @param (in) uplo      The triangle in matrix being referenced.
* @param (in) N         Number of rows and columns in matrix \b A.
* @param (in) alpha     The factor of matrix \b A.
* @param (in) A         Buffer object storing matrix \b A.
* @param (in) offa		Offset in number of elements for first element in matrix \b A.
* @param (in) lda       Leading dimension of matrix \b A. It cannot less
*                      than \b N.
* @param (in) X         Buffer object storing vector \b X.
* @param (in) offx      Offset of first element of vector \b X in buffer object.
*                      Counted in elements.
* @param (in) incx      Increment for the elements of vector \b X. It cannot be zero.
* @param (in) beta      The factor of vector \b Y.
* @param (out) Y        Buffer object storing vector \b Y.
* @param (in) offy      Offset of first element of vector \b Y in buffer object.
*                      Counted in elements.
* @param (in) incy      Increment for the elements of vector \b Y. It cannot be zero.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasNotInitialized if clblasSetup() was not called;
*   - \b clblasInvalidValue if invalid parameters are passed:
*     - \b N is zero, or
*     - either \b incx or \b incy is zero, or
*     - any of the leading dimensions is invalid;
*     - the matrix sizes or the vector sizes along with the increments lead to
*       accessing outsize of any of the buffers;
*   - \b clblasInvalidMemObject if either \b A, \b X, or \b Y object is
*     invalid, or an image object rather than the buffer one;
*   - \b clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   - \b clblasInvalidCommandQueue if the passed command queue is invalid;
*   - \b clblasInvalidContext if a context a passed command queue belongs to
*     was released;
*   - \b clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   - \b clblasCompilerNotAvailable if a compiler is not available;
*   - \b clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
* @ingroup HEMV
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasChemvNative(JNIEnv *env, jclass cls, jint order, jint uplo, jlong N, jfloatArray alpha, jobject A, jlong offa, jlong lda, jobject X, jlong offx, jint incx, jfloatArray beta, jobject Y, jlong offy, jint incy, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // N is primitive
    if (alpha == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'alpha' is null for clblasChemv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasChemv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasChemv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (beta == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'beta' is null for clblasChemv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (Y == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasChemv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasChemv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasChemv(order=%d, uplo=%d, N=%ld, alpha=%p, A=%p, offa=%ld, lda=%ld, X=%p, offx=%ld, incx=%d, beta=%p, Y=%p, offy=%ld, incy=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, N, alpha, A, offa, lda, X, offx, incx, beta, Y, offy, incy, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    size_t N_native = 0;
    FloatComplex alpha_native;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    FloatComplex beta_native;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    N_native = (size_t)N;
    if (!init_FloatComplex(env, alpha, alpha_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_FloatComplex(env, beta, beta_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_mem(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasChemv(order_native, uplo_native, N_native, alpha_native, A_native, offa_native, lda_native, X_native, offx_native, incx_native, beta_native, Y_native, offy_native, incy_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // N is primitive
    if (!release_FloatComplex(env, alpha_native, alpha, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    if (!release_FloatComplex(env, beta_native, beta, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* Matrix-vector product with a hermitian matrix and double-complex elements.
*
* Matrix-vector products:
* - \f$ Y \leftarrow \alpha A X + \beta Y \f$
*
* @param (in) order     Row/columns order.
* @param (in) uplo      The triangle in matrix being referenced.
* @param (in) N         Number of rows and columns in matrix \b A.
* @param (in) alpha     The factor of matrix \b A.
* @param (in) A         Buffer object storing matrix \b A.
* @param (in) offa		Offset in number of elements for first element in matrix \b A.
* @param (in) lda       Leading dimension of matrix \b A. It cannot less
*                      than \b N.
* @param (in) X         Buffer object storing vector \b X.
* @param (in) offx      Offset of first element of vector \b X in buffer object.
*                      Counted in elements.
* @param (in) incx      Increment for the elements of vector \b X. It cannot be zero.
* @param (in) beta      The factor of vector \b Y.
* @param (out) Y        Buffer object storing vector \b Y.
* @param (in) offy      Offset of first element of vector \b Y in buffer object.
*                      Counted in elements.
* @param (in) incy      Increment for the elements of vector \b Y. It cannot be zero.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasInvalidDevice if a target device does not support floating
*     point arithmetic with double precision;
*   - the same error codes as the clblasChemv() function otherwise.
*
* @ingroup HEMV
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasZhemvNative(JNIEnv *env, jclass cls, jint order, jint uplo, jlong N, jdoubleArray alpha, jobject A, jlong offa, jlong lda, jobject X, jlong offx, jint incx, jdoubleArray beta, jobject Y, jlong offy, jint incy, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // N is primitive
    if (alpha == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'alpha' is null for clblasZhemv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasZhemv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasZhemv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (beta == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'beta' is null for clblasZhemv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (Y == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasZhemv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasZhemv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasZhemv(order=%d, uplo=%d, N=%ld, alpha=%p, A=%p, offa=%ld, lda=%ld, X=%p, offx=%ld, incx=%d, beta=%p, Y=%p, offy=%ld, incy=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, N, alpha, A, offa, lda, X, offx, incx, beta, Y, offy, incy, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    size_t N_native = 0;
    DoubleComplex alpha_native;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    DoubleComplex beta_native;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    N_native = (size_t)N;
    if (!init_DoubleComplex(env, alpha, alpha_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_DoubleComplex(env, beta, beta_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_mem(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasZhemv(order_native, uplo_native, N_native, alpha_native, A_native, offa_native, lda_native, X_native, offx_native, incx_native, beta_native, Y_native, offy_native, incy_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // N is primitive
    if (!release_DoubleComplex(env, alpha_native, alpha, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    if (!release_DoubleComplex(env, beta_native, beta, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* @example example_zhemv.cpp
* Example of how to use the @ref clblasZhemv function.
* </pre>
*/
/**@}*/
/**
* <pre>
* @defgroup TRMV TRMV  - Triangular matrix vector multiply
* @ingroup BLAS2
* </pre>
*/
/**@{*/
/**
* <pre>
* Matrix-vector product with a triangular matrix and
* float elements.
*
* Matrix-vector products:
*   - \f$ X \leftarrow  A X \f$
*   - \f$ X \leftarrow  A^T X \f$
*
* @param (in) order				Row/column order.
* @param (in) uplo				The triangle in matrix being referenced.
* @param (in) trans				How matrix \b A is to be transposed.
* @param (in) diag				Specify whether matrix \b A is unit triangular.
* @param (in) N					Number of rows/columns in matrix \b A.
* @param (in) A					Buffer object storing matrix \b A.
* @param (in) offa				Offset in number of elements for first element in matrix \b A.
* @param (in) lda				Leading dimension of matrix \b A. It cannot be less
*								than \b N
* @param (out) X				Buffer object storing vector \b X.
* @param (in) offx				Offset in number of elements for first element in vector \b X.
* @param (in) incx				Increment for the elements of \b X. Must not be zero.
* @param (in) scratchBuff		Temporary cl_mem scratch buffer object which can hold a
*								minimum of (1 + (N-1)*abs(incx)) elements
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasNotInitialized if clblasSetup() was not called;
*   - \b clblasInvalidValue if invalid parameters are passed:
*     - either \b N or \b incx is zero, or
*     - the leading dimension is invalid;
*   - \b clblasInvalidMemObject if either \b A or \b X object is
*     Invalid, or an image object rather than the buffer one;
*   - \b clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   - \b clblasInvalidCommandQueue if the passed command queue is invalid;
*   - \b clblasInvalidContext if a context a passed command queue belongs
*     to was released;
*   - \b clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   - \b clblasCompilerNotAvailable if a compiler is not available;
*   - \b clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
* @ingroup TRMV
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasStrmvNative(JNIEnv *env, jclass cls, jint order, jint uplo, jint trans, jint diag, jlong N, jobject A, jlong offa, jlong lda, jobject X, jlong offx, jint incx, jobject scratchBuff, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasStrmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasStrmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (scratchBuff == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'scratchBuff' is null for clblasStrmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasStrmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasStrmv(order=%d, uplo=%d, trans=%d, diag=%d, N=%ld, A=%p, offa=%ld, lda=%ld, X=%p, offx=%ld, incx=%d, scratchBuff=%p, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, trans, diag, N, A, offa, lda, X, offx, incx, scratchBuff, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    clblasTranspose trans_native;
    clblasDiag diag_native;
    size_t N_native = 0;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem scratchBuff_native = nullptr;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    trans_native = (clblasTranspose)trans;
    diag_native = (clblasDiag)diag;
    N_native = (size_t)N;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_cl_mem(env, scratchBuff, scratchBuff_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasStrmv(order_native, uplo_native, trans_native, diag_native, N_native, A_native, offa_native, lda_native, X_native, offx_native, incx_native, scratchBuff_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // scratchBuff is a read-only native pointer
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* @example example_strmv.c
* Example of how to use the @ref clblasStrmv function.
* </pre>
*/
/**
* <pre>
* Matrix-vector product with a triangular matrix and
* double elements.
*
* Matrix-vector products:
*   - \f$ X \leftarrow  A X \f$
*   - \f$ X \leftarrow  A^T X \f$
*
* @param (in) order				Row/column order.
* @param (in) uplo				The triangle in matrix being referenced.
* @param (in) trans				How matrix \b A is to be transposed.
* @param (in) diag				Specify whether matrix \b A is unit triangular.
* @param (in) N					Number of rows/columns in matrix \b A.
* @param (in) A					Buffer object storing matrix \b A.
* @param (in) offa				Offset in number of elements for first element in matrix \b A.
* @param (in) lda				Leading dimension of matrix \b A. It cannot be less
*								than \b N
* @param (out) X				Buffer object storing vector \b X.
* @param (in) offx				Offset in number of elements for first element in vector \b X.
* @param (in) incx				Increment for the elements of \b X. Must not be zero.
* @param (in) scratchBuff		Temporary cl_mem scratch buffer object which can hold a
*								minimum of (1 + (N-1)*abs(incx)) elements
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasInvalidDevice if a target device does not support floating
*     point arithmetic with double precision;
*   - the same error codes as the clblasStrmv() function otherwise.
*
* @ingroup TRMV
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasDtrmvNative(JNIEnv *env, jclass cls, jint order, jint uplo, jint trans, jint diag, jlong N, jobject A, jlong offa, jlong lda, jobject X, jlong offx, jint incx, jobject scratchBuff, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasDtrmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasDtrmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (scratchBuff == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'scratchBuff' is null for clblasDtrmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasDtrmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasDtrmv(order=%d, uplo=%d, trans=%d, diag=%d, N=%ld, A=%p, offa=%ld, lda=%ld, X=%p, offx=%ld, incx=%d, scratchBuff=%p, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, trans, diag, N, A, offa, lda, X, offx, incx, scratchBuff, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    clblasTranspose trans_native;
    clblasDiag diag_native;
    size_t N_native = 0;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem scratchBuff_native = nullptr;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    trans_native = (clblasTranspose)trans;
    diag_native = (clblasDiag)diag;
    N_native = (size_t)N;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_cl_mem(env, scratchBuff, scratchBuff_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasDtrmv(order_native, uplo_native, trans_native, diag_native, N_native, A_native, offa_native, lda_native, X_native, offx_native, incx_native, scratchBuff_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // scratchBuff is a read-only native pointer
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* Matrix-vector product with a triangular matrix and
* float complex elements.
*
* Matrix-vector products:
*   - \f$ X \leftarrow  A X \f$
*   - \f$ X \leftarrow  A^T X \f$
*
* @param (in) order				Row/column order.
* @param (in) uplo				The triangle in matrix being referenced.
* @param (in) trans				How matrix \b A is to be transposed.
* @param (in) diag				Specify whether matrix \b A is unit triangular.
* @param (in) N					Number of rows/columns in matrix \b A.
* @param (in) A					Buffer object storing matrix \b A.
* @param (in) offa				Offset in number of elements for first element in matrix \b A.
* @param (in) lda				Leading dimension of matrix \b A. It cannot be less
*								than \b N
* @param (out) X				Buffer object storing vector \b X.
* @param (in) offx				Offset in number of elements for first element in vector \b X.
* @param (in) incx				Increment for the elements of \b X. Must not be zero.
* @param (in) scratchBuff		Temporary cl_mem scratch buffer object which can hold a
*								minimum of (1 + (N-1)*abs(incx)) elements
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return The same result as the clblasStrmv() function.
* @ingroup TRMV
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasCtrmvNative(JNIEnv *env, jclass cls, jint order, jint uplo, jint trans, jint diag, jlong N, jobject A, jlong offa, jlong lda, jobject X, jlong offx, jint incx, jobject scratchBuff, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasCtrmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasCtrmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (scratchBuff == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'scratchBuff' is null for clblasCtrmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasCtrmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasCtrmv(order=%d, uplo=%d, trans=%d, diag=%d, N=%ld, A=%p, offa=%ld, lda=%ld, X=%p, offx=%ld, incx=%d, scratchBuff=%p, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, trans, diag, N, A, offa, lda, X, offx, incx, scratchBuff, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    clblasTranspose trans_native;
    clblasDiag diag_native;
    size_t N_native = 0;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem scratchBuff_native = nullptr;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    trans_native = (clblasTranspose)trans;
    diag_native = (clblasDiag)diag;
    N_native = (size_t)N;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_cl_mem(env, scratchBuff, scratchBuff_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasCtrmv(order_native, uplo_native, trans_native, diag_native, N_native, A_native, offa_native, lda_native, X_native, offx_native, incx_native, scratchBuff_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // scratchBuff is a read-only native pointer
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* Matrix-vector product with a triangular matrix and
* double complex elements.
*
* Matrix-vector products:
*   - \f$ X \leftarrow  A X \f$
*   - \f$ X \leftarrow  A^T X \f$
*
* @param (in) order				Row/column order.
* @param (in) uplo				The triangle in matrix being referenced.
* @param (in) trans				How matrix \b A is to be transposed.
* @param (in) diag				Specify whether matrix \b A is unit triangular.
* @param (in) N					Number of rows/columns in matrix \b A.
* @param (in) A					Buffer object storing matrix \b A.
* @param (in) offa				Offset in number of elements for first element in matrix \b A.
* @param (in) lda				Leading dimension of matrix \b A. It cannot be less
*								than \b N
* @param (out) X				Buffer object storing vector \b X.
* @param (in) offx				Offset in number of elements for first element in vector \b X.
* @param (in) incx				Increment for the elements of \b X. Must not be zero.
* @param (in) scratchBuff		Temporary cl_mem scratch buffer object which can hold a
*								minimum of (1 + (N-1)*abs(incx)) elements
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return The same result as the clblasDtrmv() function.
* @ingroup TRMV
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasZtrmvNative(JNIEnv *env, jclass cls, jint order, jint uplo, jint trans, jint diag, jlong N, jobject A, jlong offa, jlong lda, jobject X, jlong offx, jint incx, jobject scratchBuff, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasZtrmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasZtrmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (scratchBuff == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'scratchBuff' is null for clblasZtrmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasZtrmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasZtrmv(order=%d, uplo=%d, trans=%d, diag=%d, N=%ld, A=%p, offa=%ld, lda=%ld, X=%p, offx=%ld, incx=%d, scratchBuff=%p, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, trans, diag, N, A, offa, lda, X, offx, incx, scratchBuff, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    clblasTranspose trans_native;
    clblasDiag diag_native;
    size_t N_native = 0;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem scratchBuff_native = nullptr;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    trans_native = (clblasTranspose)trans;
    diag_native = (clblasDiag)diag;
    N_native = (size_t)N;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_cl_mem(env, scratchBuff, scratchBuff_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasZtrmv(order_native, uplo_native, trans_native, diag_native, N_native, A_native, offa_native, lda_native, X_native, offx_native, incx_native, scratchBuff_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // scratchBuff is a read-only native pointer
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**@}*/
/**
* <pre>
* @defgroup TRSV TRSV  - Triangular matrix vector Solve
* @ingroup BLAS2
* </pre>
*/
/**@{*/
/**
* <pre>
* solving triangular matrix problems with float elements.
*
* Matrix-vector products:
*   - \f$ A X \leftarrow  X \f$
*   - \f$ A^T X \leftarrow  X \f$
*
* @param (in) order				Row/column order.
* @param (in) uplo				The triangle in matrix being referenced.
* @param (in) trans				How matrix \b A is to be transposed.
* @param (in) diag				Specify whether matrix \b A is unit triangular.
* @param (in) N					Number of rows/columns in matrix \b A.
* @param (in) A					Buffer object storing matrix \b A.
* @param (in) offa				Offset in number of elements for first element in matrix \b A.
* @param (in) lda				Leading dimension of matrix \b A. It cannot be less
*								than \b N
* @param (out) X				Buffer object storing vector \b X.
* @param (in) offx				Offset in number of elements for first element in vector \b X.
* @param (in) incx				Increment for the elements of \b X. Must not be zero.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasNotInitialized if clblasSetup() was not called;
*   - \b clblasInvalidValue if invalid parameters are passed:
*     - either \b N or \b incx is zero, or
*     - the leading dimension is invalid;
*   - \b clblasInvalidMemObject if either \b A or \b X object is
*     Invalid, or an image object rather than the buffer one;
*   - \b clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   - \b clblasInvalidCommandQueue if the passed command queue is invalid;
*   - \b clblasInvalidContext if a context a passed command queue belongs
*     to was released;
*   - \b clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   - \b clblasCompilerNotAvailable if a compiler is not available;
*   - \b clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
* @ingroup TRSV
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasStrsvNative(JNIEnv *env, jclass cls, jint order, jint uplo, jint trans, jint diag, jlong N, jobject A, jlong offa, jlong lda, jobject X, jlong offx, jint incx, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasStrsv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasStrsv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasStrsv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasStrsv(order=%d, uplo=%d, trans=%d, diag=%d, N=%ld, A=%p, offa=%ld, lda=%ld, X=%p, offx=%ld, incx=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, trans, diag, N, A, offa, lda, X, offx, incx, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    clblasTranspose trans_native;
    clblasDiag diag_native;
    size_t N_native = 0;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    trans_native = (clblasTranspose)trans;
    diag_native = (clblasDiag)diag;
    N_native = (size_t)N;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasStrsv(order_native, uplo_native, trans_native, diag_native, N_native, A_native, offa_native, lda_native, X_native, offx_native, incx_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* @example example_strsv.c
* Example of how to use the @ref clblasStrsv function.
* </pre>
*/
/**
* <pre>
* solving triangular matrix problems with double elements.
*
* Matrix-vector products:
*   - \f$ A X \leftarrow  X \f$
*   - \f$ A^T X \leftarrow  X \f$
*
* @param (in) order				Row/column order.
* @param (in) uplo				The triangle in matrix being referenced.
* @param (in) trans				How matrix \b A is to be transposed.
* @param (in) diag				Specify whether matrix \b A is unit triangular.
* @param (in) N					Number of rows/columns in matrix \b A.
* @param (in) A					Buffer object storing matrix \b A.
* @param (in) offa				Offset in number of elements for first element in matrix \b A.
* @param (in) lda				Leading dimension of matrix \b A. It cannot be less
*								than \b N
* @param (out) X				Buffer object storing vector \b X.
* @param (in) offx				Offset in number of elements for first element in vector \b X.
* @param (in) incx				Increment for the elements of \b X. Must not be zero.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasInvalidDevice if a target device does not support floating
*     point arithmetic with double precision;
*   - the same error codes as the clblasStrsv() function otherwise.
*
* @ingroup TRSV
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasDtrsvNative(JNIEnv *env, jclass cls, jint order, jint uplo, jint trans, jint diag, jlong N, jobject A, jlong offa, jlong lda, jobject X, jlong offx, jint incx, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasDtrsv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasDtrsv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasDtrsv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasDtrsv(order=%d, uplo=%d, trans=%d, diag=%d, N=%ld, A=%p, offa=%ld, lda=%ld, X=%p, offx=%ld, incx=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, trans, diag, N, A, offa, lda, X, offx, incx, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    clblasTranspose trans_native;
    clblasDiag diag_native;
    size_t N_native = 0;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    trans_native = (clblasTranspose)trans;
    diag_native = (clblasDiag)diag;
    N_native = (size_t)N;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasDtrsv(order_native, uplo_native, trans_native, diag_native, N_native, A_native, offa_native, lda_native, X_native, offx_native, incx_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* solving triangular matrix problems with float-complex elements.
*
* Matrix-vector products:
*   - \f$ A X \leftarrow  X \f$
*   - \f$ A^T X \leftarrow  X \f$
*
* @param (in) order				Row/column order.
* @param (in) uplo				The triangle in matrix being referenced.
* @param (in) trans				How matrix \b A is to be transposed.
* @param (in) diag				Specify whether matrix \b A is unit triangular.
* @param (in) N					Number of rows/columns in matrix \b A.
* @param (in) A					Buffer object storing matrix \b A.
* @param (in) offa				Offset in number of elements for first element in matrix \b A.
* @param (in) lda				Leading dimension of matrix \b A. It cannot be less
*								than \b N
* @param (out) X				Buffer object storing vector \b X.
* @param (in) offx				Offset in number of elements for first element in vector \b X.
* @param (in) incx				Increment for the elements of \b X. Must not be zero.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return The same result as the clblasStrsv() function.
*
* @ingroup TRSV
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasCtrsvNative(JNIEnv *env, jclass cls, jint order, jint uplo, jint trans, jint diag, jlong N, jobject A, jlong offa, jlong lda, jobject X, jlong offx, jint incx, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasCtrsv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasCtrsv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasCtrsv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasCtrsv(order=%d, uplo=%d, trans=%d, diag=%d, N=%ld, A=%p, offa=%ld, lda=%ld, X=%p, offx=%ld, incx=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, trans, diag, N, A, offa, lda, X, offx, incx, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    clblasTranspose trans_native;
    clblasDiag diag_native;
    size_t N_native = 0;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    trans_native = (clblasTranspose)trans;
    diag_native = (clblasDiag)diag;
    N_native = (size_t)N;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasCtrsv(order_native, uplo_native, trans_native, diag_native, N_native, A_native, offa_native, lda_native, X_native, offx_native, incx_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* solving triangular matrix problems with double-complex elements.
*
* Matrix-vector products:
*   - \f$ A X \leftarrow  X \f$
*   - \f$ A^T X \leftarrow  X \f$
*
* @param (in) order				Row/column order.
* @param (in) uplo				The triangle in matrix being referenced.
* @param (in) trans				How matrix \b A is to be transposed.
* @param (in) diag				Specify whether matrix \b A is unit triangular.
* @param (in) N					Number of rows/columns in matrix \b A.
* @param (in) A					Buffer object storing matrix \b A.
* @param (in) offa				Offset in number of elements for first element in matrix \b A.
* @param (in) lda				Leading dimension of matrix \b A. It cannot be less
*								than \b N
* @param (out) X				Buffer object storing vector \b X.
* @param (in) offx				Offset in number of elements for first element in vector \b X.
* @param (in) incx				Increment for the elements of \b X. Must not be zero.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return The same result as the clblasDtrsv() function.
*
* @ingroup TRSV
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasZtrsvNative(JNIEnv *env, jclass cls, jint order, jint uplo, jint trans, jint diag, jlong N, jobject A, jlong offa, jlong lda, jobject X, jlong offx, jint incx, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasZtrsv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasZtrsv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasZtrsv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasZtrsv(order=%d, uplo=%d, trans=%d, diag=%d, N=%ld, A=%p, offa=%ld, lda=%ld, X=%p, offx=%ld, incx=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, trans, diag, N, A, offa, lda, X, offx, incx, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    clblasTranspose trans_native;
    clblasDiag diag_native;
    size_t N_native = 0;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    trans_native = (clblasTranspose)trans;
    diag_native = (clblasDiag)diag;
    N_native = (size_t)N;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasZtrsv(order_native, uplo_native, trans_native, diag_native, N_native, A_native, offa_native, lda_native, X_native, offx_native, incx_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**@}*/
/**
* <pre>
* @defgroup GER GER   - General matrix rank 1 operation
* @ingroup BLAS2
* </pre>
*/
/**@{*/
/**
* <pre>
* vector-vector product with float elements and
* performs the rank 1 operation A
*
* Vector-vector products:
*   - \f$ A \leftarrow \alpha X Y^T + A \f$
*
* @param (in) order     Row/column order.
* @param (in) M         Number of rows in matrix \b A.
* @param (in) N         Number of columns in matrix \b A.
* @param (in) alpha     specifies the scalar alpha.
* @param (in) X         Buffer object storing vector \b X.
* @param (in) offx      Offset in number of elements for the first element in vector \b X.
* @param (in) incx      Increment for the elements of \b X. Must not be zero.
* @param (in) Y         Buffer object storing vector \b Y.
* @param (in) offy      Offset in number of elements for the first element in vector \b Y.
* @param (in) incy      Increment for the elements of \b Y. Must not be zero.
* @param (out) A 		Buffer object storing matrix \b A. On exit, A is
*				        overwritten by the updated matrix.
* @param (in) offa      Offset in number of elements for the first element in matrix \b A.
* @param (in) lda       Leading dimension of matrix \b A. It cannot be less
*                      than \b N when the \b order parameter is set to
*                      \b clblasRowMajor,\n or less than \b M when the
*                      parameter is set to \b clblasColumnMajor.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasNotInitialized if clblasSetup() was not called;
*   - \b clblasInvalidValue if invalid parameters are passed:
*     - \b M, \b N or
*	   - either \b incx or \b incy is zero, or
*     - a leading dimension is invalid;
*   - \b clblasInvalidMemObject if A, X, or Y object is invalid,
*     or an image object rather than the buffer one;
*   - \b clblasOutOfResources if you use image-based function implementation
*     and no suitable scratch image available;
*   - \b clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   - \b clblasInvalidCommandQueue if the passed command queue is invalid;
*   - \b clblasInvalidContext if a context a passed command queue belongs to
*     was released;
*   - \b clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   - \b clblasCompilerNotAvailable if a compiler is not available;
*   - \b clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
* @ingroup GER
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasSgerNative(JNIEnv *env, jclass cls, jint order, jlong M, jlong N, jfloat alpha, jobject X, jlong offx, jint incx, jobject Y, jlong offy, jint incy, jobject A, jlong offa, jlong lda, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // M is primitive
    // N is primitive
    // alpha is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasSger");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (Y == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasSger");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasSger");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasSger");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasSger(order=%d, M=%ld, N=%ld, alpha=%f, X=%p, offx=%ld, incx=%d, Y=%p, offy=%ld, incy=%d, A=%p, offa=%ld, lda=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, M, N, alpha, X, offx, incx, Y, offy, incy, A, offa, lda, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    size_t M_native = 0;
    size_t N_native = 0;
    cl_float alpha_native;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    M_native = (size_t)M;
    N_native = (size_t)N;
    alpha_native = (cl_float)alpha;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_cl_mem(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasSger(order_native, M_native, N_native, alpha_native, X_native, offx_native, incx_native, Y_native, offy_native, incy_native, A_native, offa_native, lda_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // M is primitive
    // N is primitive
    // alpha is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* @example example_sger.c
* Example of how to use the @ref clblasSger function.
* </pre>
*/
/**
* <pre>
* vector-vector product with double elements and
* performs the rank 1 operation A
*
* Vector-vector products:
*   - \f$ A \leftarrow \alpha X Y^T + A \f$
*
* @param (in) order     Row/column order.
* @param (in) M         Number of rows in matrix \b A.
* @param (in) N         Number of columns in matrix \b A.
* @param (in) alpha     specifies the scalar alpha.
* @param (in) X         Buffer object storing vector \b X.
* @param (in) offx      Offset in number of elements for the first element in vector \b X.
* @param (in) incx      Increment for the elements of \b X. Must not be zero.
* @param (in) Y         Buffer object storing vector \b Y.
* @param (in) offy      Offset in number of elements for the first element in vector \b Y.
* @param (in) incy      Increment for the elements of \b Y. Must not be zero.
* @param (out) A 		Buffer object storing matrix \b A. On exit, A is
*				        overwritten by the updated matrix.
* @param (in) offa      Offset in number of elements for the first element in matrix \b A.
* @param (in) lda       Leading dimension of matrix \b A. It cannot be less
*                      than \b N when the \b order parameter is set to
*                      \b clblasRowMajor,\n or less than \b M when the
*                      parameter is set to \b clblasColumnMajor.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasInvalidDevice if a target device does not support floating
*     point arithmetic with double precision;
*   - the same error codes as the clblasSger() function otherwise.
*
* @ingroup GER
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasDgerNative(JNIEnv *env, jclass cls, jint order, jlong M, jlong N, jdouble alpha, jobject X, jlong offx, jint incx, jobject Y, jlong offy, jint incy, jobject A, jlong offa, jlong lda, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // M is primitive
    // N is primitive
    // alpha is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasDger");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (Y == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasDger");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasDger");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasDger");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasDger(order=%d, M=%ld, N=%ld, alpha=%lf, X=%p, offx=%ld, incx=%d, Y=%p, offy=%ld, incy=%d, A=%p, offa=%ld, lda=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, M, N, alpha, X, offx, incx, Y, offy, incy, A, offa, lda, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    size_t M_native = 0;
    size_t N_native = 0;
    cl_double alpha_native;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    M_native = (size_t)M;
    N_native = (size_t)N;
    alpha_native = (cl_double)alpha;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_cl_mem(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasDger(order_native, M_native, N_native, alpha_native, X_native, offx_native, incx_native, Y_native, offy_native, incy_native, A_native, offa_native, lda_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // M is primitive
    // N is primitive
    // alpha is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**@}*/
/**
* <pre>
* @defgroup GERU GERU  - General matrix rank 1 operation
* @ingroup BLAS2
* </pre>
*/
/**@{*/
/**
* <pre>
* vector-vector product with float complex elements and
* performs the rank 1 operation A
*
* Vector-vector products:
*   - \f$ A \leftarrow \alpha X Y^T + A \f$
*
* @param (in) order     Row/column order.
* @param (in) M         Number of rows in matrix \b A.
* @param (in) N         Number of columns in matrix \b A.
* @param (in) alpha     specifies the scalar alpha.
* @param (in) X         Buffer object storing vector \b X.
* @param (in) offx      Offset in number of elements for the first element in vector \b X.
* @param (in) incx      Increment for the elements of \b X. Must not be zero.
* @param (in) Y         Buffer object storing vector \b Y.
* @param (in) offy      Offset in number of elements for the first element in vector \b Y.
* @param (in) incy      Increment for the elements of \b Y. Must not be zero.
* @param (out) A 		Buffer object storing matrix \b A. On exit, A is
*				        overwritten by the updated matrix.
* @param (in) offa      Offset in number of elements for the first element in matrix \b A.
* @param (in) lda       Leading dimension of matrix \b A. It cannot be less
*                      than \b N when the \b order parameter is set to
*                      \b clblasRowMajor,\n or less than \b M when the
*                      parameter is set to \b clblasColumnMajor.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasNotInitialized if clblasSetup() was not called;
*   - \b clblasInvalidValue if invalid parameters are passed:
*     - \b M, \b N or
*	   - either \b incx or \b incy is zero, or
*     - a leading dimension is invalid;
*   - \b clblasInvalidMemObject if A, X, or Y object is invalid,
*     or an image object rather than the buffer one;
*   - \b clblasOutOfResources if you use image-based function implementation
*     and no suitable scratch image available;
*   - \b clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   - \b clblasInvalidCommandQueue if the passed command queue is invalid;
*   - \b clblasInvalidContext if a context a passed command queue belongs to
*     was released;
*   - \b clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   - \b clblasCompilerNotAvailable if a compiler is not available;
*   - \b clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
* @ingroup GERU
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasCgeruNative(JNIEnv *env, jclass cls, jint order, jlong M, jlong N, jfloatArray alpha, jobject X, jlong offx, jint incx, jobject Y, jlong offy, jint incy, jobject A, jlong offa, jlong lda, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // M is primitive
    // N is primitive
    if (alpha == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'alpha' is null for clblasCgeru");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasCgeru");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (Y == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasCgeru");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasCgeru");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasCgeru");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasCgeru(order=%d, M=%ld, N=%ld, alpha=%p, X=%p, offx=%ld, incx=%d, Y=%p, offy=%ld, incy=%d, A=%p, offa=%ld, lda=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, M, N, alpha, X, offx, incx, Y, offy, incy, A, offa, lda, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    size_t M_native = 0;
    size_t N_native = 0;
    cl_float2 alpha_native;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    M_native = (size_t)M;
    N_native = (size_t)N;
    if (!init_cl_float2(env, alpha, alpha_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_cl_mem(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasCgeru(order_native, M_native, N_native, alpha_native, X_native, offx_native, incx_native, Y_native, offy_native, incy_native, A_native, offa_native, lda_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // M is primitive
    // N is primitive
    if (!release_cl_float2(env, alpha_native, alpha, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* vector-vector product with double complex elements and
* performs the rank 1 operation A
*
* Vector-vector products:
*   - \f$ A \leftarrow \alpha X Y^T + A \f$
*
* @param (in) order     Row/column order.
* @param (in) M         Number of rows in matrix \b A.
* @param (in) N         Number of columns in matrix \b A.
* @param (in) alpha     specifies the scalar alpha.
* @param (in) X         Buffer object storing vector \b X.
* @param (in) offx      Offset in number of elements for the first element in vector \b X.
* @param (in) incx      Increment for the elements of \b X. Must not be zero.
* @param (in) Y         Buffer object storing vector \b Y.
* @param (in) offy      Offset in number of elements for the first element in vector \b Y.
* @param (in) incy      Increment for the elements of \b Y. Must not be zero.
* @param (out) A		   Buffer object storing matrix \b A. On exit, A is
*				        overwritten by the updated matrix.
* @param (in) offa      Offset in number of elements for the first element in matrix \b A.
* @param (in) lda       Leading dimension of matrix \b A. It cannot be less
*                      than \b N when the \b order parameter is set to
*                      \b clblasRowMajor,\n or less than \b M when the
*                      parameter is set to \b clblasColumnMajor.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasInvalidDevice if a target device does not support floating
*     point arithmetic with double precision;
*   - the same error codes as the clblasCgeru() function otherwise.
*
* @ingroup GERU
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasZgeruNative(JNIEnv *env, jclass cls, jint order, jlong M, jlong N, jdoubleArray alpha, jobject X, jlong offx, jint incx, jobject Y, jlong offy, jint incy, jobject A, jlong offa, jlong lda, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // M is primitive
    // N is primitive
    if (alpha == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'alpha' is null for clblasZgeru");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasZgeru");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (Y == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasZgeru");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasZgeru");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasZgeru");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasZgeru(order=%d, M=%ld, N=%ld, alpha=%p, X=%p, offx=%ld, incx=%d, Y=%p, offy=%ld, incy=%d, A=%p, offa=%ld, lda=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, M, N, alpha, X, offx, incx, Y, offy, incy, A, offa, lda, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    size_t M_native = 0;
    size_t N_native = 0;
    cl_double2 alpha_native;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    M_native = (size_t)M;
    N_native = (size_t)N;
    if (!init_cl_double2(env, alpha, alpha_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_cl_mem(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasZgeru(order_native, M_native, N_native, alpha_native, X_native, offx_native, incx_native, Y_native, offy_native, incy_native, A_native, offa_native, lda_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // M is primitive
    // N is primitive
    if (!release_cl_double2(env, alpha_native, alpha, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**@}*/
/**
* <pre>
* @defgroup GERC GERC  - General matrix rank 1 operation
* @ingroup BLAS2
* </pre>
*/
/**@{*/
/**
* <pre>
* vector-vector product with float complex elements and
* performs the rank 1 operation A
*
* Vector-vector products:
*   - \f$ A \leftarrow \alpha X Y^H + A \f$
*
* @param (in) order     Row/column order.
* @param (in) M         Number of rows in matrix \b A.
* @param (in) N         Number of columns in matrix \b A.
* @param (in) alpha     specifies the scalar alpha.
* @param (in) X         Buffer object storing vector \b X.
* @param (in) offx      Offset in number of elements for the first element in vector \b X.
* @param (in) incx      Increment for the elements of \b X. Must not be zero.
* @param (in) Y         Buffer object storing vector \b Y.
* @param (in) offy      Offset in number of elements for the first element in vector \b Y.
* @param (in) incy      Increment for the elements of \b Y. Must not be zero.
* @param (out) A 	    Buffer object storing matrix \b A. On exit, A is
*				        overwritten by the updated matrix.
* @param (in) offa      Offset in number of elements for the first element in matrix \b A.
* @param (in) lda       Leading dimension of matrix \b A. It cannot be less
*                      than \b N when the \b order parameter is set to
*                      \b clblasRowMajor,\n or less than \b M when the
*                      parameter is set to \b clblasColumnMajor.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasNotInitialized if clblasSetup() was not called;
*   - \b clblasInvalidValue if invalid parameters are passed:
*     - \b M, \b N or
*	   - either \b incx or \b incy is zero, or
*     - a leading dimension is invalid;
*   - \b clblasInvalidMemObject if A, X, or Y object is invalid,
*     or an image object rather than the buffer one;
*   - \b clblasOutOfResources if you use image-based function implementation
*     and no suitable scratch image available;
*   - \b clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   - \b clblasInvalidCommandQueue if the passed command queue is invalid;
*   - \b clblasInvalidContext if a context a passed command queue belongs to
*     was released;
*   - \b clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   - \b clblasCompilerNotAvailable if a compiler is not available;
*   - \b clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
* @ingroup GERC
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasCgercNative(JNIEnv *env, jclass cls, jint order, jlong M, jlong N, jfloatArray alpha, jobject X, jlong offx, jint incx, jobject Y, jlong offy, jint incy, jobject A, jlong offa, jlong lda, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // M is primitive
    // N is primitive
    if (alpha == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'alpha' is null for clblasCgerc");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasCgerc");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (Y == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasCgerc");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasCgerc");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasCgerc");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasCgerc(order=%d, M=%ld, N=%ld, alpha=%p, X=%p, offx=%ld, incx=%d, Y=%p, offy=%ld, incy=%d, A=%p, offa=%ld, lda=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, M, N, alpha, X, offx, incx, Y, offy, incy, A, offa, lda, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    size_t M_native = 0;
    size_t N_native = 0;
    cl_float2 alpha_native;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    M_native = (size_t)M;
    N_native = (size_t)N;
    if (!init_cl_float2(env, alpha, alpha_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_cl_mem(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasCgerc(order_native, M_native, N_native, alpha_native, X_native, offx_native, incx_native, Y_native, offy_native, incy_native, A_native, offa_native, lda_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // M is primitive
    // N is primitive
    if (!release_cl_float2(env, alpha_native, alpha, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* vector-vector product with double complex elements and
* performs the rank 1 operation A
*
* Vector-vector products:
*   - \f$ A \leftarrow \alpha X Y^H + A \f$
*
* @param (in) order     Row/column order.
* @param (in) M         Number of rows in matrix \b A.
* @param (in) N         Number of columns in matrix \b A.
* @param (in) alpha     specifies the scalar alpha.
* @param (in) X         Buffer object storing vector \b X.
* @param (in) offx      Offset in number of elements for the first element in vector \b X.
* @param (in) incx      Increment for the elements of \b X. Must not be zero.
* @param (in) Y         Buffer object storing vector \b Y.
* @param (in) offy      Offset in number of elements for the first element in vector \b Y.
* @param (in) incy      Increment for the elements of \b Y. Must not be zero.
* @param (out) A		Buffer object storing matrix \b A. On exit, A is
*				        overwritten by the updated matrix.
* @param (in) offa      Offset in number of elements for the first element in matrix \b A.
* @param (in) lda       Leading dimension of matrix \b A. It cannot be less
*                      than \b N when the \b order parameter is set to
*                      \b clblasRowMajor,\n or less than \b M when the
*                      parameter is set to \b clblasColumnMajor.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasInvalidDevice if a target device does not support floating
*     point arithmetic with double precision;
*   - the same error codes as the clblasCgerc() function otherwise.
*
* @ingroup GERC
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasZgercNative(JNIEnv *env, jclass cls, jint order, jlong M, jlong N, jdoubleArray alpha, jobject X, jlong offx, jint incx, jobject Y, jlong offy, jint incy, jobject A, jlong offa, jlong lda, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // M is primitive
    // N is primitive
    if (alpha == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'alpha' is null for clblasZgerc");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasZgerc");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (Y == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasZgerc");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasZgerc");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasZgerc");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasZgerc(order=%d, M=%ld, N=%ld, alpha=%p, X=%p, offx=%ld, incx=%d, Y=%p, offy=%ld, incy=%d, A=%p, offa=%ld, lda=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, M, N, alpha, X, offx, incx, Y, offy, incy, A, offa, lda, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    size_t M_native = 0;
    size_t N_native = 0;
    cl_double2 alpha_native;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    M_native = (size_t)M;
    N_native = (size_t)N;
    if (!init_cl_double2(env, alpha, alpha_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_cl_mem(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasZgerc(order_native, M_native, N_native, alpha_native, X_native, offx_native, incx_native, Y_native, offy_native, incy_native, A_native, offa_native, lda_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // M is primitive
    // N is primitive
    if (!release_cl_double2(env, alpha_native, alpha, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**@}*/
/**
* <pre>
* @defgroup SYR SYR   - Symmetric rank 1 update
*
* The Level 2 Basic Linear Algebra Subprograms are functions that perform
* symmetric rank 1 update operations.
* @ingroup BLAS2
* </pre>
*/
/**@{*/
/**
* <pre>
* Symmetric rank 1 operation with a general triangular matrix and
* float elements.
*
* Symmetric rank 1 operation:
*   - \f$ A \leftarrow \alpha x x^T + A \f$
*
* @param (in) order     Row/column order.
* @param (in) uplo      The triangle in matrix being referenced.
* @param (in) N         Number of columns in matrix \b A.
* @param (in) alpha     The factor of matrix \b A.
* @param (in) X         Buffer object storing vector \b X.
* @param (in) offx      Offset of first element of vector \b X in buffer object.
* @param (in) incx      Increment for the elements of \b X. Must not be zero.
* @param (out) A 	    Buffer object storing matrix \b A.
* @param (in) offa      Offset of first element of matrix \b A in buffer object.
* @param (in) lda       Leading dimension of matrix \b A. It cannot be less
*                      than \b N.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasNotInitialized if clblasSetup() was not called;
*   - \b clblasInvalidValue if invalid parameters are passed:
*     - \b N is zero, or
*     - either \b incx is zero, or
*     - the leading dimension is invalid;
*   - \b clblasInvalidMemObject if either \b A, \b X object is
*     Invalid, or an image object rather than the buffer one;
*   - \b clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   - \b clblasInvalidCommandQueue if the passed command queue is invalid;
*   - \b clblasInvalidContext if a context a passed command queue belongs
*     to was released;
*   - \b clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   - \b clblasCompilerNotAvailable if a compiler is not available;
*   - \b clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
* @ingroup SYR
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasSsyrNative(JNIEnv *env, jclass cls, jint order, jint uplo, jlong N, jfloat alpha, jobject X, jlong offx, jint incx, jobject A, jlong offa, jlong lda, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // N is primitive
    // alpha is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasSsyr");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasSsyr");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasSsyr");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasSsyr(order=%d, uplo=%d, N=%ld, alpha=%f, X=%p, offx=%ld, incx=%d, A=%p, offa=%ld, lda=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, N, alpha, X, offx, incx, A, offa, lda, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    size_t N_native = 0;
    cl_float alpha_native;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    N_native = (size_t)N;
    alpha_native = (cl_float)alpha;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasSsyr(order_native, uplo_native, N_native, alpha_native, X_native, offx_native, incx_native, A_native, offa_native, lda_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // N is primitive
    // alpha is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* Symmetric rank 1 operation with a general triangular matrix and
* double elements.
*
* Symmetric rank 1 operation:
*   - \f$ A \leftarrow \alpha x x^T + A \f$
*
* @param (in) order     Row/column order.
* @param (in) uplo      The triangle in matrix being referenced.
* @param (in) N         Number of columns in matrix \b A.
* @param (in) alpha     The factor of matrix \b A.
* @param (in) X         Buffer object storing vector \b X.
* @param (in) offx      Offset of first element of vector \b X in buffer object.
* @param (in) incx      Increment for the elements of \b X. Must not be zero.
* @param (out) A		Buffer object storing matrix \b A.
* @param (in) offa      Offset of first element of matrix \b A in buffer object.
* @param (in) lda       Leading dimension of matrix \b A. It cannot be less
*                      than \b N.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasInvalidDevice if a target device does not support floating
*     point arithmetic with double precision;
*   - the same error codes as the clblasSsyr() function otherwise.
*
* @ingroup SYR
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasDsyrNative(JNIEnv *env, jclass cls, jint order, jint uplo, jlong N, jdouble alpha, jobject X, jlong offx, jint incx, jobject A, jlong offa, jlong lda, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // N is primitive
    // alpha is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasDsyr");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasDsyr");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasDsyr");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasDsyr(order=%d, uplo=%d, N=%ld, alpha=%lf, X=%p, offx=%ld, incx=%d, A=%p, offa=%ld, lda=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, N, alpha, X, offx, incx, A, offa, lda, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    size_t N_native = 0;
    cl_double alpha_native;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    N_native = (size_t)N;
    alpha_native = (cl_double)alpha;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasDsyr(order_native, uplo_native, N_native, alpha_native, X_native, offx_native, incx_native, A_native, offa_native, lda_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // N is primitive
    // alpha is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**@}*/
/**
* <pre>
* @defgroup HER HER   - Hermitian rank 1 operation
*
* The Level 2 Basic Linear Algebra Subprogram functions that perform
* hermitian rank 1 operations.
* @ingroup BLAS2
* </pre>
*/
/**@{*/
/**
* <pre>
* hermitian rank 1 operation with a general triangular matrix and
* float-complex elements.
*
* hermitian rank 1 operation:
*   - \f$ A \leftarrow \alpha X X^H + A \f$
*
* @param (in) order     Row/column order.
* @param (in) uplo      The triangle in matrix being referenced.
* @param (in) N         Number of columns in matrix \b A.
* @param (in) alpha     The factor of matrix \b A (a scalar float value)
* @param (in) X         Buffer object storing vector \b X.
* @param (in) offx      Offset in number of elements for the first element in vector \b X.
* @param (in) incx      Increment for the elements of \b X. Must not be zero.
* @param (out) A		Buffer object storing matrix \b A.
* @param (in) offa      Offset in number of elements for the first element in matrix \b A.
* @param (in) lda       Leading dimension of matrix \b A. It cannot be less
*                      than \b N.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasNotInitialized if clblasSetup() was not called;
*   - \b clblasInvalidValue if invalid parameters are passed:
*     - \b N is zero, or
*     - either \b incx is zero, or
*     - the leading dimension is invalid;
*   - \b clblasInvalidMemObject if either \b A, \b X object is
*     Invalid, or an image object rather than the buffer one;
*   - \b clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   - \b clblasInvalidCommandQueue if the passed command queue is invalid;
*   - \b clblasInvalidContext if a context a passed command queue belongs
*     to was released;
*   - \b clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   - \b clblasCompilerNotAvailable if a compiler is not available;
*   - \b clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
* @ingroup HER
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasCherNative(JNIEnv *env, jclass cls, jint order, jint uplo, jlong N, jfloat alpha, jobject X, jlong offx, jint incx, jobject A, jlong offa, jlong lda, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // N is primitive
    // alpha is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasCher");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasCher");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasCher");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasCher(order=%d, uplo=%d, N=%ld, alpha=%f, X=%p, offx=%ld, incx=%d, A=%p, offa=%ld, lda=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, N, alpha, X, offx, incx, A, offa, lda, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    size_t N_native = 0;
    cl_float alpha_native;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    N_native = (size_t)N;
    alpha_native = (cl_float)alpha;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasCher(order_native, uplo_native, N_native, alpha_native, X_native, offx_native, incx_native, A_native, offa_native, lda_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // N is primitive
    // alpha is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* @example example_cher.c
* Example of how to use the @ref clblasCher function.
* </pre>
*/
/**
* <pre>
* hermitian rank 1 operation with a general triangular matrix and
* double-complex elements.
*
* hermitian rank 1 operation:
*   - \f$ A \leftarrow \alpha X X^H + A \f$
*
* @param (in) order     Row/column order.
* @param (in) uplo      The triangle in matrix being referenced.
* @param (in) N         Number of columns in matrix \b A.
* @param (in) alpha     The factor of matrix \b A (a scalar double value)
* @param (in) X         Buffer object storing vector \b X.
* @param (in) offx      Offset in number of elements for the first element in vector \b X.
* @param (in) incx      Increment for the elements of \b X. Must not be zero.
* @param (out) A		Buffer object storing matrix \b A.
* @param (in) offa      Offset in number of elements for the first element in matrix \b A.
* @param (in) lda       Leading dimension of matrix \b A. It cannot be less
*                      than \b N.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasInvalidDevice if a target device does not support floating
*     point arithmetic with double precision;
*   - the same error codes as the clblasCher() function otherwise.
*
* @ingroup HER
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasZherNative(JNIEnv *env, jclass cls, jint order, jint uplo, jlong N, jdouble alpha, jobject X, jlong offx, jint incx, jobject A, jlong offa, jlong lda, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // N is primitive
    // alpha is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasZher");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasZher");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasZher");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasZher(order=%d, uplo=%d, N=%ld, alpha=%lf, X=%p, offx=%ld, incx=%d, A=%p, offa=%ld, lda=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, N, alpha, X, offx, incx, A, offa, lda, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    size_t N_native = 0;
    cl_double alpha_native;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    N_native = (size_t)N;
    alpha_native = (cl_double)alpha;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasZher(order_native, uplo_native, N_native, alpha_native, X_native, offx_native, incx_native, A_native, offa_native, lda_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // N is primitive
    // alpha is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**@}*/
/**
* <pre>
* @defgroup SYR2 SYR2  - Symmetric rank 2 update
*
* The Level 2 Basic Linear Algebra Subprograms are functions that perform
* symmetric rank 2 update operations.
* @ingroup BLAS2
* </pre>
*/
/**@{*/
/**
* <pre>
* Symmetric rank 2 operation with a general triangular matrix and
* float elements.
*
* Symmetric rank 2 operation:
*   - \f$ A \leftarrow \alpha x y^T + \alpha y x^T + A \f$
*
* @param (in) order     Row/column order.
* @param (in) uplo      The triangle in matrix being referenced.
* @param (in) N         Number of columns in matrix \b A.
* @param (in) alpha     The factor of matrix \b A.
* @param (in) X         Buffer object storing vector \b X.
* @param (in) offx      Offset of first element of vector \b X in buffer object.
* @param (in) incx      Increment for the elements of \b X. Must not be zero.
* @param (in) Y         Buffer object storing vector \b Y.
* @param (in) offy      Offset of first element of vector \b Y in buffer object.
* @param (in) incy      Increment for the elements of \b Y. Must not be zero.
* @param (out) A 	    Buffer object storing matrix \b A.
* @param (in) offa      Offset of first element of matrix \b A in buffer object.
* @param (in) lda       Leading dimension of matrix \b A. It cannot be less
*                      than \b N.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasNotInitialized if clblasSetup() was not called;
*   - \b clblasInvalidValue if invalid parameters are passed:
*     - either \b N is zero, or
*     - either \b incx or \b incy is zero, or
*     - the leading dimension is invalid;
*   - \b clblasInvalidMemObject if either \b A, \b X, or \b Y object is
*     Invalid, or an image object rather than the buffer one;
*   - \b clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   - \b clblasInvalidCommandQueue if the passed command queue is invalid;
*   - \b clblasInvalidContext if a context a passed command queue belongs
*     to was released;
*   - \b clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   - \b clblasCompilerNotAvailable if a compiler is not available;
*   - \b clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
* @ingroup SYR2
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasSsyr2Native(JNIEnv *env, jclass cls, jint order, jint uplo, jlong N, jfloat alpha, jobject X, jlong offx, jint incx, jobject Y, jlong offy, jint incy, jobject A, jlong offa, jlong lda, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // N is primitive
    // alpha is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasSsyr2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (Y == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasSsyr2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasSsyr2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasSsyr2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasSsyr2(order=%d, uplo=%d, N=%ld, alpha=%f, X=%p, offx=%ld, incx=%d, Y=%p, offy=%ld, incy=%d, A=%p, offa=%ld, lda=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, N, alpha, X, offx, incx, Y, offy, incy, A, offa, lda, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    size_t N_native = 0;
    cl_float alpha_native;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    N_native = (size_t)N;
    alpha_native = (cl_float)alpha;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_cl_mem(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasSsyr2(order_native, uplo_native, N_native, alpha_native, X_native, offx_native, incx_native, Y_native, offy_native, incy_native, A_native, offa_native, lda_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // N is primitive
    // alpha is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* Symmetric rank 2 operation with a general triangular matrix and
* double elements.
*
* Symmetric rank 2 operation:
*   - \f$ A \leftarrow \alpha x y^T + \alpha y x^T + A \f$
*
* @param (in) order     Row/column order.
* @param (in) uplo      The triangle in matrix being referenced.
* @param (in) N         Number of columns in matrix \b A.
* @param (in) alpha     The factor of matrix \b A.
* @param (in) X         Buffer object storing vector \b X.
* @param (in) offx      Offset of first element of vector \b X in buffer object.
* @param (in) incx      Increment for the elements of \b X. Must not be zero.
* @param (in) Y         Buffer object storing vector \b Y.
* @param (in) offy      Offset of first element of vector \b Y in buffer object.
* @param (in) incy      Increment for the elements of \b Y. Must not be zero.
* @param (out) A 	    Buffer object storing matrix \b A.
* @param (in) offa      Offset of first element of matrix \b A in buffer object.
* @param (in) lda       Leading dimension of matrix \b A. It cannot be less
*                      than \b N.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasNotInitialized if clblasSetup() was not called;
*   - \b clblasInvalidValue if invalid parameters are passed:
*     - either \b N is zero, or
*     - either \b incx or \b incy is zero, or
*     - the leading dimension is invalid;
*   - \b clblasInvalidMemObject if either \b A, \b X, or \b Y object is
*     Invalid, or an image object rather than the buffer one;
*   - \b clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   - \b clblasInvalidCommandQueue if the passed command queue is invalid;
*   - \b clblasInvalidContext if a context a passed command queue belongs
*     to was released;
*   - \b clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   - \b clblasCompilerNotAvailable if a compiler is not available;
*   - \b clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
* @ingroup SYR2
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasDsyr2Native(JNIEnv *env, jclass cls, jint order, jint uplo, jlong N, jdouble alpha, jobject X, jlong offx, jint incx, jobject Y, jlong offy, jint incy, jobject A, jlong offa, jlong lda, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // N is primitive
    // alpha is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasDsyr2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (Y == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasDsyr2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasDsyr2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasDsyr2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasDsyr2(order=%d, uplo=%d, N=%ld, alpha=%lf, X=%p, offx=%ld, incx=%d, Y=%p, offy=%ld, incy=%d, A=%p, offa=%ld, lda=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, N, alpha, X, offx, incx, Y, offy, incy, A, offa, lda, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    size_t N_native = 0;
    cl_double alpha_native;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    N_native = (size_t)N;
    alpha_native = (cl_double)alpha;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_cl_mem(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasDsyr2(order_native, uplo_native, N_native, alpha_native, X_native, offx_native, incx_native, Y_native, offy_native, incy_native, A_native, offa_native, lda_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // N is primitive
    // alpha is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**@}*/
/**
* <pre>
* @defgroup HER2 HER2  - Hermitian rank 2 update
*
* The Level 2 Basic Linear Algebra Subprograms are functions that perform
* hermitian rank 2 update operations.
* @ingroup BLAS2
* </pre>
*/
/**@{*/
/**
* <pre>
* Hermitian rank 2 operation with a general triangular matrix and
* float-compelx elements.
*
* Hermitian rank 2 operation:
*   - \f$ A \leftarrow \alpha X Y^H + \overline{ \alpha } Y X^H + A \f$
*
* @param (in) order     Row/column order.
* @param (in) uplo      The triangle in matrix being referenced.
* @param (in) N         Number of columns in matrix \b A.
* @param (in) alpha     The factor of matrix \b A.
* @param (in) X         Buffer object storing vector \b X.
* @param (in) offx      Offset in number of elements for the first element in vector \b X.
* @param (in) incx      Increment for the elements of \b X. Must not be zero.
* @param (in) Y         Buffer object storing vector \b Y.
* @param (in) offy      Offset in number of elements for the first element in vector \b Y.
* @param (in) incy      Increment for the elements of \b Y. Must not be zero.
* @param (out) A		Buffer object storing matrix \b A.
* @param (in) offa      Offset in number of elements for the first element in matrix \b A.
* @param (in) lda       Leading dimension of matrix \b A. It cannot be less
*                      than \b N.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasNotInitialized if clblasSetup() was not called;
*   - \b clblasInvalidValue if invalid parameters are passed:
*     - either \b N is zero, or
*     - either \b incx or \b incy is zero, or
*     - the leading dimension is invalid;
*   - \b clblasInvalidMemObject if either \b A, \b X, or \b Y object is
*     Invalid, or an image object rather than the buffer one;
*   - \b clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   - \b clblasInvalidCommandQueue if the passed command queue is invalid;
*   - \b clblasInvalidContext if a context a passed command queue belongs
*     to was released;
*   - \b clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   - \b clblasCompilerNotAvailable if a compiler is not available;
*   - \b clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
* @ingroup HER2
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasCher2Native(JNIEnv *env, jclass cls, jint order, jint uplo, jlong N, jfloatArray alpha, jobject X, jlong offx, jint incx, jobject Y, jlong offy, jint incy, jobject A, jlong offa, jlong lda, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // N is primitive
    if (alpha == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'alpha' is null for clblasCher2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasCher2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (Y == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasCher2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasCher2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasCher2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasCher2(order=%d, uplo=%d, N=%ld, alpha=%p, X=%p, offx=%ld, incx=%d, Y=%p, offy=%ld, incy=%d, A=%p, offa=%ld, lda=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, N, alpha, X, offx, incx, Y, offy, incy, A, offa, lda, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    size_t N_native = 0;
    cl_float2 alpha_native;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    N_native = (size_t)N;
    if (!init_cl_float2(env, alpha, alpha_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_cl_mem(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasCher2(order_native, uplo_native, N_native, alpha_native, X_native, offx_native, incx_native, Y_native, offy_native, incy_native, A_native, offa_native, lda_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // N is primitive
    if (!release_cl_float2(env, alpha_native, alpha, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* Hermitian rank 2 operation with a general triangular matrix and
* double-compelx elements.
*
* Hermitian rank 2 operation:
*   - \f$ A \leftarrow \alpha X Y^H + \overline{ \alpha } Y X^H + A \f$
*
* @param (in) order     Row/column order.
* @param (in) uplo      The triangle in matrix being referenced.
* @param (in) N         Number of columns in matrix \b A.
* @param (in) alpha     The factor of matrix \b A.
* @param (in) X         Buffer object storing vector \b X.
* @param (in) offx      Offset in number of elements for the first element in vector \b X.
* @param (in) incx      Increment for the elements of \b X. Must not be zero.
* @param (in) Y         Buffer object storing vector \b Y.
* @param (in) offy      Offset in number of elements for the first element in vector \b Y.
* @param (in) incy      Increment for the elements of \b Y. Must not be zero.
* @param (out) A		Buffer object storing matrix \b A.
* @param (in) offa      Offset in number of elements for the first element in matrix \b A.
* @param (in) lda       Leading dimension of matrix \b A. It cannot be less
*                      than \b N.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasInvalidDevice if a target device does not support floating
*     point arithmetic with double precision;
*   - the same error codes as the clblasCher2() function otherwise.
*
* @ingroup HER2
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasZher2Native(JNIEnv *env, jclass cls, jint order, jint uplo, jlong N, jdoubleArray alpha, jobject X, jlong offx, jint incx, jobject Y, jlong offy, jint incy, jobject A, jlong offa, jlong lda, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // N is primitive
    if (alpha == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'alpha' is null for clblasZher2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasZher2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (Y == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasZher2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasZher2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasZher2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasZher2(order=%d, uplo=%d, N=%ld, alpha=%p, X=%p, offx=%ld, incx=%d, Y=%p, offy=%ld, incy=%d, A=%p, offa=%ld, lda=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, N, alpha, X, offx, incx, Y, offy, incy, A, offa, lda, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    size_t N_native = 0;
    cl_double2 alpha_native;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    N_native = (size_t)N;
    if (!init_cl_double2(env, alpha, alpha_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_cl_mem(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasZher2(order_native, uplo_native, N_native, alpha_native, X_native, offx_native, incx_native, Y_native, offy_native, incy_native, A_native, offa_native, lda_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // N is primitive
    if (!release_cl_double2(env, alpha_native, alpha, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* @example example_zher2.c
* Example of how to use the @ref clblasZher2 function.
* </pre>
*/
/**@}*/
/**
* <pre>
* @defgroup TPMV TPMV  - Triangular packed matrix-vector multiply
* @ingroup BLAS2
* </pre>
*/
/**@{*/
/**
* <pre>
* Matrix-vector product with a packed triangular matrix and
* float elements.
*
* Matrix-vector products:
*   - \f$ X \leftarrow  A X \f$
*   - \f$ X \leftarrow  A^T X \f$
*
* @param (in) order     Row/column order.
* @param (in) uplo				The triangle in matrix being referenced.
* @param (in) trans				How matrix \b AP is to be transposed.
* @param (in) diag				Specify whether matrix \b AP is unit triangular.
* @param (in) N					Number of rows/columns in matrix \b A.
* @param (in) AP				Buffer object storing matrix \b AP in packed format.
* @param (in) offa				Offset in number of elements for first element in matrix \b AP.
* @param (out) X				Buffer object storing vector \b X.
* @param (in) offx				Offset in number of elements for first element in vector \b X.
* @param (in) incx				Increment for the elements of \b X. Must not be zero.
* @param (in) scratchBuff		Temporary cl_mem scratch buffer object which can hold a
*								minimum of (1 + (N-1)*abs(incx)) elements
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasNotInitialized if clblasSetup() was not called;
*   - \b clblasInvalidValue if invalid parameters are passed:
*     - either \b N or \b incx is zero
*   - \b clblasInvalidMemObject if either \b AP or \b X object is
*     Invalid, or an image object rather than the buffer one;
*   - \b clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   - \b clblasInvalidCommandQueue if the passed command queue is invalid;
*   - \b clblasInvalidContext if a context a passed command queue belongs
*     to was released;
*   - \b clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   - \b clblasCompilerNotAvailable if a compiler is not available;
*   - \b clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
* @ingroup TPMV
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasStpmvNative(JNIEnv *env, jclass cls, jint order, jint uplo, jint trans, jint diag, jlong N, jobject AP, jlong offa, jobject X, jlong offx, jint incx, jobject scratchBuff, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    if (AP == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'AP' is null for clblasStpmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasStpmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (scratchBuff == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'scratchBuff' is null for clblasStpmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasStpmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasStpmv(order=%d, uplo=%d, trans=%d, diag=%d, N=%ld, AP=%p, offa=%ld, X=%p, offx=%ld, incx=%d, scratchBuff=%p, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, trans, diag, N, AP, offa, X, offx, incx, scratchBuff, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    clblasTranspose trans_native;
    clblasDiag diag_native;
    size_t N_native = 0;
    cl_mem AP_native = nullptr;
    size_t offa_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem scratchBuff_native = nullptr;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    trans_native = (clblasTranspose)trans;
    diag_native = (clblasDiag)diag;
    N_native = (size_t)N;
    if (!init_cl_mem(env, AP, AP_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_cl_mem(env, scratchBuff, scratchBuff_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasStpmv(order_native, uplo_native, trans_native, diag_native, N_native, AP_native, offa_native, X_native, offx_native, incx_native, scratchBuff_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    // AP is a read-only native pointer
    // offa is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // scratchBuff is a read-only native pointer
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* @example example_stpmv.c
* Example of how to use the @ref clblasStpmv function.
* </pre>
*/
/**
* <pre>
* Matrix-vector product with a packed triangular matrix and
* double elements.
*
* Matrix-vector products:
*   - \f$ X \leftarrow  A X \f$
*   - \f$ X \leftarrow  A^T X \f$
*
* @param (in) order     Row/column order.
* @param (in) uplo				The triangle in matrix being referenced.
* @param (in) trans				How matrix \b AP is to be transposed.
* @param (in) diag				Specify whether matrix \b AP is unit triangular.
* @param (in) N					Number of rows/columns in matrix \b AP.
* @param (in) AP				Buffer object storing matrix \b AP in packed format.
* @param (in) offa				Offset in number of elements for first element in matrix \b AP.
* @param (out) X				Buffer object storing vector \b X.
* @param (in) offx				Offset in number of elements for first element in vector \b X.
* @param (in) incx				Increment for the elements of \b X. Must not be zero.
* @param (in) scratchBuff		Temporary cl_mem scratch buffer object which can hold a
*								minimum of (1 + (N-1)*abs(incx)) elements
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasInvalidDevice if a target device does not support floating
*     point arithmetic with double precision;
*   - the same error codes as the clblasStpmv() function otherwise.
*
* @ingroup TPMV
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasDtpmvNative(JNIEnv *env, jclass cls, jint order, jint uplo, jint trans, jint diag, jlong N, jobject AP, jlong offa, jobject X, jlong offx, jint incx, jobject scratchBuff, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    if (AP == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'AP' is null for clblasDtpmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasDtpmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (scratchBuff == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'scratchBuff' is null for clblasDtpmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasDtpmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasDtpmv(order=%d, uplo=%d, trans=%d, diag=%d, N=%ld, AP=%p, offa=%ld, X=%p, offx=%ld, incx=%d, scratchBuff=%p, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, trans, diag, N, AP, offa, X, offx, incx, scratchBuff, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    clblasTranspose trans_native;
    clblasDiag diag_native;
    size_t N_native = 0;
    cl_mem AP_native = nullptr;
    size_t offa_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem scratchBuff_native = nullptr;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    trans_native = (clblasTranspose)trans;
    diag_native = (clblasDiag)diag;
    N_native = (size_t)N;
    if (!init_cl_mem(env, AP, AP_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_cl_mem(env, scratchBuff, scratchBuff_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasDtpmv(order_native, uplo_native, trans_native, diag_native, N_native, AP_native, offa_native, X_native, offx_native, incx_native, scratchBuff_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    // AP is a read-only native pointer
    // offa is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // scratchBuff is a read-only native pointer
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* Matrix-vector product with a packed triangular matrix and
* float-complex elements.
*
* Matrix-vector products:
*   - \f$ X \leftarrow  A X \f$
*   - \f$ X \leftarrow  A^T X \f$
*
* @param (in) order     Row/column order.
* @param (in) uplo				The triangle in matrix being referenced.
* @param (in) trans				How matrix \b AP is to be transposed.
* @param (in) diag				Specify whether matrix \b AP is unit triangular.
* @param (in) N					Number of rows/columns in matrix \b AP.
* @param (in) AP				Buffer object storing matrix \b AP in packed format.
* @param (in) offa				Offset in number of elements for first element in matrix \b AP.
* @param (out) X				Buffer object storing vector \b X.
* @param (in) offx				Offset in number of elements for first element in vector \b X.
* @param (in) incx				Increment for the elements of \b X. Must not be zero.
* @param (in) scratchBuff		Temporary cl_mem scratch buffer object which can hold a
*								minimum of (1 + (N-1)*abs(incx)) elements
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return The same result as the clblasStpmv() function.
* @ingroup TPMV
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasCtpmvNative(JNIEnv *env, jclass cls, jint order, jint uplo, jint trans, jint diag, jlong N, jobject AP, jlong offa, jobject X, jlong offx, jint incx, jobject scratchBuff, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    if (AP == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'AP' is null for clblasCtpmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasCtpmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (scratchBuff == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'scratchBuff' is null for clblasCtpmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasCtpmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasCtpmv(order=%d, uplo=%d, trans=%d, diag=%d, N=%ld, AP=%p, offa=%ld, X=%p, offx=%ld, incx=%d, scratchBuff=%p, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, trans, diag, N, AP, offa, X, offx, incx, scratchBuff, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    clblasTranspose trans_native;
    clblasDiag diag_native;
    size_t N_native = 0;
    cl_mem AP_native = nullptr;
    size_t offa_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem scratchBuff_native = nullptr;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    trans_native = (clblasTranspose)trans;
    diag_native = (clblasDiag)diag;
    N_native = (size_t)N;
    if (!init_cl_mem(env, AP, AP_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_cl_mem(env, scratchBuff, scratchBuff_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasCtpmv(order_native, uplo_native, trans_native, diag_native, N_native, AP_native, offa_native, X_native, offx_native, incx_native, scratchBuff_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    // AP is a read-only native pointer
    // offa is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // scratchBuff is a read-only native pointer
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* Matrix-vector product with a packed triangular matrix and
* double-complex elements.
*
* Matrix-vector products:
*   - \f$ X \leftarrow  A X \f$
*   - \f$ X \leftarrow  A^T X \f$
*
* @param (in) order     Row/column order.
* @param (in) uplo				The triangle in matrix being referenced.
* @param (in) trans				How matrix \b AP is to be transposed.
* @param (in) diag				Specify whether matrix \b AP is unit triangular.
* @param (in) N					Number of rows/columns in matrix \b AP.
* @param (in) AP				Buffer object storing matrix \b AP in packed format.
* @param (in) offa				Offset in number of elements for first element in matrix \b AP.
* @param (out) X				Buffer object storing vector \b X.
* @param (in) offx				Offset in number of elements for first element in vector \b X.
* @param (in) incx				Increment for the elements of \b X. Must not be zero.
* @param (in) scratchBuff		Temporary cl_mem scratch buffer object which can hold a
*								minimum of (1 + (N-1)*abs(incx)) elements
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return The same result as the clblasDtpmv() function.
* @ingroup TPMV
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasZtpmvNative(JNIEnv *env, jclass cls, jint order, jint uplo, jint trans, jint diag, jlong N, jobject AP, jlong offa, jobject X, jlong offx, jint incx, jobject scratchBuff, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    if (AP == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'AP' is null for clblasZtpmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasZtpmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (scratchBuff == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'scratchBuff' is null for clblasZtpmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasZtpmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasZtpmv(order=%d, uplo=%d, trans=%d, diag=%d, N=%ld, AP=%p, offa=%ld, X=%p, offx=%ld, incx=%d, scratchBuff=%p, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, trans, diag, N, AP, offa, X, offx, incx, scratchBuff, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    clblasTranspose trans_native;
    clblasDiag diag_native;
    size_t N_native = 0;
    cl_mem AP_native = nullptr;
    size_t offa_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem scratchBuff_native = nullptr;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    trans_native = (clblasTranspose)trans;
    diag_native = (clblasDiag)diag;
    N_native = (size_t)N;
    if (!init_cl_mem(env, AP, AP_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_cl_mem(env, scratchBuff, scratchBuff_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasZtpmv(order_native, uplo_native, trans_native, diag_native, N_native, AP_native, offa_native, X_native, offx_native, incx_native, scratchBuff_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    // AP is a read-only native pointer
    // offa is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // scratchBuff is a read-only native pointer
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**@}*/
/**
* <pre>
* @defgroup TPSV TPSV  - Triangular packed matrix vector solve
* @ingroup BLAS2
* </pre>
*/
/**@{*/
/**
* <pre>
* solving triangular packed matrix problems with float elements.
*
* Matrix-vector products:
*   - \f$ A X \leftarrow  X \f$
*   - \f$ A^T X \leftarrow  X \f$
*
* @param (in) order     Row/column order.
* @param (in) uplo              The triangle in matrix being referenced.
* @param (in) trans             How matrix \b A is to be transposed.
* @param (in) diag              Specify whether matrix \b A is unit triangular.
* @param (in) N                 Number of rows/columns in matrix \b A.
* @param (in) A                 Buffer object storing matrix in packed format.\b A.
* @param (in) offa              Offset in number of elements for first element in matrix \b A.
* @param (out) X                Buffer object storing vector \b X.
* @param (in) offx              Offset in number of elements for first element in vector \b X.
* @param (in) incx              Increment for the elements of \b X. Must not be zero.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasNotInitialized if clblasSetup() was not called;
*   - \b clblasInvalidValue if invalid parameters are passed:
*     - either \b N or \b incx is zero, or
*     - the leading dimension is invalid;
*   - \b clblasInvalidMemObject if either \b A or \b X object is
*     Invalid, or an image object rather than the buffer one;
*   - \b clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   - \b clblasInvalidCommandQueue if the passed command queue is invalid;
*   - \b clblasInvalidContext if a context a passed command queue belongs
*     to was released;
*   - \b clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   - \b clblasCompilerNotAvailable if a compiler is not available;
*   - \b clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
* @ingroup TPSV
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasStpsvNative(JNIEnv *env, jclass cls, jint order, jint uplo, jint trans, jint diag, jlong N, jobject A, jlong offa, jobject X, jlong offx, jint incx, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasStpsv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasStpsv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasStpsv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasStpsv(order=%d, uplo=%d, trans=%d, diag=%d, N=%ld, A=%p, offa=%ld, X=%p, offx=%ld, incx=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, trans, diag, N, A, offa, X, offx, incx, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    clblasTranspose trans_native;
    clblasDiag diag_native;
    size_t N_native = 0;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    trans_native = (clblasTranspose)trans;
    diag_native = (clblasDiag)diag;
    N_native = (size_t)N;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasStpsv(order_native, uplo_native, trans_native, diag_native, N_native, A_native, offa_native, X_native, offx_native, incx_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    // A is a read-only native pointer
    // offa is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* @example example_stpsv.c
* Example of how to use the @ref clblasStpsv function.
* </pre>
*/
/**
* <pre>
* solving triangular packed matrix problems with double elements.
*
* Matrix-vector products:
*   - \f$ A X \leftarrow  X \f$
*   - \f$ A^T X \leftarrow  X \f$
*
* @param (in) order     Row/column order.
* @param (in) uplo              The triangle in matrix being referenced.
* @param (in) trans             How matrix \b A is to be transposed.
* @param (in) diag              Specify whether matrix \b A is unit triangular.
* @param (in) N                 Number of rows/columns in matrix \b A.
* @param (in) A                 Buffer object storing matrix in packed format.\b A.
* @param (in) offa              Offset in number of elements for first element in matrix \b A.
* @param (out) X                Buffer object storing vector \b X.
* @param (in) offx              Offset in number of elements for first element in vector \b X.
* @param (in) incx              Increment for the elements of \b X. Must not be zero.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasNotInitialized if clblasSetup() was not called;
*   - \b clblasInvalidValue if invalid parameters are passed:
*     - either \b N or \b incx is zero, or
*     - the leading dimension is invalid;
*   - \b clblasInvalidMemObject if either \b A or \b X object is
*     Invalid, or an image object rather than the buffer one;
*   - \b clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   - \b clblasInvalidCommandQueue if the passed command queue is invalid;
*   - \b clblasInvalidContext if a context a passed command queue belongs
*     to was released;
*   - \b clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   - \b clblasCompilerNotAvailable if a compiler is not available;
*   - \b clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
* @ingroup TPSV
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasDtpsvNative(JNIEnv *env, jclass cls, jint order, jint uplo, jint trans, jint diag, jlong N, jobject A, jlong offa, jobject X, jlong offx, jint incx, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasDtpsv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasDtpsv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasDtpsv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasDtpsv(order=%d, uplo=%d, trans=%d, diag=%d, N=%ld, A=%p, offa=%ld, X=%p, offx=%ld, incx=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, trans, diag, N, A, offa, X, offx, incx, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    clblasTranspose trans_native;
    clblasDiag diag_native;
    size_t N_native = 0;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    trans_native = (clblasTranspose)trans;
    diag_native = (clblasDiag)diag;
    N_native = (size_t)N;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasDtpsv(order_native, uplo_native, trans_native, diag_native, N_native, A_native, offa_native, X_native, offx_native, incx_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    // A is a read-only native pointer
    // offa is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* solving triangular packed matrix problems with float complex elements.
*
* Matrix-vector products:
*   - \f$ A X \leftarrow  X \f$
*   - \f$ A^T X \leftarrow  X \f$
*
* @param (in) order     Row/column order.
* @param (in) uplo              The triangle in matrix being referenced.
* @param (in) trans             How matrix \b A is to be transposed.
* @param (in) diag              Specify whether matrix \b A is unit triangular.
* @param (in) N                 Number of rows/columns in matrix \b A.
* @param (in) A                 Buffer object storing matrix in packed format.\b A.
* @param (in) offa              Offset in number of elements for first element in matrix \b A.
* @param (out) X                Buffer object storing vector \b X.
* @param (in) offx              Offset in number of elements for first element in vector \b X.
* @param (in) incx              Increment for the elements of \b X. Must not be zero.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasNotInitialized if clblasSetup() was not called;
*   - \b clblasInvalidValue if invalid parameters are passed:
*     - either \b N or \b incx is zero, or
*     - the leading dimension is invalid;
*   - \b clblasInvalidMemObject if either \b A or \b X object is
*     Invalid, or an image object rather than the buffer one;
*   - \b clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   - \b clblasInvalidCommandQueue if the passed command queue is invalid;
*   - \b clblasInvalidContext if a context a passed command queue belongs
*     to was released;
*   - \b clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   - \b clblasCompilerNotAvailable if a compiler is not available;
*   - \b clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
* @ingroup TPSV
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasCtpsvNative(JNIEnv *env, jclass cls, jint order, jint uplo, jint trans, jint diag, jlong N, jobject A, jlong offa, jobject X, jlong offx, jint incx, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasCtpsv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasCtpsv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasCtpsv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasCtpsv(order=%d, uplo=%d, trans=%d, diag=%d, N=%ld, A=%p, offa=%ld, X=%p, offx=%ld, incx=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, trans, diag, N, A, offa, X, offx, incx, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    clblasTranspose trans_native;
    clblasDiag diag_native;
    size_t N_native = 0;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    trans_native = (clblasTranspose)trans;
    diag_native = (clblasDiag)diag;
    N_native = (size_t)N;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasCtpsv(order_native, uplo_native, trans_native, diag_native, N_native, A_native, offa_native, X_native, offx_native, incx_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    // A is a read-only native pointer
    // offa is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* solving triangular packed matrix problems with double complex elements.
*
* Matrix-vector products:
*   - \f$ A X \leftarrow  X \f$
*   - \f$ A^T X \leftarrow  X \f$
*
* @param (in) order     Row/column order.
* @param (in) uplo              The triangle in matrix being referenced.
* @param (in) trans             How matrix \b A is to be transposed.
* @param (in) diag              Specify whether matrix \b A is unit triangular.
* @param (in) N                 Number of rows/columns in matrix \b A.
* @param (in) A                 Buffer object storing matrix in packed format.\b A.
* @param (in) offa              Offset in number of elements for first element in matrix \b A.
* @param (out) X                Buffer object storing vector \b X.
* @param (in) offx              Offset in number of elements for first element in vector \b X.
* @param (in) incx              Increment for the elements of \b X. Must not be zero.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasNotInitialized if clblasSetup() was not called;
*   - \b clblasInvalidValue if invalid parameters are passed:
*     - either \b N or \b incx is zero, or
*     - the leading dimension is invalid;
*   - \b clblasInvalidMemObject if either \b A or \b X object is
*     Invalid, or an image object rather than the buffer one;
*   - \b clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   - \b clblasInvalidCommandQueue if the passed command queue is invalid;
*   - \b clblasInvalidContext if a context a passed command queue belongs
*     to was released;
*   - \b clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   - \b clblasCompilerNotAvailable if a compiler is not available;
*   - \b clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
* @ingroup TPSV
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasZtpsvNative(JNIEnv *env, jclass cls, jint order, jint uplo, jint trans, jint diag, jlong N, jobject A, jlong offa, jobject X, jlong offx, jint incx, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasZtpsv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasZtpsv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasZtpsv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasZtpsv(order=%d, uplo=%d, trans=%d, diag=%d, N=%ld, A=%p, offa=%ld, X=%p, offx=%ld, incx=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, trans, diag, N, A, offa, X, offx, incx, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    clblasTranspose trans_native;
    clblasDiag diag_native;
    size_t N_native = 0;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    trans_native = (clblasTranspose)trans;
    diag_native = (clblasDiag)diag;
    N_native = (size_t)N;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasZtpsv(order_native, uplo_native, trans_native, diag_native, N_native, A_native, offa_native, X_native, offx_native, incx_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    // A is a read-only native pointer
    // offa is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**@}*/
/**
* <pre>
* @defgroup SPMV SPMV  - Symmetric packed matrix vector multiply
* @ingroup BLAS2
* </pre>
*/
/**@{*/
/**
* <pre>
* Matrix-vector product with a symmetric packed-matrix and float elements.
*
* Matrix-vector products:
* - \f$ Y \leftarrow \alpha A X + \beta Y \f$
*
* @param (in) order     Row/columns order.
* @param (in) uplo      The triangle in matrix being referenced.
* @param (in) N         Number of rows and columns in matrix \b AP.
* @param (in) alpha     The factor of matrix \b AP.
* @param (in) AP        Buffer object storing matrix \b AP.
* @param (in) offa		Offset in number of elements for first element in matrix \b AP.
* @param (in) X         Buffer object storing vector \b X.
* @param (in) offx      Offset of first element of vector \b X in buffer object.
*                      Counted in elements.
* @param (in) incx      Increment for the elements of vector \b X. It cannot be zero.
* @param (in) beta      The factor of vector \b Y.
* @param (out) Y        Buffer object storing vector \b Y.
* @param (in) offy      Offset of first element of vector \b Y in buffer object.
*                      Counted in elements.
* @param (in) incy      Increment for the elements of vector \b Y. It cannot be zero.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasNotInitialized if clblasSetup() was not called;
*   - \b clblasInvalidValue if invalid parameters are passed:
*     - \b N is zero, or
*     - either \b incx or \b incy is zero, or
*     - the matrix sizes or the vector sizes along with the increments lead to
*       accessing outsize of any of the buffers;
*   - \b clblasInvalidMemObject if either \b AP, \b X, or \b Y object is
*     invalid, or an image object rather than the buffer one;
*   - \b clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   - \b clblasInvalidCommandQueue if the passed command queue is invalid;
*   - \b clblasInvalidContext if a context a passed command queue belongs to
*     was released;
*   - \b clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   - \b clblasCompilerNotAvailable if a compiler is not available;
*   - \b clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
* @ingroup SPMV
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasSspmvNative(JNIEnv *env, jclass cls, jint order, jint uplo, jlong N, jfloat alpha, jobject AP, jlong offa, jobject X, jlong offx, jint incx, jfloat beta, jobject Y, jlong offy, jint incy, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // N is primitive
    // alpha is primitive
    if (AP == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'AP' is null for clblasSspmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasSspmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    // beta is primitive
    if (Y == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasSspmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasSspmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasSspmv(order=%d, uplo=%d, N=%ld, alpha=%f, AP=%p, offa=%ld, X=%p, offx=%ld, incx=%d, beta=%f, Y=%p, offy=%ld, incy=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, N, alpha, AP, offa, X, offx, incx, beta, Y, offy, incy, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    size_t N_native = 0;
    cl_float alpha_native;
    cl_mem AP_native = nullptr;
    size_t offa_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_float beta_native;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    N_native = (size_t)N;
    alpha_native = (cl_float)alpha;
    if (!init_cl_mem(env, AP, AP_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    beta_native = (cl_float)beta;
    if (!init_cl_mem(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasSspmv(order_native, uplo_native, N_native, alpha_native, AP_native, offa_native, X_native, offx_native, incx_native, beta_native, Y_native, offy_native, incy_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // N is primitive
    // alpha is primitive
    // AP is a read-only native pointer
    // offa is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // beta is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* @example example_sspmv.c
* This is an example of how to use the @ref clblasSspmv function.
* </pre>
*/
/**
* <pre>
* Matrix-vector product with a symmetric packed-matrix and double elements.
*
* Matrix-vector products:
* - \f$ Y \leftarrow \alpha A X + \beta Y \f$
*
* @param (in) order     Row/columns order.
* @param (in) uplo      The triangle in matrix being referenced.
* @param (in) N         Number of rows and columns in matrix \b AP.
* @param (in) alpha     The factor of matrix \b AP.
* @param (in) AP        Buffer object storing matrix \b AP.
* @param (in) offa		Offset in number of elements for first element in matrix \b AP.
* @param (in) X         Buffer object storing vector \b X.
* @param (in) offx      Offset of first element of vector \b X in buffer object.
*                      Counted in elements.
* @param (in) incx      Increment for the elements of vector \b X. It cannot be zero.
* @param (in) beta      The factor of vector \b Y.
* @param (out) Y        Buffer object storing vector \b Y.
* @param (in) offy      Offset of first element of vector \b Y in buffer object.
*                      Counted in elements.
* @param (in) incy      Increment for the elements of vector \b Y. It cannot be zero.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasInvalidDevice if a target device does not support floating
*     point arithmetic with double precision;
*   - the same error codes as the clblasSspmv() function otherwise.
*
* @ingroup SPMV
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasDspmvNative(JNIEnv *env, jclass cls, jint order, jint uplo, jlong N, jdouble alpha, jobject AP, jlong offa, jobject X, jlong offx, jint incx, jdouble beta, jobject Y, jlong offy, jint incy, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // N is primitive
    // alpha is primitive
    if (AP == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'AP' is null for clblasDspmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasDspmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    // beta is primitive
    if (Y == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasDspmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasDspmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasDspmv(order=%d, uplo=%d, N=%ld, alpha=%lf, AP=%p, offa=%ld, X=%p, offx=%ld, incx=%d, beta=%lf, Y=%p, offy=%ld, incy=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, N, alpha, AP, offa, X, offx, incx, beta, Y, offy, incy, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    size_t N_native = 0;
    cl_double alpha_native;
    cl_mem AP_native = nullptr;
    size_t offa_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_double beta_native;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    N_native = (size_t)N;
    alpha_native = (cl_double)alpha;
    if (!init_cl_mem(env, AP, AP_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    beta_native = (cl_double)beta;
    if (!init_cl_mem(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasDspmv(order_native, uplo_native, N_native, alpha_native, AP_native, offa_native, X_native, offx_native, incx_native, beta_native, Y_native, offy_native, incy_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // N is primitive
    // alpha is primitive
    // AP is a read-only native pointer
    // offa is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // beta is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**@}*/
/**
* <pre>
* @defgroup HPMV HPMV  - Hermitian packed matrix-vector multiplication
* @ingroup BLAS2
* </pre>
*/
/**@{*/
/**
* <pre>
* Matrix-vector product with a packed hermitian matrix and float-complex elements.
*
* Matrix-vector products:
* - \f$ Y \leftarrow \alpha A X + \beta Y \f$
*
* @param (in) order     Row/columns order.
* @param (in) uplo      The triangle in matrix being referenced.
* @param (in) N         Number of rows and columns in matrix \b AP.
* @param (in) alpha     The factor of matrix \b AP.
* @param (in) AP        Buffer object storing packed matrix \b AP.
* @param (in) offa		Offset in number of elements for first element in matrix \b AP.
* @param (in) X         Buffer object storing vector \b X.
* @param (in) offx      Offset of first element of vector \b X in buffer object.
*                      Counted in elements.
* @param (in) incx      Increment for the elements of vector \b X. It cannot be zero.
* @param (in) beta      The factor of vector \b Y.
* @param (out) Y        Buffer object storing vector \b Y.
* @param (in) offy      Offset of first element of vector \b Y in buffer object.
*                      Counted in elements.
* @param (in) incy      Increment for the elements of vector \b Y. It cannot be zero.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasNotInitialized if clblasSetup() was not called;
*   - \b clblasInvalidValue if invalid parameters are passed:
*     - \b N is zero, or
*     - either \b incx or \b incy is zero, or
*     - the matrix sizes or the vector sizes along with the increments lead to
*       accessing outsize of any of the buffers;
*   - \b clblasInvalidMemObject if either \b AP, \b X, or \b Y object is
*     invalid, or an image object rather than the buffer one;
*   - \b clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   - \b clblasInvalidCommandQueue if the passed command queue is invalid;
*   - \b clblasInvalidContext if a context a passed command queue belongs to
*     was released;
*   - \b clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   - \b clblasCompilerNotAvailable if a compiler is not available;
*   - \b clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
* @ingroup HPMV
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasChpmvNative(JNIEnv *env, jclass cls, jint order, jint uplo, jlong N, jfloatArray alpha, jobject AP, jlong offa, jobject X, jlong offx, jint incx, jfloatArray beta, jobject Y, jlong offy, jint incy, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // N is primitive
    if (alpha == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'alpha' is null for clblasChpmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (AP == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'AP' is null for clblasChpmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasChpmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (beta == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'beta' is null for clblasChpmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (Y == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasChpmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasChpmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasChpmv(order=%d, uplo=%d, N=%ld, alpha=%p, AP=%p, offa=%ld, X=%p, offx=%ld, incx=%d, beta=%p, Y=%p, offy=%ld, incy=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, N, alpha, AP, offa, X, offx, incx, beta, Y, offy, incy, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    size_t N_native = 0;
    cl_float2 alpha_native;
    cl_mem AP_native = nullptr;
    size_t offa_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_float2 beta_native;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    N_native = (size_t)N;
    if (!init_cl_float2(env, alpha, alpha_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_mem(env, AP, AP_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_cl_float2(env, beta, beta_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_mem(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasChpmv(order_native, uplo_native, N_native, alpha_native, AP_native, offa_native, X_native, offx_native, incx_native, beta_native, Y_native, offy_native, incy_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // N is primitive
    if (!release_cl_float2(env, alpha_native, alpha, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // AP is a read-only native pointer
    // offa is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    if (!release_cl_float2(env, beta_native, beta, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* @example example_chpmv.c
* This is an example of how to use the @ref clblasChpmv function.
* </pre>
*/
/**
* <pre>
* Matrix-vector product with a packed hermitian matrix and double-complex elements.
*
* Matrix-vector products:
* - \f$ Y \leftarrow \alpha A X + \beta Y \f$
*
* @param (in) order     Row/columns order.
* @param (in) uplo      The triangle in matrix being referenced.
* @param (in) N         Number of rows and columns in matrix \b AP.
* @param (in) alpha     The factor of matrix \b AP.
* @param (in) AP        Buffer object storing packed matrix \b AP.
* @param (in) offa		Offset in number of elements for first element in matrix \b AP.
* @param (in) X         Buffer object storing vector \b X.
* @param (in) offx      Offset of first element of vector \b X in buffer object.
*                      Counted in elements.
* @param (in) incx      Increment for the elements of vector \b X. It cannot be zero.
* @param (in) beta      The factor of vector \b Y.
* @param (out) Y        Buffer object storing vector \b Y.
* @param (in) offy      Offset of first element of vector \b Y in buffer object.
*                      Counted in elements.
* @param (in) incy      Increment for the elements of vector \b Y. It cannot be zero.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasInvalidDevice if a target device does not support floating
*     point arithmetic with double precision;
*   - the same error codes as the clblasChpmv() function otherwise.
*
* @ingroup HPMV
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasZhpmvNative(JNIEnv *env, jclass cls, jint order, jint uplo, jlong N, jdoubleArray alpha, jobject AP, jlong offa, jobject X, jlong offx, jint incx, jdoubleArray beta, jobject Y, jlong offy, jint incy, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // N is primitive
    if (alpha == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'alpha' is null for clblasZhpmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (AP == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'AP' is null for clblasZhpmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasZhpmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (beta == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'beta' is null for clblasZhpmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (Y == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasZhpmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasZhpmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasZhpmv(order=%d, uplo=%d, N=%ld, alpha=%p, AP=%p, offa=%ld, X=%p, offx=%ld, incx=%d, beta=%p, Y=%p, offy=%ld, incy=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, N, alpha, AP, offa, X, offx, incx, beta, Y, offy, incy, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    size_t N_native = 0;
    cl_double2 alpha_native;
    cl_mem AP_native = nullptr;
    size_t offa_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_double2 beta_native;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    N_native = (size_t)N;
    if (!init_cl_double2(env, alpha, alpha_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_mem(env, AP, AP_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_cl_double2(env, beta, beta_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_mem(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasZhpmv(order_native, uplo_native, N_native, alpha_native, AP_native, offa_native, X_native, offx_native, incx_native, beta_native, Y_native, offy_native, incy_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // N is primitive
    if (!release_cl_double2(env, alpha_native, alpha, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // AP is a read-only native pointer
    // offa is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    if (!release_cl_double2(env, beta_native, beta, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**@}*/
/**
* <pre>
* @defgroup SPR SPR   - Symmetric packed matrix rank 1 update
*
* The Level 2 Basic Linear Algebra Subprograms are functions that perform
* symmetric rank 1 update operations on packed matrix
* @ingroup BLAS2
* </pre>
*/
/**@{*/
/**
* <pre>
* Symmetric rank 1 operation with a general triangular packed-matrix and
* float elements.
*
* Symmetric rank 1 operation:
*   - \f$ A \leftarrow \alpha X X^T + A \f$
*
* @param (in) order     Row/column order.
* @param (in) uplo      The triangle in matrix being referenced.
* @param (in) N         Number of columns in matrix \b A.
* @param (in) alpha     The factor of matrix \b A.
* @param (in) X         Buffer object storing vector \b X.
* @param (in) offx      Offset of first element of vector \b X in buffer object.
* @param (in) incx      Increment for the elements of \b X. Must not be zero.
* @param (out) AP 	    Buffer object storing packed-matrix \b AP.
* @param (in) offa      Offset of first element of matrix \b AP in buffer object.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasNotInitialized if clblasSetup() was not called;
*   - \b clblasInvalidValue if invalid parameters are passed:
*     - \b N is zero, or
*     - either \b incx is zero
*   - \b clblasInvalidMemObject if either \b AP, \b X object is
*     Invalid, or an image object rather than the buffer one;
*   - \b clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   - \b clblasInvalidCommandQueue if the passed command queue is invalid;
*   - \b clblasInvalidContext if a context a passed command queue belongs
*     to was released;
*   - \b clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   - \b clblasCompilerNotAvailable if a compiler is not available;
*   - \b clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
* @ingroup SPR
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasSsprNative(JNIEnv *env, jclass cls, jint order, jint uplo, jlong N, jfloat alpha, jobject X, jlong offx, jint incx, jobject AP, jlong offa, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // N is primitive
    // alpha is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasSspr");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (AP == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'AP' is null for clblasSspr");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasSspr");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasSspr(order=%d, uplo=%d, N=%ld, alpha=%f, X=%p, offx=%ld, incx=%d, AP=%p, offa=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, N, alpha, X, offx, incx, AP, offa, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    size_t N_native = 0;
    cl_float alpha_native;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem AP_native = nullptr;
    size_t offa_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    N_native = (size_t)N;
    alpha_native = (cl_float)alpha;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_cl_mem(env, AP, AP_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasSspr(order_native, uplo_native, N_native, alpha_native, X_native, offx_native, incx_native, AP_native, offa_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // N is primitive
    // alpha is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // AP is a read-only native pointer
    // offa is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* @example example_sspr.c
* Example of how to use the @ref clblasSspr function.
* </pre>
*/
/**
* <pre>
* Symmetric rank 1 operation with a general triangular packed-matrix and
* double elements.
*
* Symmetric rank 1 operation:
*   - \f$ A \leftarrow \alpha X X^T + A \f$
*
* @param (in) order     Row/column order.
* @param (in) uplo      The triangle in matrix being referenced.
* @param (in) N         Number of columns in matrix \b A.
* @param (in) alpha     The factor of matrix \b A.
* @param (in) X         Buffer object storing vector \b X.
* @param (in) offx      Offset of first element of vector \b X in buffer object.
* @param (in) incx      Increment for the elements of \b X. Must not be zero.
* @param (out) AP 	    Buffer object storing packed-matrix \b AP.
* @param (in) offa      Offset of first element of matrix \b AP in buffer object.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasInvalidDevice if a target device does not support floating
*     point arithmetic with double precision;
*   - the same error codes as the clblasSspr() function otherwise.
*
* @ingroup SPR
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasDsprNative(JNIEnv *env, jclass cls, jint order, jint uplo, jlong N, jdouble alpha, jobject X, jlong offx, jint incx, jobject AP, jlong offa, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // N is primitive
    // alpha is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasDspr");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (AP == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'AP' is null for clblasDspr");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasDspr");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasDspr(order=%d, uplo=%d, N=%ld, alpha=%lf, X=%p, offx=%ld, incx=%d, AP=%p, offa=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, N, alpha, X, offx, incx, AP, offa, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    size_t N_native = 0;
    cl_double alpha_native;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem AP_native = nullptr;
    size_t offa_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    N_native = (size_t)N;
    alpha_native = (cl_double)alpha;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_cl_mem(env, AP, AP_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasDspr(order_native, uplo_native, N_native, alpha_native, X_native, offx_native, incx_native, AP_native, offa_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // N is primitive
    // alpha is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // AP is a read-only native pointer
    // offa is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**@}*/
/**
* <pre>
* @defgroup HPR HPR   - Hermitian packed matrix rank 1 update
*
* The Level 2 Basic Linear Algebra Subprogram functions that perform
* hermitian rank 1 operations on packed matrix
* @ingroup BLAS2
* </pre>
*/
/**@{*/
/**
* <pre>
* hermitian rank 1 operation with a general triangular packed-matrix and
* float-complex elements.
*
* hermitian rank 1 operation:
*   - \f$ A \leftarrow \alpha X X^H + A \f$
*
* @param (in) order     Row/column order.
* @param (in) uplo      The triangle in matrix being referenced.
* @param (in) N         Number of columns in matrix \b A.
* @param (in) alpha     The factor of matrix \b A (a scalar float value)
* @param (in) X         Buffer object storing vector \b X.
* @param (in) offx      Offset in number of elements for the first element in vector \b X.
* @param (in) incx      Increment for the elements of \b X. Must not be zero.
* @param (out) AP 	    Buffer object storing matrix \b AP.
* @param (in) offa      Offset in number of elements for the first element in matrix \b AP.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasNotInitialized if clblasSetup() was not called;
*   - \b clblasInvalidValue if invalid parameters are passed:
*     - \b N is zero, or
*     - either \b incx is zero
*   - \b clblasInvalidMemObject if either \b AP, \b X object is
*     Invalid, or an image object rather than the buffer one;
*   - \b clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   - \b clblasInvalidCommandQueue if the passed command queue is invalid;
*   - \b clblasInvalidContext if a context a passed command queue belongs
*     to was released;
*   - \b clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   - \b clblasCompilerNotAvailable if a compiler is not available;
*   - \b clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
* @ingroup HPR
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasChprNative(JNIEnv *env, jclass cls, jint order, jint uplo, jlong N, jfloat alpha, jobject X, jlong offx, jint incx, jobject AP, jlong offa, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // N is primitive
    // alpha is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasChpr");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (AP == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'AP' is null for clblasChpr");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasChpr");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasChpr(order=%d, uplo=%d, N=%ld, alpha=%f, X=%p, offx=%ld, incx=%d, AP=%p, offa=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, N, alpha, X, offx, incx, AP, offa, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    size_t N_native = 0;
    cl_float alpha_native;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem AP_native = nullptr;
    size_t offa_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    N_native = (size_t)N;
    alpha_native = (cl_float)alpha;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_cl_mem(env, AP, AP_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasChpr(order_native, uplo_native, N_native, alpha_native, X_native, offx_native, incx_native, AP_native, offa_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // N is primitive
    // alpha is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // AP is a read-only native pointer
    // offa is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* @example example_chpr.c
* Example of how to use the @ref clblasChpr function.
* </pre>
*/
/**
* <pre>
* hermitian rank 1 operation with a general triangular packed-matrix and
* double-complex elements.
*
* hermitian rank 1 operation:
*   - \f$ A \leftarrow \alpha X X^H + A \f$
*
* @param (in) order     Row/column order.
* @param (in) uplo      The triangle in matrix being referenced.
* @param (in) N         Number of columns in matrix \b A.
* @param (in) alpha     The factor of matrix \b A (a scalar float value)
* @param (in) X         Buffer object storing vector \b X.
* @param (in) offx      Offset in number of elements for the first element in vector \b X.
* @param (in) incx      Increment for the elements of \b X. Must not be zero.
* @param (out) AP 	    Buffer object storing matrix \b AP.
* @param (in) offa      Offset in number of elements for the first element in matrix \b AP.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasInvalidDevice if a target device does not support floating
*     point arithmetic with double precision;
*   - the same error codes as the clblasChpr() function otherwise.
*
* @ingroup HPR
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasZhprNative(JNIEnv *env, jclass cls, jint order, jint uplo, jlong N, jdouble alpha, jobject X, jlong offx, jint incx, jobject AP, jlong offa, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // N is primitive
    // alpha is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasZhpr");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (AP == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'AP' is null for clblasZhpr");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasZhpr");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasZhpr(order=%d, uplo=%d, N=%ld, alpha=%lf, X=%p, offx=%ld, incx=%d, AP=%p, offa=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, N, alpha, X, offx, incx, AP, offa, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    size_t N_native = 0;
    cl_double alpha_native;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem AP_native = nullptr;
    size_t offa_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    N_native = (size_t)N;
    alpha_native = (cl_double)alpha;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_cl_mem(env, AP, AP_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasZhpr(order_native, uplo_native, N_native, alpha_native, X_native, offx_native, incx_native, AP_native, offa_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // N is primitive
    // alpha is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // AP is a read-only native pointer
    // offa is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**@}*/
/**
* <pre>
* @defgroup SPR2 SPR2  - Symmetric packed matrix rank 2 update
*
* The Level 2 Basic Linear Algebra Subprograms are functions that perform
* symmetric rank 2 update operations on packed matrices
* @ingroup BLAS2
* </pre>
*/
/**@{*/
/**
* <pre>
* Symmetric rank 2 operation with a general triangular packed-matrix and
* float elements.
*
* Symmetric rank 2 operation:
*   - \f$ A \leftarrow \alpha X Y^T + \alpha Y X^T + A \f$
*
* @param (in) order     Row/column order.
* @param (in) uplo      The triangle in matrix being referenced.
* @param (in) N         Number of columns in matrix \b A.
* @param (in) alpha     The factor of matrix \b A.
* @param (in) X         Buffer object storing vector \b X.
* @param (in) offx      Offset of first element of vector \b X in buffer object.
* @param (in) incx      Increment for the elements of \b X. Must not be zero.
* @param (in) Y         Buffer object storing vector \b Y.
* @param (in) offy      Offset of first element of vector \b Y in buffer object.
* @param (in) incy      Increment for the elements of \b Y. Must not be zero.
* @param (out) AP		Buffer object storing packed-matrix \b AP.
* @param (in) offa      Offset of first element of matrix \b AP in buffer object.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasNotInitialized if clblasSetup() was not called;
*   - \b clblasInvalidValue if invalid parameters are passed:
*     - either \b N is zero, or
*     - either \b incx or \b incy is zero
*   - \b clblasInvalidMemObject if either \b AP, \b X, or \b Y object is
*     Invalid, or an image object rather than the buffer one;
*   - \b clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   - \b clblasInvalidCommandQueue if the passed command queue is invalid;
*   - \b clblasInvalidContext if a context a passed command queue belongs
*     to was released;
*   - \b clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   - \b clblasCompilerNotAvailable if a compiler is not available;
*   - \b clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
* @ingroup SPR2
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasSspr2Native(JNIEnv *env, jclass cls, jint order, jint uplo, jlong N, jfloat alpha, jobject X, jlong offx, jint incx, jobject Y, jlong offy, jint incy, jobject AP, jlong offa, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // N is primitive
    // alpha is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasSspr2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (Y == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasSspr2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    if (AP == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'AP' is null for clblasSspr2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasSspr2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasSspr2(order=%d, uplo=%d, N=%ld, alpha=%f, X=%p, offx=%ld, incx=%d, Y=%p, offy=%ld, incy=%d, AP=%p, offa=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, N, alpha, X, offx, incx, Y, offy, incy, AP, offa, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    size_t N_native = 0;
    cl_float alpha_native;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_mem AP_native = nullptr;
    size_t offa_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    N_native = (size_t)N;
    alpha_native = (cl_float)alpha;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_cl_mem(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    if (!init_cl_mem(env, AP, AP_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasSspr2(order_native, uplo_native, N_native, alpha_native, X_native, offx_native, incx_native, Y_native, offy_native, incy_native, AP_native, offa_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // N is primitive
    // alpha is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // AP is a read-only native pointer
    // offa is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* @example example_sspr2.c
* Example of how to use the @ref clblasSspr2 function.
* </pre>
*/
/**
* <pre>
* Symmetric rank 2 operation with a general triangular packed-matrix and
* double elements.
*
* Symmetric rank 2 operation:
*   - \f$ A \leftarrow \alpha X Y^T + \alpha Y X^T + A \f$
*
* @param (in) order     Row/column order.
* @param (in) uplo      The triangle in matrix being referenced.
* @param (in) N         Number of columns in matrix \b A.
* @param (in) alpha     The factor of matrix \b A.
* @param (in) X         Buffer object storing vector \b X.
* @param (in) offx      Offset of first element of vector \b X in buffer object.
* @param (in) incx      Increment for the elements of \b X. Must not be zero.
* @param (in) Y         Buffer object storing vector \b Y.
* @param (in) offy      Offset of first element of vector \b Y in buffer object.
* @param (in) incy      Increment for the elements of \b Y. Must not be zero.
* @param (out) AP		Buffer object storing packed-matrix \b AP.
* @param (in) offa      Offset of first element of matrix \b AP in buffer object.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasInvalidDevice if a target device does not support floating
*     point arithmetic with double precision;
*   - the same error codes as the clblasSspr2() function otherwise.
*
* @ingroup SPR2
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasDspr2Native(JNIEnv *env, jclass cls, jint order, jint uplo, jlong N, jdouble alpha, jobject X, jlong offx, jint incx, jobject Y, jlong offy, jint incy, jobject AP, jlong offa, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // N is primitive
    // alpha is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasDspr2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (Y == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasDspr2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    if (AP == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'AP' is null for clblasDspr2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasDspr2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasDspr2(order=%d, uplo=%d, N=%ld, alpha=%lf, X=%p, offx=%ld, incx=%d, Y=%p, offy=%ld, incy=%d, AP=%p, offa=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, N, alpha, X, offx, incx, Y, offy, incy, AP, offa, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    size_t N_native = 0;
    cl_double alpha_native;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_mem AP_native = nullptr;
    size_t offa_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    N_native = (size_t)N;
    alpha_native = (cl_double)alpha;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_cl_mem(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    if (!init_cl_mem(env, AP, AP_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasDspr2(order_native, uplo_native, N_native, alpha_native, X_native, offx_native, incx_native, Y_native, offy_native, incy_native, AP_native, offa_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // N is primitive
    // alpha is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // AP is a read-only native pointer
    // offa is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**@}*/
/**
* <pre>
* @defgroup HPR2 HPR2  - Hermitian packed matrix rank 2 update
*
* The Level 2 Basic Linear Algebra Subprograms are functions that perform
* hermitian rank 2 update operations on packed matrices
* @ingroup BLAS2
* </pre>
*/
/**@{*/
/**
* <pre>
* Hermitian rank 2 operation with a general triangular packed-matrix and
* float-compelx elements.
*
* Hermitian rank 2 operation:
*   - \f$ A \leftarrow \alpha X Y^H + \conjg( alpha ) Y X^H + A \f$
*
* @param (in) order     Row/column order.
* @param (in) uplo      The triangle in matrix being referenced.
* @param (in) N         Number of columns in matrix \b A.
* @param (in) alpha     The factor of matrix \b A.
* @param (in) X         Buffer object storing vector \b X.
* @param (in) offx      Offset in number of elements for the first element in vector \b X.
* @param (in) incx      Increment for the elements of \b X. Must not be zero.
* @param (in) Y         Buffer object storing vector \b Y.
* @param (in) offy      Offset in number of elements for the first element in vector \b Y.
* @param (in) incy      Increment for the elements of \b Y. Must not be zero.
* @param (out) AP		Buffer object storing packed-matrix \b AP.
* @param (in) offa      Offset in number of elements for the first element in matrix \b AP.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasNotInitialized if clblasSetup() was not called;
*   - \b clblasInvalidValue if invalid parameters are passed:
*     - either \b N is zero, or
*     - either \b incx or \b incy is zero
*   - \b clblasInvalidMemObject if either \b AP, \b X, or \b Y object is
*     Invalid, or an image object rather than the buffer one;
*   - \b clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   - \b clblasInvalidCommandQueue if the passed command queue is invalid;
*   - \b clblasInvalidContext if a context a passed command queue belongs
*     to was released;
*   - \b clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   - \b clblasCompilerNotAvailable if a compiler is not available;
*   - \b clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
* @ingroup HPR2
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasChpr2Native(JNIEnv *env, jclass cls, jint order, jint uplo, jlong N, jfloatArray alpha, jobject X, jlong offx, jint incx, jobject Y, jlong offy, jint incy, jobject AP, jlong offa, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // N is primitive
    if (alpha == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'alpha' is null for clblasChpr2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasChpr2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (Y == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasChpr2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    if (AP == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'AP' is null for clblasChpr2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasChpr2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasChpr2(order=%d, uplo=%d, N=%ld, alpha=%p, X=%p, offx=%ld, incx=%d, Y=%p, offy=%ld, incy=%d, AP=%p, offa=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, N, alpha, X, offx, incx, Y, offy, incy, AP, offa, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    size_t N_native = 0;
    cl_float2 alpha_native;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_mem AP_native = nullptr;
    size_t offa_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    N_native = (size_t)N;
    if (!init_cl_float2(env, alpha, alpha_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_cl_mem(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    if (!init_cl_mem(env, AP, AP_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasChpr2(order_native, uplo_native, N_native, alpha_native, X_native, offx_native, incx_native, Y_native, offy_native, incy_native, AP_native, offa_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // N is primitive
    if (!release_cl_float2(env, alpha_native, alpha, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // AP is a read-only native pointer
    // offa is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* Hermitian rank 2 operation with a general triangular packed-matrix and
* double-compelx elements.
*
* Hermitian rank 2 operation:
*   - \f$ A \leftarrow \alpha X Y^H + \conjg( alpha ) Y X^H + A \f$
*
* @param (in) order     Row/column order.
* @param (in) uplo      The triangle in matrix being referenced.
* @param (in) N         Number of columns in matrix \b A.
* @param (in) alpha     The factor of matrix \b A.
* @param (in) X         Buffer object storing vector \b X.
* @param (in) offx      Offset in number of elements for the first element in vector \b X.
* @param (in) incx      Increment for the elements of \b X. Must not be zero.
* @param (in) Y         Buffer object storing vector \b Y.
* @param (in) offy      Offset in number of elements for the first element in vector \b Y.
* @param (in) incy      Increment for the elements of \b Y. Must not be zero.
* @param (out) AP		Buffer object storing packed-matrix \b AP.
* @param (in) offa      Offset in number of elements for the first element in matrix \b AP.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasInvalidDevice if a target device does not support floating
*     point arithmetic with double precision;
*   - the same error codes as the clblasChpr2() function otherwise.
*
* @ingroup HPR2
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasZhpr2Native(JNIEnv *env, jclass cls, jint order, jint uplo, jlong N, jdoubleArray alpha, jobject X, jlong offx, jint incx, jobject Y, jlong offy, jint incy, jobject AP, jlong offa, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // N is primitive
    if (alpha == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'alpha' is null for clblasZhpr2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasZhpr2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (Y == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasZhpr2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    if (AP == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'AP' is null for clblasZhpr2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasZhpr2");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasZhpr2(order=%d, uplo=%d, N=%ld, alpha=%p, X=%p, offx=%ld, incx=%d, Y=%p, offy=%ld, incy=%d, AP=%p, offa=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, N, alpha, X, offx, incx, Y, offy, incy, AP, offa, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    size_t N_native = 0;
    cl_double2 alpha_native;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_mem AP_native = nullptr;
    size_t offa_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    N_native = (size_t)N;
    if (!init_cl_double2(env, alpha, alpha_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_cl_mem(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    if (!init_cl_mem(env, AP, AP_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasZhpr2(order_native, uplo_native, N_native, alpha_native, X_native, offx_native, incx_native, Y_native, offy_native, incy_native, AP_native, offa_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // N is primitive
    if (!release_cl_double2(env, alpha_native, alpha, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // AP is a read-only native pointer
    // offa is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* @example example_zhpr2.c
* Example of how to use the @ref clblasZhpr2 function.
* </pre>
*/
/**@}*/
/**
* <pre>
* @defgroup GBMV GBMV  - General banded matrix-vector multiplication
* @ingroup BLAS2
* </pre>
*/
/**@{*/
/**
* <pre>
* Matrix-vector product with a general rectangular banded matrix and
* float elements.
*
* Matrix-vector products:
*   - \f$ Y \leftarrow \alpha A X + \beta Y \f$
*   - \f$ Y \leftarrow \alpha A^T X + \beta Y \f$
*
* @param (in) order     Row/column order.
* @param (in) trans     How matrix \b A is to be transposed.
* @param (in) M         Number of rows in banded matrix \b A.
* @param (in) N         Number of columns in banded matrix \b A.
* @param (in) KL        Number of sub-diagonals in banded matrix \b A.
* @param (in) KU        Number of super-diagonals in banded matrix \b A.
* @param (in) alpha     The factor of banded matrix \b A.
* @param (in) A         Buffer object storing banded matrix \b A.
* @param (in) offa      Offset in number of elements for the first element in banded matrix \b A.
* @param (in) lda       Leading dimension of banded matrix \b A. It cannot be less
*                      than ( \b KL + \b KU + 1 )
* @param (in) X         Buffer object storing vector \b X.
* @param (in) offx      Offset of first element of vector \b X in buffer object.
*                      Counted in elements.
* @param (in) incx      Increment for the elements of \b X. Must not be zero.
* @param (in) beta      The factor of the vector \b Y.
* @param (out) Y        Buffer object storing the vector \b y.
* @param (in) offy      Offset of first element of vector \b Y in buffer object.
*                      Counted in elements.
* @param (in) incy      Increment for the elements of \b Y. Must not be zero.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasNotInitialized if clblasSetup() was not called;
*   - \b clblasInvalidValue if invalid parameters are passed:
*     - either \b M or \b N is zero, or
*     - KL is greater than \b M - 1, or
*     - KU is greater than \b N - 1, or
*     - either \b incx or \b incy is zero, or
*     - any of the leading dimensions is invalid;
*     - the matrix size or the vector sizes along with the increments lead to
*       accessing outside of any of the buffers;
*   - \b clblasInvalidMemObject if either \b A, \b X, or \b Y object is
*     Invalid, or an image object rather than the buffer one;
*   - \b clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   - \b clblasInvalidCommandQueue if the passed command queue is invalid;
*   - \b clblasInvalidContext if a context a passed command queue belongs
*     to was released;
*   - \b clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   - \b clblasCompilerNotAvailable if a compiler is not available;
*   - \b clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
* @ingroup GBMV
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasSgbmvNative(JNIEnv *env, jclass cls, jint order, jint trans, jlong M, jlong N, jlong KL, jlong KU, jfloat alpha, jobject A, jlong offa, jlong lda, jobject X, jlong offx, jint incx, jfloat beta, jobject Y, jlong offy, jint incy, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // trans is primitive
    // M is primitive
    // N is primitive
    // KL is primitive
    // KU is primitive
    // alpha is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasSgbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasSgbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    // beta is primitive
    if (Y == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasSgbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasSgbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasSgbmv(order=%d, trans=%d, M=%ld, N=%ld, KL=%ld, KU=%ld, alpha=%f, A=%p, offa=%ld, lda=%ld, X=%p, offx=%ld, incx=%d, beta=%f, Y=%p, offy=%ld, incy=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, trans, M, N, KL, KU, alpha, A, offa, lda, X, offx, incx, beta, Y, offy, incy, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasTranspose trans_native;
    size_t M_native = 0;
    size_t N_native = 0;
    size_t KL_native = 0;
    size_t KU_native = 0;
    cl_float alpha_native;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_float beta_native;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    trans_native = (clblasTranspose)trans;
    M_native = (size_t)M;
    N_native = (size_t)N;
    KL_native = (size_t)KL;
    KU_native = (size_t)KU;
    alpha_native = (cl_float)alpha;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    beta_native = (cl_float)beta;
    if (!init_cl_mem(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasSgbmv(order_native, trans_native, M_native, N_native, KL_native, KU_native, alpha_native, A_native, offa_native, lda_native, X_native, offx_native, incx_native, beta_native, Y_native, offy_native, incy_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // trans is primitive
    // M is primitive
    // N is primitive
    // KL is primitive
    // KU is primitive
    // alpha is primitive
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // beta is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* @example example_sgbmv.c
* Example of how to use the @ref clblasSgbmv function.
* </pre>
*/
/**
* <pre>
* Matrix-vector product with a general rectangular banded matrix and
* double elements.
*
* Matrix-vector products:
*   - \f$ Y \leftarrow \alpha A X + \beta Y \f$
*   - \f$ Y \leftarrow \alpha A^T X + \beta Y \f$
*
* @param (in) order     Row/column order.
* @param (in) trans     How matrix \b A is to be transposed.
* @param (in) M         Number of rows in banded matrix \b A.
* @param (in) N         Number of columns in banded matrix \b A.
* @param (in) KL        Number of sub-diagonals in banded matrix \b A.
* @param (in) KU        Number of super-diagonals in banded matrix \b A.
* @param (in) alpha     The factor of banded matrix \b A.
* @param (in) A         Buffer object storing banded matrix \b A.
* @param (in) offa      Offset in number of elements for the first element in banded matrix \b A.
* @param (in) lda       Leading dimension of banded matrix \b A. It cannot be less
*                      than ( \b KL + \b KU + 1 )
* @param (in) X         Buffer object storing vector \b X.
* @param (in) offx      Offset of first element of vector \b X in buffer object.
*                      Counted in elements.
* @param (in) incx      Increment for the elements of \b X. Must not be zero.
* @param (in) beta      The factor of the vector \b Y.
* @param (out) Y        Buffer object storing the vector \b y.
* @param (in) offy      Offset of first element of vector \b Y in buffer object.
*                      Counted in elements.
* @param (in) incy      Increment for the elements of \b Y. Must not be zero.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasInvalidDevice if a target device does not support floating
*     point arithmetic with double precision;
*   - the same error codes as the clblasSgbmv() function otherwise.
*
* @ingroup GBMV
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasDgbmvNative(JNIEnv *env, jclass cls, jint order, jint trans, jlong M, jlong N, jlong KL, jlong KU, jdouble alpha, jobject A, jlong offa, jlong lda, jobject X, jlong offx, jint incx, jdouble beta, jobject Y, jlong offy, jint incy, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // trans is primitive
    // M is primitive
    // N is primitive
    // KL is primitive
    // KU is primitive
    // alpha is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasDgbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasDgbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    // beta is primitive
    if (Y == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasDgbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasDgbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasDgbmv(order=%d, trans=%d, M=%ld, N=%ld, KL=%ld, KU=%ld, alpha=%lf, A=%p, offa=%ld, lda=%ld, X=%p, offx=%ld, incx=%d, beta=%lf, Y=%p, offy=%ld, incy=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, trans, M, N, KL, KU, alpha, A, offa, lda, X, offx, incx, beta, Y, offy, incy, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasTranspose trans_native;
    size_t M_native = 0;
    size_t N_native = 0;
    size_t KL_native = 0;
    size_t KU_native = 0;
    cl_double alpha_native;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_double beta_native;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    trans_native = (clblasTranspose)trans;
    M_native = (size_t)M;
    N_native = (size_t)N;
    KL_native = (size_t)KL;
    KU_native = (size_t)KU;
    alpha_native = (cl_double)alpha;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    beta_native = (cl_double)beta;
    if (!init_cl_mem(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasDgbmv(order_native, trans_native, M_native, N_native, KL_native, KU_native, alpha_native, A_native, offa_native, lda_native, X_native, offx_native, incx_native, beta_native, Y_native, offy_native, incy_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // trans is primitive
    // M is primitive
    // N is primitive
    // KL is primitive
    // KU is primitive
    // alpha is primitive
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // beta is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* Matrix-vector product with a general rectangular banded matrix and
* float-complex elements.
*
* Matrix-vector products:
*   - \f$ Y \leftarrow \alpha A X + \beta Y \f$
*   - \f$ Y \leftarrow \alpha A^T X + \beta Y \f$
*
* @param (in) order     Row/column order.
* @param (in) trans     How matrix \b A is to be transposed.
* @param (in) M         Number of rows in banded matrix \b A.
* @param (in) N         Number of columns in banded matrix \b A.
* @param (in) KL        Number of sub-diagonals in banded matrix \b A.
* @param (in) KU        Number of super-diagonals in banded matrix \b A.
* @param (in) alpha     The factor of banded matrix \b A.
* @param (in) A         Buffer object storing banded matrix \b A.
* @param (in) offa      Offset in number of elements for the first element in banded matrix \b A.
* @param (in) lda       Leading dimension of banded matrix \b A. It cannot be less
*                      than ( \b KL + \b KU + 1 )
* @param (in) X         Buffer object storing vector \b X.
* @param (in) offx      Offset of first element of vector \b X in buffer object.
*                      Counted in elements.
* @param (in) incx      Increment for the elements of \b X. Must not be zero.
* @param (in) beta      The factor of the vector \b Y.
* @param (out) Y        Buffer object storing the vector \b y.
* @param (in) offy      Offset of first element of vector \b Y in buffer object.
*                      Counted in elements.
* @param (in) incy      Increment for the elements of \b Y. Must not be zero.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return The same result as the clblasSgbmv() function.
*
* @ingroup GBMV
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasCgbmvNative(JNIEnv *env, jclass cls, jint order, jint trans, jlong M, jlong N, jlong KL, jlong KU, jfloatArray alpha, jobject A, jlong offa, jlong lda, jobject X, jlong offx, jint incx, jfloatArray beta, jobject Y, jlong offy, jint incy, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // trans is primitive
    // M is primitive
    // N is primitive
    // KL is primitive
    // KU is primitive
    if (alpha == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'alpha' is null for clblasCgbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasCgbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasCgbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (beta == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'beta' is null for clblasCgbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (Y == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasCgbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasCgbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasCgbmv(order=%d, trans=%d, M=%ld, N=%ld, KL=%ld, KU=%ld, alpha=%p, A=%p, offa=%ld, lda=%ld, X=%p, offx=%ld, incx=%d, beta=%p, Y=%p, offy=%ld, incy=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, trans, M, N, KL, KU, alpha, A, offa, lda, X, offx, incx, beta, Y, offy, incy, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasTranspose trans_native;
    size_t M_native = 0;
    size_t N_native = 0;
    size_t KL_native = 0;
    size_t KU_native = 0;
    cl_float2 alpha_native;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_float2 beta_native;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    trans_native = (clblasTranspose)trans;
    M_native = (size_t)M;
    N_native = (size_t)N;
    KL_native = (size_t)KL;
    KU_native = (size_t)KU;
    if (!init_cl_float2(env, alpha, alpha_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_cl_float2(env, beta, beta_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_mem(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasCgbmv(order_native, trans_native, M_native, N_native, KL_native, KU_native, alpha_native, A_native, offa_native, lda_native, X_native, offx_native, incx_native, beta_native, Y_native, offy_native, incy_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // trans is primitive
    // M is primitive
    // N is primitive
    // KL is primitive
    // KU is primitive
    if (!release_cl_float2(env, alpha_native, alpha, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    if (!release_cl_float2(env, beta_native, beta, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* Matrix-vector product with a general rectangular banded matrix and
* double-complex elements.
*
* Matrix-vector products:
*   - \f$ Y \leftarrow \alpha A X + \beta Y \f$
*   - \f$ Y \leftarrow \alpha A^T X + \beta Y \f$
*
* @param (in) order     Row/column order.
* @param (in) trans     How matrix \b A is to be transposed.
* @param (in) M         Number of rows in banded matrix \b A.
* @param (in) N         Number of columns in banded matrix \b A.
* @param (in) KL        Number of sub-diagonals in banded matrix \b A.
* @param (in) KU        Number of super-diagonals in banded matrix \b A.
* @param (in) alpha     The factor of banded matrix \b A.
* @param (in) A         Buffer object storing banded matrix \b A.
* @param (in) offa      Offset in number of elements for the first element in banded matrix \b A.
* @param (in) lda       Leading dimension of banded matrix \b A. It cannot be less
*                      than ( \b KL + \b KU + 1 )
* @param (in) X         Buffer object storing vector \b X.
* @param (in) offx      Offset of first element of vector \b X in buffer object.
*                      Counted in elements.
* @param (in) incx      Increment for the elements of \b X. Must not be zero.
* @param (in) beta      The factor of the vector \b Y.
* @param (out) Y        Buffer object storing the vector \b y.
* @param (in) offy      Offset of first element of vector \b Y in buffer object.
*                      Counted in elements.
* @param (in) incy      Increment for the elements of \b Y. Must not be zero.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return The same result as the clblasDgbmv() function.
*
* @ingroup GBMV
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasZgbmvNative(JNIEnv *env, jclass cls, jint order, jint trans, jlong M, jlong N, jlong KL, jlong KU, jdoubleArray alpha, jobject A, jlong offa, jlong lda, jobject X, jlong offx, jint incx, jdoubleArray beta, jobject Y, jlong offy, jint incy, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // trans is primitive
    // M is primitive
    // N is primitive
    // KL is primitive
    // KU is primitive
    if (alpha == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'alpha' is null for clblasZgbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasZgbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasZgbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (beta == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'beta' is null for clblasZgbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (Y == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasZgbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasZgbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasZgbmv(order=%d, trans=%d, M=%ld, N=%ld, KL=%ld, KU=%ld, alpha=%p, A=%p, offa=%ld, lda=%ld, X=%p, offx=%ld, incx=%d, beta=%p, Y=%p, offy=%ld, incy=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, trans, M, N, KL, KU, alpha, A, offa, lda, X, offx, incx, beta, Y, offy, incy, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasTranspose trans_native;
    size_t M_native = 0;
    size_t N_native = 0;
    size_t KL_native = 0;
    size_t KU_native = 0;
    cl_double2 alpha_native;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_double2 beta_native;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    trans_native = (clblasTranspose)trans;
    M_native = (size_t)M;
    N_native = (size_t)N;
    KL_native = (size_t)KL;
    KU_native = (size_t)KU;
    if (!init_cl_double2(env, alpha, alpha_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_cl_double2(env, beta, beta_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_mem(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasZgbmv(order_native, trans_native, M_native, N_native, KL_native, KU_native, alpha_native, A_native, offa_native, lda_native, X_native, offx_native, incx_native, beta_native, Y_native, offy_native, incy_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // trans is primitive
    // M is primitive
    // N is primitive
    // KL is primitive
    // KU is primitive
    if (!release_cl_double2(env, alpha_native, alpha, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    if (!release_cl_double2(env, beta_native, beta, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**@}*/
/**
* <pre>
* @defgroup TBMV TBMV  - Triangular banded matrix vector multiply
* @ingroup BLAS2
* </pre>
*/
/**@{*/
/**
* <pre>
* Matrix-vector product with a triangular banded matrix and
* float elements.
*
* Matrix-vector products:
*   - \f$ X \leftarrow  A X \f$
*   - \f$ X \leftarrow  A^T X \f$
*
* @param (in) order				Row/column order.
* @param (in) uplo				The triangle in matrix being referenced.
* @param (in) trans				How matrix \b A is to be transposed.
* @param (in) diag				Specify whether matrix \b A is unit triangular.
* @param (in) N					Number of rows/columns in banded matrix \b A.
* @param (in) K					Number of sub-diagonals/super-diagonals in triangular banded matrix \b A.
* @param (in) A					Buffer object storing matrix \b A.
* @param (in) offa				Offset in number of elements for first element in matrix \b A.
* @param (in) lda				Leading dimension of matrix \b A. It cannot be less
*								than ( \b K + 1 )
* @param (out) X				Buffer object storing vector \b X.
* @param (in) offx				Offset in number of elements for first element in vector \b X.
* @param (in) incx				Increment for the elements of \b X. Must not be zero.
* @param (in) scratchBuff		Temporary cl_mem scratch buffer object which can hold a
*								minimum of (1 + (N-1)*abs(incx)) elements
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasNotInitialized if clblasSetup() was not called;
*   - \b clblasInvalidValue if invalid parameters are passed:
*     - either \b N or \b incx is zero, or
*     - K is greater than \b N - 1
*     - the leading dimension is invalid;
*   - \b clblasInvalidMemObject if either \b A or \b X object is
*     Invalid, or an image object rather than the buffer one;
*   - \b clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   - \b clblasInvalidCommandQueue if the passed command queue is invalid;
*   - \b clblasInvalidContext if a context a passed command queue belongs
*     to was released;
*   - \b clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   - \b clblasCompilerNotAvailable if a compiler is not available;
*   - \b clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
* @ingroup TBMV
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasStbmvNative(JNIEnv *env, jclass cls, jint order, jint uplo, jint trans, jint diag, jlong N, jlong K, jobject A, jlong offa, jlong lda, jobject X, jlong offx, jint incx, jobject scratchBuff, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    // K is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasStbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasStbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (scratchBuff == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'scratchBuff' is null for clblasStbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasStbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasStbmv(order=%d, uplo=%d, trans=%d, diag=%d, N=%ld, K=%ld, A=%p, offa=%ld, lda=%ld, X=%p, offx=%ld, incx=%d, scratchBuff=%p, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, trans, diag, N, K, A, offa, lda, X, offx, incx, scratchBuff, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    clblasTranspose trans_native;
    clblasDiag diag_native;
    size_t N_native = 0;
    size_t K_native = 0;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem scratchBuff_native = nullptr;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    trans_native = (clblasTranspose)trans;
    diag_native = (clblasDiag)diag;
    N_native = (size_t)N;
    K_native = (size_t)K;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_cl_mem(env, scratchBuff, scratchBuff_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasStbmv(order_native, uplo_native, trans_native, diag_native, N_native, K_native, A_native, offa_native, lda_native, X_native, offx_native, incx_native, scratchBuff_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    // K is primitive
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // scratchBuff is a read-only native pointer
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* @example example_stbmv.c
* Example of how to use the @ref clblasStbmv function.
* </pre>
*/
/**
* <pre>
* Matrix-vector product with a triangular banded matrix and
* double elements.
*
* Matrix-vector products:
*   - \f$ X \leftarrow  A X \f$
*   - \f$ X \leftarrow  A^T X \f$
*
* @param (in) order				Row/column order.
* @param (in) uplo				The triangle in matrix being referenced.
* @param (in) trans				How matrix \b A is to be transposed.
* @param (in) diag				Specify whether matrix \b A is unit triangular.
* @param (in) N					Number of rows/columns in banded matrix \b A.
* @param (in) K					Number of sub-diagonals/super-diagonals in triangular banded matrix \b A.
* @param (in) A					Buffer object storing matrix \b A.
* @param (in) offa				Offset in number of elements for first element in matrix \b A.
* @param (in) lda				Leading dimension of matrix \b A. It cannot be less
*								than ( \b K + 1 )
* @param (out) X				Buffer object storing vector \b X.
* @param (in) offx				Offset in number of elements for first element in vector \b X.
* @param (in) incx				Increment for the elements of \b X. Must not be zero.
* @param (in) scratchBuff		Temporary cl_mem scratch buffer object which can hold a
*								minimum of (1 + (N-1)*abs(incx)) elements
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasInvalidDevice if a target device does not support floating
*     point arithmetic with double precision;
*   - the same error codes as the clblasStbmv() function otherwise.
*
* @ingroup TBMV
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasDtbmvNative(JNIEnv *env, jclass cls, jint order, jint uplo, jint trans, jint diag, jlong N, jlong K, jobject A, jlong offa, jlong lda, jobject X, jlong offx, jint incx, jobject scratchBuff, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    // K is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasDtbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasDtbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (scratchBuff == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'scratchBuff' is null for clblasDtbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasDtbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasDtbmv(order=%d, uplo=%d, trans=%d, diag=%d, N=%ld, K=%ld, A=%p, offa=%ld, lda=%ld, X=%p, offx=%ld, incx=%d, scratchBuff=%p, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, trans, diag, N, K, A, offa, lda, X, offx, incx, scratchBuff, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    clblasTranspose trans_native;
    clblasDiag diag_native;
    size_t N_native = 0;
    size_t K_native = 0;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem scratchBuff_native = nullptr;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    trans_native = (clblasTranspose)trans;
    diag_native = (clblasDiag)diag;
    N_native = (size_t)N;
    K_native = (size_t)K;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_cl_mem(env, scratchBuff, scratchBuff_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasDtbmv(order_native, uplo_native, trans_native, diag_native, N_native, K_native, A_native, offa_native, lda_native, X_native, offx_native, incx_native, scratchBuff_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    // K is primitive
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // scratchBuff is a read-only native pointer
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* Matrix-vector product with a triangular banded matrix and
* float-complex elements.
*
* Matrix-vector products:
*   - \f$ X \leftarrow  A X \f$
*   - \f$ X \leftarrow  A^T X \f$
*
* @param (in) order				Row/column order.
* @param (in) uplo				The triangle in matrix being referenced.
* @param (in) trans				How matrix \b A is to be transposed.
* @param (in) diag				Specify whether matrix \b A is unit triangular.
* @param (in) N					Number of rows/columns in banded matrix \b A.
* @param (in) K					Number of sub-diagonals/super-diagonals in triangular banded matrix \b A.
* @param (in) A					Buffer object storing matrix \b A.
* @param (in) offa				Offset in number of elements for first element in matrix \b A.
* @param (in) lda				Leading dimension of matrix \b A. It cannot be less
*								than ( \b K + 1 )
* @param (out) X				Buffer object storing vector \b X.
* @param (in) offx				Offset in number of elements for first element in vector \b X.
* @param (in) incx				Increment for the elements of \b X. Must not be zero.
* @param (in) scratchBuff		Temporary cl_mem scratch buffer object which can hold a
*								minimum of (1 + (N-1)*abs(incx)) elements
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return The same result as the clblasStbmv() function.
*
* @ingroup TBMV
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasCtbmvNative(JNIEnv *env, jclass cls, jint order, jint uplo, jint trans, jint diag, jlong N, jlong K, jobject A, jlong offa, jlong lda, jobject X, jlong offx, jint incx, jobject scratchBuff, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    // K is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasCtbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasCtbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (scratchBuff == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'scratchBuff' is null for clblasCtbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasCtbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasCtbmv(order=%d, uplo=%d, trans=%d, diag=%d, N=%ld, K=%ld, A=%p, offa=%ld, lda=%ld, X=%p, offx=%ld, incx=%d, scratchBuff=%p, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, trans, diag, N, K, A, offa, lda, X, offx, incx, scratchBuff, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    clblasTranspose trans_native;
    clblasDiag diag_native;
    size_t N_native = 0;
    size_t K_native = 0;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem scratchBuff_native = nullptr;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    trans_native = (clblasTranspose)trans;
    diag_native = (clblasDiag)diag;
    N_native = (size_t)N;
    K_native = (size_t)K;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_cl_mem(env, scratchBuff, scratchBuff_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasCtbmv(order_native, uplo_native, trans_native, diag_native, N_native, K_native, A_native, offa_native, lda_native, X_native, offx_native, incx_native, scratchBuff_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    // K is primitive
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // scratchBuff is a read-only native pointer
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* Matrix-vector product with a triangular banded matrix and
* double-complex elements.
*
* Matrix-vector products:
*   - \f$ X \leftarrow  A X \f$
*   - \f$ X \leftarrow  A^T X \f$
*
* @param (in) order				Row/column order.
* @param (in) uplo				The triangle in matrix being referenced.
* @param (in) trans				How matrix \b A is to be transposed.
* @param (in) diag				Specify whether matrix \b A is unit triangular.
* @param (in) N					Number of rows/columns in banded matrix \b A.
* @param (in) K					Number of sub-diagonals/super-diagonals in triangular banded matrix \b A.
* @param (in) A					Buffer object storing matrix \b A.
* @param (in) offa				Offset in number of elements for first element in matrix \b A.
* @param (in) lda				Leading dimension of matrix \b A. It cannot be less
*								than ( \b K + 1 )
* @param (out) X				Buffer object storing vector \b X.
* @param (in) offx				Offset in number of elements for first element in vector \b X.
* @param (in) incx				Increment for the elements of \b X. Must not be zero.
* @param (in) scratchBuff		Temporary cl_mem scratch buffer object which can hold a
*								minimum of (1 + (N-1)*abs(incx)) elements
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return The same result as the clblasDtbmv() function.
*
* @ingroup TBMV
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasZtbmvNative(JNIEnv *env, jclass cls, jint order, jint uplo, jint trans, jint diag, jlong N, jlong K, jobject A, jlong offa, jlong lda, jobject X, jlong offx, jint incx, jobject scratchBuff, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    // K is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasZtbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasZtbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (scratchBuff == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'scratchBuff' is null for clblasZtbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasZtbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasZtbmv(order=%d, uplo=%d, trans=%d, diag=%d, N=%ld, K=%ld, A=%p, offa=%ld, lda=%ld, X=%p, offx=%ld, incx=%d, scratchBuff=%p, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, trans, diag, N, K, A, offa, lda, X, offx, incx, scratchBuff, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    clblasTranspose trans_native;
    clblasDiag diag_native;
    size_t N_native = 0;
    size_t K_native = 0;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_mem scratchBuff_native = nullptr;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    trans_native = (clblasTranspose)trans;
    diag_native = (clblasDiag)diag;
    N_native = (size_t)N;
    K_native = (size_t)K;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_cl_mem(env, scratchBuff, scratchBuff_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasZtbmv(order_native, uplo_native, trans_native, diag_native, N_native, K_native, A_native, offa_native, lda_native, X_native, offx_native, incx_native, scratchBuff_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    // K is primitive
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // scratchBuff is a read-only native pointer
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**@}*/
/**
* <pre>
* @defgroup SBMV SBMV  - Symmetric banded matrix-vector multiplication
* @ingroup BLAS2
* </pre>
*/
/**@{*/
/**
* <pre>
* Matrix-vector product with a symmetric banded matrix and float elements.
*
* Matrix-vector products:
* - \f$ Y \leftarrow \alpha A X + \beta Y \f$
*
* @param (in) order     Row/columns order.
* @param (in) uplo      The triangle in matrix being referenced.
* @param (in) N         Number of rows and columns in banded matrix \b A.
* @param (in) K			Number of sub-diagonals/super-diagonals in banded matrix \b A.
* @param (in) alpha     The factor of matrix \b A.
* @param (in) A			Buffer object storing matrix \b A.
* @param (in) offa		Offset in number of elements for first element in matrix \b A.
* @param (in) lda		Leading dimension of matrix \b A. It cannot be less
*						than ( \b K + 1 )
* @param (in) X         Buffer object storing vector \b X.
* @param (in) offx      Offset of first element of vector \b X in buffer object.
*                      Counted in elements.
* @param (in) incx      Increment for the elements of vector \b X. It cannot be zero.
* @param (in) beta      The factor of vector \b Y.
* @param (out) Y        Buffer object storing vector \b Y.
* @param (in) offy      Offset of first element of vector \b Y in buffer object.
*                      Counted in elements.
* @param (in) incy      Increment for the elements of vector \b Y. It cannot be zero.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasNotInitialized if clblasSetup() was not called;
*   - \b clblasInvalidValue if invalid parameters are passed:
*     - either \b N or \b incx is zero, or
*     - K is greater than \b N - 1
*     - the leading dimension is invalid;
*   - \b clblasInvalidMemObject if either \b A or \b X object is
*     Invalid, or an image object rather than the buffer one;
*   - \b clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   - \b clblasInvalidCommandQueue if the passed command queue is invalid;
*   - \b clblasInvalidContext if a context a passed command queue belongs
*     to was released;
*   - \b clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   - \b clblasCompilerNotAvailable if a compiler is not available;
*   - \b clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
* @ingroup SBMV
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasSsbmvNative(JNIEnv *env, jclass cls, jint order, jint uplo, jlong N, jlong K, jfloat alpha, jobject A, jlong offa, jlong lda, jobject X, jlong offx, jint incx, jfloat beta, jobject Y, jlong offy, jint incy, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // N is primitive
    // K is primitive
    // alpha is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasSsbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasSsbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    // beta is primitive
    if (Y == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasSsbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasSsbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasSsbmv(order=%d, uplo=%d, N=%ld, K=%ld, alpha=%f, A=%p, offa=%ld, lda=%ld, X=%p, offx=%ld, incx=%d, beta=%f, Y=%p, offy=%ld, incy=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, N, K, alpha, A, offa, lda, X, offx, incx, beta, Y, offy, incy, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    size_t N_native = 0;
    size_t K_native = 0;
    cl_float alpha_native;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_float beta_native;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    N_native = (size_t)N;
    K_native = (size_t)K;
    alpha_native = (cl_float)alpha;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    beta_native = (cl_float)beta;
    if (!init_cl_mem(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasSsbmv(order_native, uplo_native, N_native, K_native, alpha_native, A_native, offa_native, lda_native, X_native, offx_native, incx_native, beta_native, Y_native, offy_native, incy_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // N is primitive
    // K is primitive
    // alpha is primitive
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // beta is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* @example example_ssbmv.c
* This is an example of how to use the @ref clblasSsbmv function.
* </pre>
*/
/**
* <pre>
* Matrix-vector product with a symmetric banded matrix and double elements.
*
* Matrix-vector products:
* - \f$ Y \leftarrow \alpha A X + \beta Y \f$
*
* @param (in) order     Row/columns order.
* @param (in) uplo      The triangle in matrix being referenced.
* @param (in) N         Number of rows and columns in banded matrix \b A.
* @param (in) K			Number of sub-diagonals/super-diagonals in banded matrix \b A.
* @param (in) alpha     The factor of matrix \b A.
* @param (in) A			Buffer object storing matrix \b A.
* @param (in) offa		Offset in number of elements for first element in matrix \b A.
* @param (in) lda		Leading dimension of matrix \b A. It cannot be less
*						than ( \b K + 1 )
* @param (in) X         Buffer object storing vector \b X.
* @param (in) offx      Offset of first element of vector \b X in buffer object.
*                      Counted in elements.
* @param (in) incx      Increment for the elements of vector \b X. It cannot be zero.
* @param (in) beta      The factor of vector \b Y.
* @param (out) Y        Buffer object storing vector \b Y.
* @param (in) offy      Offset of first element of vector \b Y in buffer object.
*                      Counted in elements.
* @param (in) incy      Increment for the elements of vector \b Y. It cannot be zero.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasInvalidDevice if a target device does not support floating
*     point arithmetic with double precision;
*   - the same error codes as the clblasSsbmv() function otherwise.
*
* @ingroup SBMV
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasDsbmvNative(JNIEnv *env, jclass cls, jint order, jint uplo, jlong N, jlong K, jdouble alpha, jobject A, jlong offa, jlong lda, jobject X, jlong offx, jint incx, jdouble beta, jobject Y, jlong offy, jint incy, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // N is primitive
    // K is primitive
    // alpha is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasDsbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasDsbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    // beta is primitive
    if (Y == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasDsbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasDsbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasDsbmv(order=%d, uplo=%d, N=%ld, K=%ld, alpha=%lf, A=%p, offa=%ld, lda=%ld, X=%p, offx=%ld, incx=%d, beta=%lf, Y=%p, offy=%ld, incy=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, N, K, alpha, A, offa, lda, X, offx, incx, beta, Y, offy, incy, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    size_t N_native = 0;
    size_t K_native = 0;
    cl_double alpha_native;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_double beta_native;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    N_native = (size_t)N;
    K_native = (size_t)K;
    alpha_native = (cl_double)alpha;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    beta_native = (cl_double)beta;
    if (!init_cl_mem(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasDsbmv(order_native, uplo_native, N_native, K_native, alpha_native, A_native, offa_native, lda_native, X_native, offx_native, incx_native, beta_native, Y_native, offy_native, incy_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // N is primitive
    // K is primitive
    // alpha is primitive
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // beta is primitive
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**@}*/
/**
* <pre>
* @defgroup HBMV HBMV  - Hermitian banded matrix-vector multiplication
* @ingroup BLAS2
* </pre>
*/
/**@{*/
/**
* <pre>
* Matrix-vector product with a hermitian banded matrix and float elements.
*
* Matrix-vector products:
* - \f$ Y \leftarrow \alpha A X + \beta Y \f$
*
* @param (in) order     Row/columns order.
* @param (in) uplo      The triangle in matrix being referenced.
* @param (in) N         Number of rows and columns in banded matrix \b A.
* @param (in) K			Number of sub-diagonals/super-diagonals in banded matrix \b A.
* @param (in) alpha     The factor of matrix \b A.
* @param (in) A			Buffer object storing matrix \b A.
* @param (in) offa		Offset in number of elements for first element in matrix \b A.
* @param (in) lda		Leading dimension of matrix \b A. It cannot be less
*						than ( \b K + 1 )
* @param (in) X         Buffer object storing vector \b X.
* @param (in) offx      Offset of first element of vector \b X in buffer object.
*                      Counted in elements.
* @param (in) incx      Increment for the elements of vector \b X. It cannot be zero.
* @param (in) beta      The factor of vector \b Y.
* @param (out) Y        Buffer object storing vector \b Y.
* @param (in) offy      Offset of first element of vector \b Y in buffer object.
*                      Counted in elements.
* @param (in) incy      Increment for the elements of vector \b Y. It cannot be zero.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasNotInitialized if clblasSetup() was not called;
*   - \b clblasInvalidValue if invalid parameters are passed:
*     - either \b N or \b incx is zero, or
*     - K is greater than \b N - 1
*     - the leading dimension is invalid;
*   - \b clblasInvalidMemObject if either \b A or \b X object is
*     Invalid, or an image object rather than the buffer one;
*   - \b clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   - \b clblasInvalidCommandQueue if the passed command queue is invalid;
*   - \b clblasInvalidContext if a context a passed command queue belongs
*     to was released;
*   - \b clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   - \b clblasCompilerNotAvailable if a compiler is not available;
*   - \b clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
* @ingroup HBMV
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasChbmvNative(JNIEnv *env, jclass cls, jint order, jint uplo, jlong N, jlong K, jfloatArray alpha, jobject A, jlong offa, jlong lda, jobject X, jlong offx, jint incx, jfloatArray beta, jobject Y, jlong offy, jint incy, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // N is primitive
    // K is primitive
    if (alpha == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'alpha' is null for clblasChbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasChbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasChbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (beta == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'beta' is null for clblasChbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (Y == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasChbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasChbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasChbmv(order=%d, uplo=%d, N=%ld, K=%ld, alpha=%p, A=%p, offa=%ld, lda=%ld, X=%p, offx=%ld, incx=%d, beta=%p, Y=%p, offy=%ld, incy=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, N, K, alpha, A, offa, lda, X, offx, incx, beta, Y, offy, incy, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    size_t N_native = 0;
    size_t K_native = 0;
    cl_float2 alpha_native;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_float2 beta_native;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    N_native = (size_t)N;
    K_native = (size_t)K;
    if (!init_cl_float2(env, alpha, alpha_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_cl_float2(env, beta, beta_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_mem(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasChbmv(order_native, uplo_native, N_native, K_native, alpha_native, A_native, offa_native, lda_native, X_native, offx_native, incx_native, beta_native, Y_native, offy_native, incy_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // N is primitive
    // K is primitive
    if (!release_cl_float2(env, alpha_native, alpha, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    if (!release_cl_float2(env, beta_native, beta, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* @example example_chbmv.c
* This is an example of how to use the @ref clblasChbmv function.
* </pre>
*/
/**
* <pre>
* Matrix-vector product with a hermitian banded matrix and double elements.
*
* Matrix-vector products:
* - \f$ Y \leftarrow \alpha A X + \beta Y \f$
*
* @param (in) order     Row/columns order.
* @param (in) uplo      The triangle in matrix being referenced.
* @param (in) N         Number of rows and columns in banded matrix \b A.
* @param (in) K			Number of sub-diagonals/super-diagonals in banded matrix \b A.
* @param (in) alpha     The factor of matrix \b A.
* @param (in) A			Buffer object storing matrix \b A.
* @param (in) offa		Offset in number of elements for first element in matrix \b A.
* @param (in) lda		Leading dimension of matrix \b A. It cannot be less
*						than ( \b K + 1 )
* @param (in) X         Buffer object storing vector \b X.
* @param (in) offx      Offset of first element of vector \b X in buffer object.
*                      Counted in elements.
* @param (in) incx      Increment for the elements of vector \b X. It cannot be zero.
* @param (in) beta      The factor of vector \b Y.
* @param (out) Y        Buffer object storing vector \b Y.
* @param (in) offy      Offset of first element of vector \b Y in buffer object.
*                      Counted in elements.
* @param (in) incy      Increment for the elements of vector \b Y. It cannot be zero.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasInvalidDevice if a target device does not support floating
*     point arithmetic with double precision;
*   - the same error codes as the clblasChbmv() function otherwise.
*
* @ingroup HBMV
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasZhbmvNative(JNIEnv *env, jclass cls, jint order, jint uplo, jlong N, jlong K, jdoubleArray alpha, jobject A, jlong offa, jlong lda, jobject X, jlong offx, jint incx, jdoubleArray beta, jobject Y, jlong offy, jint incy, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // N is primitive
    // K is primitive
    if (alpha == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'alpha' is null for clblasZhbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasZhbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasZhbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    if (beta == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'beta' is null for clblasZhbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (Y == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'Y' is null for clblasZhbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasZhbmv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasZhbmv(order=%d, uplo=%d, N=%ld, K=%ld, alpha=%p, A=%p, offa=%ld, lda=%ld, X=%p, offx=%ld, incx=%d, beta=%p, Y=%p, offy=%ld, incy=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, N, K, alpha, A, offa, lda, X, offx, incx, beta, Y, offy, incy, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    size_t N_native = 0;
    size_t K_native = 0;
    cl_double2 alpha_native;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_double2 beta_native;
    cl_mem Y_native = nullptr;
    size_t offy_native = 0;
    int incy_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    N_native = (size_t)N;
    K_native = (size_t)K;
    if (!init_cl_double2(env, alpha, alpha_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    if (!init_cl_double2(env, beta, beta_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_mem(env, Y, Y_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offy_native = (size_t)offy;
    incy_native = (int)incy;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasZhbmv(order_native, uplo_native, N_native, K_native, alpha_native, A_native, offa_native, lda_native, X_native, offx_native, incx_native, beta_native, Y_native, offy_native, incy_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // N is primitive
    // K is primitive
    if (!release_cl_double2(env, alpha_native, alpha, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    if (!release_cl_double2(env, beta_native, beta, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // Y is a read-only native pointer
    // offy is primitive
    // incy is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**@}*/
/**
* <pre>
* @defgroup TBSV TBSV  - Solving triangular banded matrix
* @ingroup BLAS2
* </pre>
*/
/**@{*/
/**
* <pre>
* solving triangular banded matrix problems with float elements.
*
* Matrix-vector products:
*   - \f$ A X \leftarrow  X \f$
*   - \f$ A^T X \leftarrow  X \f$
*
* @param (in) order				Row/column order.
* @param (in) uplo				The triangle in matrix being referenced.
* @param (in) trans				How matrix \b A is to be transposed.
* @param (in) diag				Specify whether matrix \b A is unit triangular.
* @param (in) N					Number of rows/columns in banded matrix \b A.
* @param (in) K					Number of sub-diagonals/super-diagonals in triangular banded matrix \b A.
* @param (in) A					Buffer object storing matrix \b A.
* @param (in) offa				Offset in number of elements for first element in matrix \b A.
* @param (in) lda				Leading dimension of matrix \b A. It cannot be less
*								than ( \b K + 1 )
* @param (out) X				Buffer object storing vector \b X.
* @param (in) offx				Offset in number of elements for first element in vector \b X.
* @param (in) incx				Increment for the elements of \b X. Must not be zero.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasNotInitialized if clblasSetup() was not called;
*   - \b clblasInvalidValue if invalid parameters are passed:
*     - either \b N or \b incx is zero, or
*     - K is greater than \b N - 1
*     - the leading dimension is invalid;
*   - \b clblasInvalidMemObject if either \b A or \b X object is
*     Invalid, or an image object rather than the buffer one;
*   - \b clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   - \b clblasInvalidCommandQueue if the passed command queue is invalid;
*   - \b clblasInvalidContext if a context a passed command queue belongs
*     to was released;
*   - \b clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   - \b clblasCompilerNotAvailable if a compiler is not available;
*   - \b clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
* @ingroup TBSV
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasStbsvNative(JNIEnv *env, jclass cls, jint order, jint uplo, jint trans, jint diag, jlong N, jlong K, jobject A, jlong offa, jlong lda, jobject X, jlong offx, jint incx, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    // K is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasStbsv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasStbsv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasStbsv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasStbsv(order=%d, uplo=%d, trans=%d, diag=%d, N=%ld, K=%ld, A=%p, offa=%ld, lda=%ld, X=%p, offx=%ld, incx=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, trans, diag, N, K, A, offa, lda, X, offx, incx, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    clblasTranspose trans_native;
    clblasDiag diag_native;
    size_t N_native = 0;
    size_t K_native = 0;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    trans_native = (clblasTranspose)trans;
    diag_native = (clblasDiag)diag;
    N_native = (size_t)N;
    K_native = (size_t)K;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasStbsv(order_native, uplo_native, trans_native, diag_native, N_native, K_native, A_native, offa_native, lda_native, X_native, offx_native, incx_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    // K is primitive
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* @example example_stbsv.c
* This is an example of how to use the @ref clblasStbsv function.
* </pre>
*/
/**
* <pre>
* solving triangular banded matrix problems with double elements.
*
* Matrix-vector products:
*   - \f$ A X \leftarrow  X \f$
*   - \f$ A^T X \leftarrow  X \f$
*
* @param (in) order				Row/column order.
* @param (in) uplo				The triangle in matrix being referenced.
* @param (in) trans				How matrix \b A is to be transposed.
* @param (in) diag				Specify whether matrix \b A is unit triangular.
* @param (in) N					Number of rows/columns in banded matrix \b A.
* @param (in) K					Number of sub-diagonals/super-diagonals in triangular banded matrix \b A.
* @param (in) A					Buffer object storing matrix \b A.
* @param (in) offa				Offset in number of elements for first element in matrix \b A.
* @param (in) lda				Leading dimension of matrix \b A. It cannot be less
*								than ( \b K + 1 )
* @param (out) X				Buffer object storing vector \b X.
* @param (in) offx				Offset in number of elements for first element in vector \b X.
* @param (in) incx				Increment for the elements of \b X. Must not be zero.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasInvalidDevice if a target device does not support floating
*     point arithmetic with double precision;
*   - the same error codes as the clblasStbsv() function otherwise.
*
* @ingroup TBSV
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasDtbsvNative(JNIEnv *env, jclass cls, jint order, jint uplo, jint trans, jint diag, jlong N, jlong K, jobject A, jlong offa, jlong lda, jobject X, jlong offx, jint incx, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    // K is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasDtbsv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasDtbsv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasDtbsv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasDtbsv(order=%d, uplo=%d, trans=%d, diag=%d, N=%ld, K=%ld, A=%p, offa=%ld, lda=%ld, X=%p, offx=%ld, incx=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, trans, diag, N, K, A, offa, lda, X, offx, incx, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    clblasTranspose trans_native;
    clblasDiag diag_native;
    size_t N_native = 0;
    size_t K_native = 0;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    trans_native = (clblasTranspose)trans;
    diag_native = (clblasDiag)diag;
    N_native = (size_t)N;
    K_native = (size_t)K;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasDtbsv(order_native, uplo_native, trans_native, diag_native, N_native, K_native, A_native, offa_native, lda_native, X_native, offx_native, incx_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    // K is primitive
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* solving triangular banded matrix problems with float-complex elements.
*
* Matrix-vector products:
*   - \f$ A X \leftarrow  X \f$
*   - \f$ A^T X \leftarrow  X \f$
*
* @param (in) order				Row/column order.
* @param (in) uplo				The triangle in matrix being referenced.
* @param (in) trans				How matrix \b A is to be transposed.
* @param (in) diag				Specify whether matrix \b A is unit triangular.
* @param (in) N					Number of rows/columns in banded matrix \b A.
* @param (in) K					Number of sub-diagonals/super-diagonals in triangular banded matrix \b A.
* @param (in) A					Buffer object storing matrix \b A.
* @param (in) offa				Offset in number of elements for first element in matrix \b A.
* @param (in) lda				Leading dimension of matrix \b A. It cannot be less
*								than ( \b K + 1 )
* @param (out) X				Buffer object storing vector \b X.
* @param (in) offx				Offset in number of elements for first element in vector \b X.
* @param (in) incx				Increment for the elements of \b X. Must not be zero.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return The same result as the clblasStbsv() function.
*
* @ingroup TBSV
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasCtbsvNative(JNIEnv *env, jclass cls, jint order, jint uplo, jint trans, jint diag, jlong N, jlong K, jobject A, jlong offa, jlong lda, jobject X, jlong offx, jint incx, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    // K is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasCtbsv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasCtbsv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasCtbsv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasCtbsv(order=%d, uplo=%d, trans=%d, diag=%d, N=%ld, K=%ld, A=%p, offa=%ld, lda=%ld, X=%p, offx=%ld, incx=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, trans, diag, N, K, A, offa, lda, X, offx, incx, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    clblasTranspose trans_native;
    clblasDiag diag_native;
    size_t N_native = 0;
    size_t K_native = 0;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    trans_native = (clblasTranspose)trans;
    diag_native = (clblasDiag)diag;
    N_native = (size_t)N;
    K_native = (size_t)K;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasCtbsv(order_native, uplo_native, trans_native, diag_native, N_native, K_native, A_native, offa_native, lda_native, X_native, offx_native, incx_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    // K is primitive
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* solving triangular banded matrix problems with double-complex elements.
*
* Matrix-vector products:
*   - \f$ A X \leftarrow  X \f$
*   - \f$ A^T X \leftarrow  X \f$
*
* @param (in) order				Row/column order.
* @param (in) uplo				The triangle in matrix being referenced.
* @param (in) trans				How matrix \b A is to be transposed.
* @param (in) diag				Specify whether matrix \b A is unit triangular.
* @param (in) N					Number of rows/columns in banded matrix \b A.
* @param (in) K					Number of sub-diagonals/super-diagonals in triangular banded matrix \b A.
* @param (in) A					Buffer object storing matrix \b A.
* @param (in) offa				Offset in number of elements for first element in matrix \b A.
* @param (in) lda				Leading dimension of matrix \b A. It cannot be less
*								than ( \b K + 1 )
* @param (out) X				Buffer object storing vector \b X.
* @param (in) offx				Offset in number of elements for first element in vector \b X.
* @param (in) incx				Increment for the elements of \b X. Must not be zero.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return The same result as the clblasDtbsv() function.
*
* @ingroup TBSV
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasZtbsvNative(JNIEnv *env, jclass cls, jint order, jint uplo, jint trans, jint diag, jlong N, jlong K, jobject A, jlong offa, jlong lda, jobject X, jlong offx, jint incx, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    // K is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasZtbsv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    if (X == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'X' is null for clblasZtbsv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offx is primitive
    // incx is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasZtbsv");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasZtbsv(order=%d, uplo=%d, trans=%d, diag=%d, N=%ld, K=%ld, A=%p, offa=%ld, lda=%ld, X=%p, offx=%ld, incx=%d, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, trans, diag, N, K, A, offa, lda, X, offx, incx, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    clblasTranspose trans_native;
    clblasDiag diag_native;
    size_t N_native = 0;
    size_t K_native = 0;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_mem X_native = nullptr;
    size_t offx_native = 0;
    int incx_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    trans_native = (clblasTranspose)trans;
    diag_native = (clblasDiag)diag;
    N_native = (size_t)N;
    K_native = (size_t)K;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    if (!init_cl_mem(env, X, X_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offx_native = (size_t)offx;
    incx_native = (int)incx;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasZtbsv(order_native, uplo_native, trans_native, diag_native, N_native, K_native, A_native, offa_native, lda_native, X_native, offx_native, incx_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // diag is primitive
    // N is primitive
    // K is primitive
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // X is a read-only native pointer
    // offx is primitive
    // incx is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**@}*/
/**
* <pre>
* @defgroup BLAS3 BLAS-3 functions
*
* The Level 3 Basic Linear Algebra Subprograms are funcions that perform
* matrix-matrix operations.
* </pre>
*/
/**@{*/
/**@}*/
/**
* <pre>
* @defgroup GEMM GEMM - General matrix-matrix multiplication
* @ingroup BLAS3
* </pre>
*/
/**@{*/
/**
* <pre>
* Matrix-matrix product of general rectangular matrices with float
*        elements. Extended version.
*
* Matrix-matrix products:
*   - \f$ C \leftarrow \alpha A B + \beta C \f$
*   - \f$ C \leftarrow \alpha A^T B + \beta C \f$
*   - \f$ C \leftarrow \alpha A B^T + \beta C \f$
*   - \f$ C \leftarrow \alpha A^T B^T + \beta C \f$
*
* @param (in) order     Row/column order.
* @param (in) transA    How matrix \b A is to be transposed.
* @param (in) transB    How matrix \b B is to be transposed.
* @param (in) M         Number of rows in matrix \b A.
* @param (in) N         Number of columns in matrix \b B.
* @param (in) K         Number of columns in matrix \b A and rows in matrix \b B.
* @param (in) alpha     The factor of matrix \b A.
* @param (in) A         Buffer object storing matrix \b A.
* @param (in) offA      Offset of the first element of the matrix \b A in the
*                      buffer object. Counted in elements.
* @param (in) lda       Leading dimension of matrix \b A. It cannot be less
*                      than \b K when the \b order parameter is set to
*                      \b clblasRowMajor,\n or less than \b M when the
*                      parameter is set to \b clblasColumnMajor.
* @param (in) B         Buffer object storing matrix \b B.
* @param (in) offB      Offset of the first element of the matrix \b B in the
*                      buffer object. Counted in elements.
* @param (in) ldb       Leading dimension of matrix \b B. It cannot be less
*                      than \b N when the \b order parameter is set to
*                      \b clblasRowMajor,\n or less than \b K
*                      when it is set to \b clblasColumnMajor.
* @param (in) beta      The factor of matrix \b C.
* @param (out) C        Buffer object storing matrix \b C.
* @param (in)  offC     Offset of the first element of the matrix \b C in the
*                      buffer object. Counted in elements.
* @param (in) ldc       Leading dimension of matrix \b C. It cannot be less
*                      than \b N when the \b order parameter is set to
*                      \b clblasRowMajor,\n or less than \b M when
*                      it is set to \b clblasColumnMajorOrder.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasInvalidValue if either \b offA, \b offB or \b offC exceeds
*        the size of the respective buffer object;
*   - the same error codes as clblasSgemm() otherwise.
*
* @ingroup GEMM
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasSgemmNative(JNIEnv *env, jclass cls, jint order, jint transA, jint transB, jlong M, jlong N, jlong K, jfloat alpha, jobject A, jlong offA, jlong lda, jobject B, jlong offB, jlong ldb, jfloat beta, jobject C, jlong offC, jlong ldc, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // transA is primitive
    // transB is primitive
    // M is primitive
    // N is primitive
    // K is primitive
    // alpha is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasSgemm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // lda is primitive
    if (B == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasSgemm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offB is primitive
    // ldb is primitive
    // beta is primitive
    if (C == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'C' is null for clblasSgemm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offC is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasSgemm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasSgemm(order=%d, transA=%d, transB=%d, M=%ld, N=%ld, K=%ld, alpha=%f, A=%p, offA=%ld, lda=%ld, B=%p, offB=%ld, ldb=%ld, beta=%f, C=%p, offC=%ld, ldc=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, transA, transB, M, N, K, alpha, A, offA, lda, B, offB, ldb, beta, C, offC, ldc, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasTranspose transA_native;
    clblasTranspose transB_native;
    size_t M_native = 0;
    size_t N_native = 0;
    size_t K_native = 0;
    cl_float alpha_native;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    size_t lda_native = 0;
    cl_mem B_native = nullptr;
    size_t offB_native = 0;
    size_t ldb_native = 0;
    cl_float beta_native;
    cl_mem C_native = nullptr;
    size_t offC_native = 0;
    size_t ldc_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    transA_native = (clblasTranspose)transA;
    transB_native = (clblasTranspose)transB;
    M_native = (size_t)M;
    N_native = (size_t)N;
    K_native = (size_t)K;
    alpha_native = (cl_float)alpha;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    lda_native = (size_t)lda;
    if (!init_cl_mem(env, B, B_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offB_native = (size_t)offB;
    ldb_native = (size_t)ldb;
    beta_native = (cl_float)beta;
    if (!init_cl_mem(env, C, C_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offC_native = (size_t)offC;
    ldc_native = (size_t)ldc;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasSgemm(order_native, transA_native, transB_native, M_native, N_native, K_native, alpha_native, A_native, offA_native, lda_native, B_native, offB_native, ldb_native, beta_native, C_native, offC_native, ldc_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // transA is primitive
    // transB is primitive
    // M is primitive
    // N is primitive
    // K is primitive
    // alpha is primitive
    // A is a read-only native pointer
    // offA is primitive
    // lda is primitive
    // B is a read-only native pointer
    // offB is primitive
    // ldb is primitive
    // beta is primitive
    // C is a read-only native pointer
    // offC is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* @example example_sgemm.c
* This is an example of how to use the @ref clblasSgemmEx function.
* </pre>
*/
/**
* <pre>
* Matrix-matrix product of general rectangular matrices with double
*        elements. Extended version.
*
* Matrix-matrix products:
*   - \f$ C \leftarrow \alpha A B + \beta C \f$
*   - \f$ C \leftarrow \alpha A^T B + \beta C \f$
*   - \f$ C \leftarrow \alpha A B^T + \beta C \f$
*   - \f$ C \leftarrow \alpha A^T B^T + \beta C \f$
*
* @param (in) order     Row/column order.
* @param (in) transA    How matrix \b A is to be transposed.
* @param (in) transB    How matrix \b B is to be transposed.
* @param (in) M         Number of rows in matrix \b A.
* @param (in) N         Number of columns in matrix \b B.
* @param (in) K         Number of columns in matrix \b A and rows in matrix \b B.
* @param (in) alpha     The factor of matrix \b A.
* @param (in) A         Buffer object storing matrix \b A.
* @param (in) offA      Offset of the first element of the matrix \b A in the
*                      buffer object. Counted in elements.
* @param (in) lda       Leading dimension of matrix \b A. For detailed description,
*                      see clblasSgemm().
* @param (in) B         Buffer object storing matrix \b B.
* @param (in) offB      Offset of the first element of the matrix \b B in the
*                      buffer object. Counted in elements.
* @param (in) ldb       Leading dimension of matrix \b B. For detailed description,
*                      see clblasSgemm().
* @param (in) beta      The factor of matrix \b C.
* @param (out) C        Buffer object storing matrix \b C.
* @param (in) offC      Offset of the first element of the matrix \b C in the
*                      buffer object. Counted in elements.
* @param (in) ldc       Leading dimension of matrix \b C. For detailed description,
*                      see clblasSgemm().
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasInvalidDevice if a target device does not support floating
*        point arithmetic with double precision;
*   - \b clblasInvalidValue if either \b offA, \b offB or offC exceeds
*        the size of the respective buffer object;
*   - the same error codes as the clblasSgemm() function otherwise.
*
* @ingroup GEMM
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasDgemmNative(JNIEnv *env, jclass cls, jint order, jint transA, jint transB, jlong M, jlong N, jlong K, jdouble alpha, jobject A, jlong offA, jlong lda, jobject B, jlong offB, jlong ldb, jdouble beta, jobject C, jlong offC, jlong ldc, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // transA is primitive
    // transB is primitive
    // M is primitive
    // N is primitive
    // K is primitive
    // alpha is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasDgemm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // lda is primitive
    if (B == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasDgemm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offB is primitive
    // ldb is primitive
    // beta is primitive
    if (C == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'C' is null for clblasDgemm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offC is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasDgemm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasDgemm(order=%d, transA=%d, transB=%d, M=%ld, N=%ld, K=%ld, alpha=%lf, A=%p, offA=%ld, lda=%ld, B=%p, offB=%ld, ldb=%ld, beta=%lf, C=%p, offC=%ld, ldc=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, transA, transB, M, N, K, alpha, A, offA, lda, B, offB, ldb, beta, C, offC, ldc, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasTranspose transA_native;
    clblasTranspose transB_native;
    size_t M_native = 0;
    size_t N_native = 0;
    size_t K_native = 0;
    cl_double alpha_native;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    size_t lda_native = 0;
    cl_mem B_native = nullptr;
    size_t offB_native = 0;
    size_t ldb_native = 0;
    cl_double beta_native;
    cl_mem C_native = nullptr;
    size_t offC_native = 0;
    size_t ldc_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    transA_native = (clblasTranspose)transA;
    transB_native = (clblasTranspose)transB;
    M_native = (size_t)M;
    N_native = (size_t)N;
    K_native = (size_t)K;
    alpha_native = (cl_double)alpha;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    lda_native = (size_t)lda;
    if (!init_cl_mem(env, B, B_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offB_native = (size_t)offB;
    ldb_native = (size_t)ldb;
    beta_native = (cl_double)beta;
    if (!init_cl_mem(env, C, C_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offC_native = (size_t)offC;
    ldc_native = (size_t)ldc;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasDgemm(order_native, transA_native, transB_native, M_native, N_native, K_native, alpha_native, A_native, offA_native, lda_native, B_native, offB_native, ldb_native, beta_native, C_native, offC_native, ldc_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // transA is primitive
    // transB is primitive
    // M is primitive
    // N is primitive
    // K is primitive
    // alpha is primitive
    // A is a read-only native pointer
    // offA is primitive
    // lda is primitive
    // B is a read-only native pointer
    // offB is primitive
    // ldb is primitive
    // beta is primitive
    // C is a read-only native pointer
    // offC is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* Matrix-matrix product of general rectangular matrices with float
*        complex elements. Extended version.
*
* Matrix-matrix products:
*   - \f$ C \leftarrow \alpha A B + \beta C \f$
*   - \f$ C \leftarrow \alpha A^T B + \beta C \f$
*   - \f$ C \leftarrow \alpha A B^T + \beta C \f$
*   - \f$ C \leftarrow \alpha A^T B^T + \beta C \f$
*
* @param (in) order     Row/column order.
* @param (in) transA    How matrix \b A is to be transposed.
* @param (in) transB    How matrix \b B is to be transposed.
* @param (in) M         Number of rows in matrix \b A.
* @param (in) N         Number of columns in matrix \b B.
* @param (in) K         Number of columns in matrix \b A and rows in matrix \b B.
* @param (in) alpha     The factor of matrix \b A.
* @param (in) A         Buffer object storing matrix \b A.
* @param (in) offA      Offset of the first element of the matrix \b A in the
*                      buffer object. Counted in elements.
* @param (in) lda       Leading dimension of matrix \b A. For detailed description,
*                      see clblasSgemm().
* @param (in) B         Buffer object storing matrix \b B.
* @param (in) offB      Offset of the first element of the matrix \b B in the
*                      buffer object. Counted in elements.
* @param (in) ldb       Leading dimension of matrix \b B. For detailed description,
*                      see clblasSgemm().
* @param (in) beta      The factor of matrix \b C.
* @param (out) C        Buffer object storing matrix \b C.
* @param (in) offC      Offset of the first element of the matrix \b C in the
*                      buffer object. Counted in elements.
* @param (in) ldc       Leading dimension of matrix \b C. For detailed description,
*                      see clblasSgemm().
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasInvalidValue if either \b offA, \b offB or offC exceeds
*        the size of the respective buffer object;
*   - the same error codes as the clblasSgemm() function otherwise.
*
* @ingroup GEMM
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasCgemmNative(JNIEnv *env, jclass cls, jint order, jint transA, jint transB, jlong M, jlong N, jlong K, jfloatArray alpha, jobject A, jlong offA, jlong lda, jobject B, jlong offB, jlong ldb, jfloatArray beta, jobject C, jlong offC, jlong ldc, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // transA is primitive
    // transB is primitive
    // M is primitive
    // N is primitive
    // K is primitive
    if (alpha == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'alpha' is null for clblasCgemm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasCgemm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // lda is primitive
    if (B == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasCgemm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offB is primitive
    // ldb is primitive
    if (beta == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'beta' is null for clblasCgemm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (C == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'C' is null for clblasCgemm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offC is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasCgemm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasCgemm(order=%d, transA=%d, transB=%d, M=%ld, N=%ld, K=%ld, alpha=%p, A=%p, offA=%ld, lda=%ld, B=%p, offB=%ld, ldb=%ld, beta=%p, C=%p, offC=%ld, ldc=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, transA, transB, M, N, K, alpha, A, offA, lda, B, offB, ldb, beta, C, offC, ldc, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasTranspose transA_native;
    clblasTranspose transB_native;
    size_t M_native = 0;
    size_t N_native = 0;
    size_t K_native = 0;
    FloatComplex alpha_native;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    size_t lda_native = 0;
    cl_mem B_native = nullptr;
    size_t offB_native = 0;
    size_t ldb_native = 0;
    FloatComplex beta_native;
    cl_mem C_native = nullptr;
    size_t offC_native = 0;
    size_t ldc_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    transA_native = (clblasTranspose)transA;
    transB_native = (clblasTranspose)transB;
    M_native = (size_t)M;
    N_native = (size_t)N;
    K_native = (size_t)K;
    if (!init_FloatComplex(env, alpha, alpha_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    lda_native = (size_t)lda;
    if (!init_cl_mem(env, B, B_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offB_native = (size_t)offB;
    ldb_native = (size_t)ldb;
    if (!init_FloatComplex(env, beta, beta_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_mem(env, C, C_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offC_native = (size_t)offC;
    ldc_native = (size_t)ldc;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasCgemm(order_native, transA_native, transB_native, M_native, N_native, K_native, alpha_native, A_native, offA_native, lda_native, B_native, offB_native, ldb_native, beta_native, C_native, offC_native, ldc_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // transA is primitive
    // transB is primitive
    // M is primitive
    // N is primitive
    // K is primitive
    if (!release_FloatComplex(env, alpha_native, alpha, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // A is a read-only native pointer
    // offA is primitive
    // lda is primitive
    // B is a read-only native pointer
    // offB is primitive
    // ldb is primitive
    if (!release_FloatComplex(env, beta_native, beta, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // C is a read-only native pointer
    // offC is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* Matrix-matrix product of general rectangular matrices with double
*        complex elements. Exteneded version.
*
* Matrix-matrix products:
*   - \f$ C \leftarrow \alpha A B + \beta C \f$
*   - \f$ C \leftarrow \alpha A^T B + \beta C \f$
*   - \f$ C \leftarrow \alpha A B^T + \beta C \f$
*   - \f$ C \leftarrow \alpha A^T B^T + \beta C \f$
*
* @param (in) order     Row/column order.
* @param (in) transA    How matrix \b A is to be transposed.
* @param (in) transB    How matrix \b B is to be transposed.
* @param (in) M         Number of rows in matrix \b A.
* @param (in) N         Number of columns in matrix \b B.
* @param (in) K         Number of columns in matrix \b A and rows in matrix \b B.
* @param (in) alpha     The factor of matrix \b A.
* @param (in) A         Buffer object storing matrix \b A.
* @param (in) offA      Offset of the first element of the matrix \b A in the
*                      buffer object. Counted in elements.
* @param (in) lda       Leading dimension of matrix \b A. For detailed description,
*                      see clblasSgemm().
* @param (in) B         Buffer object storing matrix \b B.
* @param (in) offB      Offset of the first element of the matrix \b B in the
*                      buffer object. Counted in elements.
* @param (in) ldb       Leading dimension of matrix \b B. For detailed description,
*                      see clblasSgemm().
* @param (in) beta      The factor of matrix \b C.
* @param (out) C        Buffer object storing matrix \b C.
* @param (in) offC      Offset of the first element of the matrix \b C in the
*                      buffer object. Counted in elements.
* @param (in) ldc       Leading dimension of matrix \b C. For detailed description,
*                      see clblasSgemm().
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasInvalidDevice if a target device does not support floating
*        point arithmetic with double precision;
*   - \b clblasInvalidValue if either \b offA, \b offB or offC exceeds
*        the size of the respective buffer object;
*   - the same error codes as the clblasSgemm() function otherwise.
*
* @ingroup GEMM
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasZgemmNative(JNIEnv *env, jclass cls, jint order, jint transA, jint transB, jlong M, jlong N, jlong K, jdoubleArray alpha, jobject A, jlong offA, jlong lda, jobject B, jlong offB, jlong ldb, jdoubleArray beta, jobject C, jlong offC, jlong ldc, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // transA is primitive
    // transB is primitive
    // M is primitive
    // N is primitive
    // K is primitive
    if (alpha == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'alpha' is null for clblasZgemm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasZgemm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // lda is primitive
    if (B == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasZgemm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offB is primitive
    // ldb is primitive
    if (beta == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'beta' is null for clblasZgemm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (C == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'C' is null for clblasZgemm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offC is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasZgemm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasZgemm(order=%d, transA=%d, transB=%d, M=%ld, N=%ld, K=%ld, alpha=%p, A=%p, offA=%ld, lda=%ld, B=%p, offB=%ld, ldb=%ld, beta=%p, C=%p, offC=%ld, ldc=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, transA, transB, M, N, K, alpha, A, offA, lda, B, offB, ldb, beta, C, offC, ldc, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasTranspose transA_native;
    clblasTranspose transB_native;
    size_t M_native = 0;
    size_t N_native = 0;
    size_t K_native = 0;
    DoubleComplex alpha_native;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    size_t lda_native = 0;
    cl_mem B_native = nullptr;
    size_t offB_native = 0;
    size_t ldb_native = 0;
    DoubleComplex beta_native;
    cl_mem C_native = nullptr;
    size_t offC_native = 0;
    size_t ldc_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    transA_native = (clblasTranspose)transA;
    transB_native = (clblasTranspose)transB;
    M_native = (size_t)M;
    N_native = (size_t)N;
    K_native = (size_t)K;
    if (!init_DoubleComplex(env, alpha, alpha_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    lda_native = (size_t)lda;
    if (!init_cl_mem(env, B, B_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offB_native = (size_t)offB;
    ldb_native = (size_t)ldb;
    if (!init_DoubleComplex(env, beta, beta_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_mem(env, C, C_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offC_native = (size_t)offC;
    ldc_native = (size_t)ldc;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasZgemm(order_native, transA_native, transB_native, M_native, N_native, K_native, alpha_native, A_native, offA_native, lda_native, B_native, offB_native, ldb_native, beta_native, C_native, offC_native, ldc_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // transA is primitive
    // transB is primitive
    // M is primitive
    // N is primitive
    // K is primitive
    if (!release_DoubleComplex(env, alpha_native, alpha, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // A is a read-only native pointer
    // offA is primitive
    // lda is primitive
    // B is a read-only native pointer
    // offB is primitive
    // ldb is primitive
    if (!release_DoubleComplex(env, beta_native, beta, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // C is a read-only native pointer
    // offC is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**@}*/
/**
* <pre>
* @defgroup TRMM TRMM - Triangular matrix-matrix multiplication
* @ingroup BLAS3
* </pre>
*/
/**@{*/
/**
* <pre>
* Multiplying a matrix by a triangular matrix with float elements.
*        Extended version.
*
* Matrix-triangular matrix products:
*   - \f$ B \leftarrow \alpha A B \f$
*   - \f$ B \leftarrow \alpha A^T B \f$
*   - \f$ B \leftarrow \alpha B A \f$
*   - \f$ B \leftarrow \alpha B A^T \f$
*
* where \b T is an upper or lower triangular matrix.
*
* @param (in) order     Row/column order.
* @param (in) side      The side of triangular matrix.
* @param (in) uplo      The triangle in matrix being referenced.
* @param (in) transA    How matrix \b A is to be transposed.
* @param (in) diag      Specify whether matrix is unit triangular.
* @param (in) M         Number of rows in matrix \b B.
* @param (in) N         Number of columns in matrix \b B.
* @param (in) alpha     The factor of matrix \b A.
* @param (in) A         Buffer object storing matrix \b A.
* @param (in) offA      Offset of the first element of the matrix \b A in the
*                      buffer object. Counted in elements.
* @param (in) lda       Leading dimension of matrix \b A. It cannot be less
*                      than \b M when the \b side parameter is set to
*                      \b clblasLeft,\n or less than \b N when it is set
*                      to \b clblasRight.
* @param (out) B        Buffer object storing matrix \b B.
* @param (in) offB      Offset of the first element of the matrix \b B in the
*                      buffer object. Counted in elements.
* @param (in) ldb       Leading dimension of matrix \b B. It cannot be less
*                      than \b N when the \b order parameter is set to
*                      \b clblasRowMajor,\n or not less than \b M
*                      when it is set to \b clblasColumnMajor.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasInvalidValue if either \b offA or \b offB exceeds the size
*        of the respective buffer object;
*   - the same error codes as clblasStrmm() otherwise.
*
* @ingroup TRMM
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasStrmmNative(JNIEnv *env, jclass cls, jint order, jint side, jint uplo, jint transA, jint diag, jlong M, jlong N, jfloat alpha, jobject A, jlong offA, jlong lda, jobject B, jlong offB, jlong ldb, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // side is primitive
    // uplo is primitive
    // transA is primitive
    // diag is primitive
    // M is primitive
    // N is primitive
    // alpha is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasStrmm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // lda is primitive
    if (B == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasStrmm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offB is primitive
    // ldb is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasStrmm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasStrmm(order=%d, side=%d, uplo=%d, transA=%d, diag=%d, M=%ld, N=%ld, alpha=%f, A=%p, offA=%ld, lda=%ld, B=%p, offB=%ld, ldb=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, side, uplo, transA, diag, M, N, alpha, A, offA, lda, B, offB, ldb, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasSide side_native;
    clblasUplo uplo_native;
    clblasTranspose transA_native;
    clblasDiag diag_native;
    size_t M_native = 0;
    size_t N_native = 0;
    cl_float alpha_native;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    size_t lda_native = 0;
    cl_mem B_native = nullptr;
    size_t offB_native = 0;
    size_t ldb_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    side_native = (clblasSide)side;
    uplo_native = (clblasUplo)uplo;
    transA_native = (clblasTranspose)transA;
    diag_native = (clblasDiag)diag;
    M_native = (size_t)M;
    N_native = (size_t)N;
    alpha_native = (cl_float)alpha;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    lda_native = (size_t)lda;
    if (!init_cl_mem(env, B, B_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offB_native = (size_t)offB;
    ldb_native = (size_t)ldb;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasStrmm(order_native, side_native, uplo_native, transA_native, diag_native, M_native, N_native, alpha_native, A_native, offA_native, lda_native, B_native, offB_native, ldb_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // side is primitive
    // uplo is primitive
    // transA is primitive
    // diag is primitive
    // M is primitive
    // N is primitive
    // alpha is primitive
    // A is a read-only native pointer
    // offA is primitive
    // lda is primitive
    // B is a read-only native pointer
    // offB is primitive
    // ldb is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* @example example_strmm.c
* This is an example of how to use the @ref clblasStrmmEx function.
* </pre>
*/
/**
* <pre>
* Multiplying a matrix by a triangular matrix with double elements.
*        Extended version.
*
* Matrix-triangular matrix products:
*   - \f$ B \leftarrow \alpha A B \f$
*   - \f$ B \leftarrow \alpha A^T B \f$
*   - \f$ B \leftarrow \alpha B A \f$
*   - \f$ B \leftarrow \alpha B A^T \f$
*
* where \b T is an upper or lower triangular matrix.
*
* @param (in) order     Row/column order.
* @param (in) side      The side of triangular matrix.
* @param (in) uplo      The triangle in matrix being referenced.
* @param (in) transA    How matrix \b A is to be transposed.
* @param (in) diag      Specify whether matrix is unit triangular.
* @param (in) M         Number of rows in matrix \b B.
* @param (in) N         Number of columns in matrix \b B.
* @param (in) alpha     The factor of matrix \b A.
* @param (in) A         Buffer object storing matrix \b A.
* @param (in) offA      Offset of the first element of the matrix \b A in the
*                      buffer object. Counted in elements.
* @param (in) lda       Leading dimension of matrix \b A. For detailed
*                      description, see clblasStrmm().
* @param (out) B        Buffer object storing matrix \b B.
* @param (in) offB      Offset of the first element of the matrix \b B in the
*                      buffer object. Counted in elements.
* @param (in) ldb       Leading dimension of matrix \b B. For detailed
*                      description, see clblasStrmm().
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasInvalidDevice if a target device does not support floating
*     point arithmetic with double precision;
*   - \b clblasInvalidValue if either \b offA or \b offB exceeds the size
*        of the respective buffer object;
*   - the same error codes as the clblasStrmm() function otherwise.
*
* @ingroup TRMM
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasDtrmmNative(JNIEnv *env, jclass cls, jint order, jint side, jint uplo, jint transA, jint diag, jlong M, jlong N, jdouble alpha, jobject A, jlong offA, jlong lda, jobject B, jlong offB, jlong ldb, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // side is primitive
    // uplo is primitive
    // transA is primitive
    // diag is primitive
    // M is primitive
    // N is primitive
    // alpha is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasDtrmm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // lda is primitive
    if (B == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasDtrmm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offB is primitive
    // ldb is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasDtrmm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasDtrmm(order=%d, side=%d, uplo=%d, transA=%d, diag=%d, M=%ld, N=%ld, alpha=%lf, A=%p, offA=%ld, lda=%ld, B=%p, offB=%ld, ldb=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, side, uplo, transA, diag, M, N, alpha, A, offA, lda, B, offB, ldb, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasSide side_native;
    clblasUplo uplo_native;
    clblasTranspose transA_native;
    clblasDiag diag_native;
    size_t M_native = 0;
    size_t N_native = 0;
    cl_double alpha_native;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    size_t lda_native = 0;
    cl_mem B_native = nullptr;
    size_t offB_native = 0;
    size_t ldb_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    side_native = (clblasSide)side;
    uplo_native = (clblasUplo)uplo;
    transA_native = (clblasTranspose)transA;
    diag_native = (clblasDiag)diag;
    M_native = (size_t)M;
    N_native = (size_t)N;
    alpha_native = (cl_double)alpha;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    lda_native = (size_t)lda;
    if (!init_cl_mem(env, B, B_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offB_native = (size_t)offB;
    ldb_native = (size_t)ldb;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasDtrmm(order_native, side_native, uplo_native, transA_native, diag_native, M_native, N_native, alpha_native, A_native, offA_native, lda_native, B_native, offB_native, ldb_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // side is primitive
    // uplo is primitive
    // transA is primitive
    // diag is primitive
    // M is primitive
    // N is primitive
    // alpha is primitive
    // A is a read-only native pointer
    // offA is primitive
    // lda is primitive
    // B is a read-only native pointer
    // offB is primitive
    // ldb is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* Multiplying a matrix by a triangular matrix with float complex
*        elements. Extended version.
*
* Matrix-triangular matrix products:
*   - \f$ B \leftarrow \alpha A B \f$
*   - \f$ B \leftarrow \alpha A^T B \f$
*   - \f$ B \leftarrow \alpha B A \f$
*   - \f$ B \leftarrow \alpha B A^T \f$
*
* where \b T is an upper or lower triangular matrix.
* @param (in) order     Row/column order.
* @param (in) side      The side of triangular matrix.
* @param (in) uplo      The triangle in matrix being referenced.
* @param (in) transA    How matrix \b A is to be transposed.
* @param (in) diag      Specify whether matrix is unit triangular.
* @param (in) M         Number of rows in matrix \b B.
* @param (in) N         Number of columns in matrix \b B.
* @param (in) alpha     The factor of matrix \b A.
* @param (in) offA      Offset of the first element of the matrix \b A in the
*                      buffer object. Counted in elements.
* @param (in) A         Buffer object storing matrix \b A.
* @param (in) lda       Leading dimension of matrix \b A. For detailed
*                      description, see clblasStrmm().
* @param (out) B        Buffer object storing matrix \b B.
* @param (in) offB      Offset of the first element of the matrix \b B in the
*                      buffer object. Counted in elements.
* @param (in) ldb       Leading dimension of matrix \b B. For detailed
*                      description, see clblasStrmm().
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasInvalidValue if either \b offA or \b offB exceeds the size
*        of the respective buffer object;
*   - the same error codes as clblasStrmm() otherwise.
*
* @ingroup TRMM
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasCtrmmNative(JNIEnv *env, jclass cls, jint order, jint side, jint uplo, jint transA, jint diag, jlong M, jlong N, jfloatArray alpha, jobject A, jlong offA, jlong lda, jobject B, jlong offB, jlong ldb, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // side is primitive
    // uplo is primitive
    // transA is primitive
    // diag is primitive
    // M is primitive
    // N is primitive
    if (alpha == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'alpha' is null for clblasCtrmm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasCtrmm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // lda is primitive
    if (B == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasCtrmm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offB is primitive
    // ldb is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasCtrmm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasCtrmm(order=%d, side=%d, uplo=%d, transA=%d, diag=%d, M=%ld, N=%ld, alpha=%p, A=%p, offA=%ld, lda=%ld, B=%p, offB=%ld, ldb=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, side, uplo, transA, diag, M, N, alpha, A, offA, lda, B, offB, ldb, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasSide side_native;
    clblasUplo uplo_native;
    clblasTranspose transA_native;
    clblasDiag diag_native;
    size_t M_native = 0;
    size_t N_native = 0;
    FloatComplex alpha_native;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    size_t lda_native = 0;
    cl_mem B_native = nullptr;
    size_t offB_native = 0;
    size_t ldb_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    side_native = (clblasSide)side;
    uplo_native = (clblasUplo)uplo;
    transA_native = (clblasTranspose)transA;
    diag_native = (clblasDiag)diag;
    M_native = (size_t)M;
    N_native = (size_t)N;
    if (!init_FloatComplex(env, alpha, alpha_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    lda_native = (size_t)lda;
    if (!init_cl_mem(env, B, B_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offB_native = (size_t)offB;
    ldb_native = (size_t)ldb;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasCtrmm(order_native, side_native, uplo_native, transA_native, diag_native, M_native, N_native, alpha_native, A_native, offA_native, lda_native, B_native, offB_native, ldb_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // side is primitive
    // uplo is primitive
    // transA is primitive
    // diag is primitive
    // M is primitive
    // N is primitive
    if (!release_FloatComplex(env, alpha_native, alpha, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // A is a read-only native pointer
    // offA is primitive
    // lda is primitive
    // B is a read-only native pointer
    // offB is primitive
    // ldb is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* Multiplying a matrix by a triangular matrix with double complex
*        elements. Extended version.
*
* Matrix-triangular matrix products:
*   - \f$ B \leftarrow \alpha A B \f$
*   - \f$ B \leftarrow \alpha A^T B \f$
*   - \f$ B \leftarrow \alpha B A \f$
*   - \f$ B \leftarrow \alpha B A^T \f$
*
* where \b T is an upper or lower triangular matrix.
*
* @param (in) order     Row/column order.
* @param (in) side      The side of triangular matrix.
* @param (in) uplo      The triangle in matrix being referenced.
* @param (in) transA    How matrix \b A is to be transposed.
* @param (in) diag      Specify whether matrix is unit triangular.
* @param (in) M         Number of rows in matrix \b B.
* @param (in) N         Number of columns in matrix \b B.
* @param (in) alpha     The factor of matrix \b A.
* @param (in) A         Buffer object storing matrix \b A.
* @param (in) offA      Offset of the first element of the matrix \b A in the
*                      buffer object. Counted in elements.
* @param (in) lda       Leading dimension of matrix \b A. For detailed
*                      description, see clblasStrmm().
* @param (out) B        Buffer object storing matrix \b B.
* @param (in) offB      Offset of the first element of the matrix \b B in the
*                      buffer object. Counted in elements.
* @param (in) ldb       Leading dimension of matrix \b B. For detailed
*                      description, see clblasStrmm().
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasInvalidDevice if a target device does not support floating
*     point arithmetic with double precision;
*   - \b clblasInvalidValue if either \b offA or \b offB exceeds the size
*        of the respective buffer object;
*   - the same error codes as the clblasStrmm() function otherwise.
*
* @ingroup TRMM
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasZtrmmNative(JNIEnv *env, jclass cls, jint order, jint side, jint uplo, jint transA, jint diag, jlong M, jlong N, jdoubleArray alpha, jobject A, jlong offA, jlong lda, jobject B, jlong offB, jlong ldb, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // side is primitive
    // uplo is primitive
    // transA is primitive
    // diag is primitive
    // M is primitive
    // N is primitive
    if (alpha == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'alpha' is null for clblasZtrmm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasZtrmm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // lda is primitive
    if (B == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasZtrmm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offB is primitive
    // ldb is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasZtrmm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasZtrmm(order=%d, side=%d, uplo=%d, transA=%d, diag=%d, M=%ld, N=%ld, alpha=%p, A=%p, offA=%ld, lda=%ld, B=%p, offB=%ld, ldb=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, side, uplo, transA, diag, M, N, alpha, A, offA, lda, B, offB, ldb, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasSide side_native;
    clblasUplo uplo_native;
    clblasTranspose transA_native;
    clblasDiag diag_native;
    size_t M_native = 0;
    size_t N_native = 0;
    DoubleComplex alpha_native;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    size_t lda_native = 0;
    cl_mem B_native = nullptr;
    size_t offB_native = 0;
    size_t ldb_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    side_native = (clblasSide)side;
    uplo_native = (clblasUplo)uplo;
    transA_native = (clblasTranspose)transA;
    diag_native = (clblasDiag)diag;
    M_native = (size_t)M;
    N_native = (size_t)N;
    if (!init_DoubleComplex(env, alpha, alpha_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    lda_native = (size_t)lda;
    if (!init_cl_mem(env, B, B_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offB_native = (size_t)offB;
    ldb_native = (size_t)ldb;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasZtrmm(order_native, side_native, uplo_native, transA_native, diag_native, M_native, N_native, alpha_native, A_native, offA_native, lda_native, B_native, offB_native, ldb_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // side is primitive
    // uplo is primitive
    // transA is primitive
    // diag is primitive
    // M is primitive
    // N is primitive
    if (!release_DoubleComplex(env, alpha_native, alpha, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // A is a read-only native pointer
    // offA is primitive
    // lda is primitive
    // B is a read-only native pointer
    // offB is primitive
    // ldb is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**@}*/
/**
* <pre>
* @defgroup TRSM TRSM - Solving triangular systems of equations
* @ingroup BLAS3
* </pre>
*/
/**@{*/
/**
* <pre>
* Solving triangular systems of equations with multiple right-hand
*        sides and float elements. Extended version.
*
* Solving triangular systems of equations:
*   - \f$ B \leftarrow \alpha A^{-1} B \f$
*   - \f$ B \leftarrow \alpha A^{-T} B \f$
*   - \f$ B \leftarrow \alpha B A^{-1} \f$
*   - \f$ B \leftarrow \alpha B A^{-T} \f$
*
* where \b T is an upper or lower triangular matrix.
*
* @param (in) order     Row/column order.
* @param (in) side      The side of triangular matrix.
* @param (in) uplo      The triangle in matrix being referenced.
* @param (in) transA    How matrix \b A is to be transposed.
* @param (in) diag      Specify whether matrix is unit triangular.
* @param (in) M         Number of rows in matrix \b B.
* @param (in) N         Number of columns in matrix \b B.
* @param (in) alpha     The factor of matrix \b A.
* @param (in) A         Buffer object storing matrix \b A.
* @param (in) offA      Offset of the first element of the matrix \b A in the
*                      buffer object. Counted in elements.
* @param (in) lda       Leading dimension of matrix \b A. It cannot be less
*                      than \b M when the \b side parameter is set to
*                      \b clblasLeft,\n or less than \b N
*                      when it is set to \b clblasRight.
* @param (out) B        Buffer object storing matrix \b B.
* @param (in) offB      Offset of the first element of the matrix \b B in the
*                      buffer object. Counted in elements.
* @param (in) ldb       Leading dimension of matrix \b B. It cannot be less
*                      than \b N when the \b order parameter is set to
*                      \b clblasRowMajor,\n or less than \b M
*                      when it is set to \b clblasColumnMajor.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasInvalidValue if either \b offA or \b offB exceeds the size
*        of the respective buffer object;
*   - the same error codes as clblasStrsm() otherwise.
*
* @ingroup TRSM
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasStrsmNative(JNIEnv *env, jclass cls, jint order, jint side, jint uplo, jint transA, jint diag, jlong M, jlong N, jfloat alpha, jobject A, jlong offA, jlong lda, jobject B, jlong offB, jlong ldb, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // side is primitive
    // uplo is primitive
    // transA is primitive
    // diag is primitive
    // M is primitive
    // N is primitive
    // alpha is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasStrsm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // lda is primitive
    if (B == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasStrsm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offB is primitive
    // ldb is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasStrsm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasStrsm(order=%d, side=%d, uplo=%d, transA=%d, diag=%d, M=%ld, N=%ld, alpha=%f, A=%p, offA=%ld, lda=%ld, B=%p, offB=%ld, ldb=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, side, uplo, transA, diag, M, N, alpha, A, offA, lda, B, offB, ldb, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasSide side_native;
    clblasUplo uplo_native;
    clblasTranspose transA_native;
    clblasDiag diag_native;
    size_t M_native = 0;
    size_t N_native = 0;
    cl_float alpha_native;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    size_t lda_native = 0;
    cl_mem B_native = nullptr;
    size_t offB_native = 0;
    size_t ldb_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    side_native = (clblasSide)side;
    uplo_native = (clblasUplo)uplo;
    transA_native = (clblasTranspose)transA;
    diag_native = (clblasDiag)diag;
    M_native = (size_t)M;
    N_native = (size_t)N;
    alpha_native = (cl_float)alpha;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    lda_native = (size_t)lda;
    if (!init_cl_mem(env, B, B_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offB_native = (size_t)offB;
    ldb_native = (size_t)ldb;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasStrsm(order_native, side_native, uplo_native, transA_native, diag_native, M_native, N_native, alpha_native, A_native, offA_native, lda_native, B_native, offB_native, ldb_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // side is primitive
    // uplo is primitive
    // transA is primitive
    // diag is primitive
    // M is primitive
    // N is primitive
    // alpha is primitive
    // A is a read-only native pointer
    // offA is primitive
    // lda is primitive
    // B is a read-only native pointer
    // offB is primitive
    // ldb is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* @example example_strsm.c
* This is an example of how to use the @ref clblasStrsmEx function.
* </pre>
*/
/**
* <pre>
* Solving triangular systems of equations with multiple right-hand
*        sides and double elements. Extended version.
*
* Solving triangular systems of equations:
*   - \f$ B \leftarrow \alpha A^{-1} B \f$
*   - \f$ B \leftarrow \alpha A^{-T} B \f$
*   - \f$ B \leftarrow \alpha B A^{-1} \f$
*   - \f$ B \leftarrow \alpha B A^{-T} \f$
*
* where \b T is an upper or lower triangular matrix.
*
* @param (in) order     Row/column order.
* @param (in) side      The side of triangular matrix.
* @param (in) uplo      The triangle in matrix being referenced.
* @param (in) transA    How matrix \b A is to be transposed.
* @param (in) diag      Specify whether matrix is unit triangular.
* @param (in) M         Number of rows in matrix \b B.
* @param (in) N         Number of columns in matrix \b B.
* @param (in) alpha     The factor of matrix \b A.
* @param (in) A         Buffer object storing matrix \b A.
* @param (in) offA      Offset of the first element of the matrix \b A in the
*                      buffer object. Counted in elements.
* @param (in) lda       Leading dimension of matrix \b A. For detailed
*                      description, see clblasStrsm().
* @param (out) B        Buffer object storing matrix \b B.
* @param (in) offB      Offset of the first element of the matrix \b A in the
*                      buffer object. Counted in elements.
* @param (in) ldb       Leading dimension of matrix \b B. For detailed
*                      description, see clblasStrsm().
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasInvalidDevice if a target device does not support floating
*        point arithmetic with double precision;
*   - \b clblasInvalidValue if either \b offA or \b offB exceeds the size
*        of the respective buffer object;
*   - the same error codes as the clblasStrsm() function otherwise.
*
* @ingroup TRSM
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasDtrsmNative(JNIEnv *env, jclass cls, jint order, jint side, jint uplo, jint transA, jint diag, jlong M, jlong N, jdouble alpha, jobject A, jlong offA, jlong lda, jobject B, jlong offB, jlong ldb, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // side is primitive
    // uplo is primitive
    // transA is primitive
    // diag is primitive
    // M is primitive
    // N is primitive
    // alpha is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasDtrsm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // lda is primitive
    if (B == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasDtrsm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offB is primitive
    // ldb is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasDtrsm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasDtrsm(order=%d, side=%d, uplo=%d, transA=%d, diag=%d, M=%ld, N=%ld, alpha=%lf, A=%p, offA=%ld, lda=%ld, B=%p, offB=%ld, ldb=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, side, uplo, transA, diag, M, N, alpha, A, offA, lda, B, offB, ldb, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasSide side_native;
    clblasUplo uplo_native;
    clblasTranspose transA_native;
    clblasDiag diag_native;
    size_t M_native = 0;
    size_t N_native = 0;
    cl_double alpha_native;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    size_t lda_native = 0;
    cl_mem B_native = nullptr;
    size_t offB_native = 0;
    size_t ldb_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    side_native = (clblasSide)side;
    uplo_native = (clblasUplo)uplo;
    transA_native = (clblasTranspose)transA;
    diag_native = (clblasDiag)diag;
    M_native = (size_t)M;
    N_native = (size_t)N;
    alpha_native = (cl_double)alpha;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    lda_native = (size_t)lda;
    if (!init_cl_mem(env, B, B_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offB_native = (size_t)offB;
    ldb_native = (size_t)ldb;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasDtrsm(order_native, side_native, uplo_native, transA_native, diag_native, M_native, N_native, alpha_native, A_native, offA_native, lda_native, B_native, offB_native, ldb_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // side is primitive
    // uplo is primitive
    // transA is primitive
    // diag is primitive
    // M is primitive
    // N is primitive
    // alpha is primitive
    // A is a read-only native pointer
    // offA is primitive
    // lda is primitive
    // B is a read-only native pointer
    // offB is primitive
    // ldb is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* Solving triangular systems of equations with multiple right-hand
*        sides and float complex elements. Extended version.
*
* Solving triangular systems of equations:
*   - \f$ B \leftarrow \alpha A^{-1} B \f$
*   - \f$ B \leftarrow \alpha A^{-T} B \f$
*   - \f$ B \leftarrow \alpha B A^{-1} \f$
*   - \f$ B \leftarrow \alpha B A^{-T} \f$
*
* where \b T is an upper or lower triangular matrix.
*
* @param (in) order     Row/column order.
* @param (in) side      The side of triangular matrix.
* @param (in) uplo      The triangle in matrix being referenced.
* @param (in) transA    How matrix \b A is to be transposed.
* @param (in) diag      Specify whether matrix is unit triangular.
* @param (in) M         Number of rows in matrix \b B.
* @param (in) N         Number of columns in matrix \b B.
* @param (in) alpha     The factor of matrix \b A.
* @param (in) A         Buffer object storing matrix \b A.
* @param (in) offA      Offset of the first element of the matrix \b A in the
*                      buffer object. Counted in elements.
* @param (in) lda       Leading dimension of matrix \b A. For detailed
*                      description, see clblasStrsm().
* @param (out) B        Buffer object storing matrix \b B.
* @param (in) offB      Offset of the first element of the matrix \b B in the
*                      buffer object. Counted in elements.
* @param (in) ldb       Leading dimension of matrix \b B. For detailed
*                      description, see clblasStrsm().
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasInvalidValue if either \b offA or \b offB exceeds the size
*        of the respective buffer object;
*   - the same error codes as clblasStrsm() otherwise.
*
* @ingroup TRSM
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasCtrsmNative(JNIEnv *env, jclass cls, jint order, jint side, jint uplo, jint transA, jint diag, jlong M, jlong N, jfloatArray alpha, jobject A, jlong offA, jlong lda, jobject B, jlong offB, jlong ldb, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // side is primitive
    // uplo is primitive
    // transA is primitive
    // diag is primitive
    // M is primitive
    // N is primitive
    if (alpha == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'alpha' is null for clblasCtrsm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasCtrsm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // lda is primitive
    if (B == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasCtrsm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offB is primitive
    // ldb is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasCtrsm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasCtrsm(order=%d, side=%d, uplo=%d, transA=%d, diag=%d, M=%ld, N=%ld, alpha=%p, A=%p, offA=%ld, lda=%ld, B=%p, offB=%ld, ldb=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, side, uplo, transA, diag, M, N, alpha, A, offA, lda, B, offB, ldb, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasSide side_native;
    clblasUplo uplo_native;
    clblasTranspose transA_native;
    clblasDiag diag_native;
    size_t M_native = 0;
    size_t N_native = 0;
    FloatComplex alpha_native;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    size_t lda_native = 0;
    cl_mem B_native = nullptr;
    size_t offB_native = 0;
    size_t ldb_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    side_native = (clblasSide)side;
    uplo_native = (clblasUplo)uplo;
    transA_native = (clblasTranspose)transA;
    diag_native = (clblasDiag)diag;
    M_native = (size_t)M;
    N_native = (size_t)N;
    if (!init_FloatComplex(env, alpha, alpha_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    lda_native = (size_t)lda;
    if (!init_cl_mem(env, B, B_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offB_native = (size_t)offB;
    ldb_native = (size_t)ldb;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasCtrsm(order_native, side_native, uplo_native, transA_native, diag_native, M_native, N_native, alpha_native, A_native, offA_native, lda_native, B_native, offB_native, ldb_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // side is primitive
    // uplo is primitive
    // transA is primitive
    // diag is primitive
    // M is primitive
    // N is primitive
    if (!release_FloatComplex(env, alpha_native, alpha, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // A is a read-only native pointer
    // offA is primitive
    // lda is primitive
    // B is a read-only native pointer
    // offB is primitive
    // ldb is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* Solving triangular systems of equations with multiple right-hand
*        sides and double complex elements. Extended version.
*
* Solving triangular systems of equations:
*   - \f$ B \leftarrow \alpha A^{-1} B \f$
*   - \f$ B \leftarrow \alpha A^{-T} B \f$
*   - \f$ B \leftarrow \alpha B A^{-1} \f$
*   - \f$ B \leftarrow \alpha B A^{-T} \f$
*
* where \b T is an upper or lower triangular matrix.
*
* @param (in) order     Row/column order.
* @param (in) side      The side of triangular matrix.
* @param (in) uplo      The triangle in matrix being referenced.
* @param (in) transA    How matrix \b A is to be transposed.
* @param (in) diag      Specify whether matrix is unit triangular.
* @param (in) M         Number of rows in matrix \b B.
* @param (in) N         Number of columns in matrix \b B.
* @param (in) alpha     The factor of matrix \b A.
* @param (in) A         Buffer object storing matrix \b A.
* @param (in) offA      Offset of the first element of the matrix \b A in the
*                      buffer object. Counted in elements.
* @param (in) lda       Leading dimension of matrix \b A. For detailed
*                      description, see clblasStrsm().
* @param (out) B        Buffer object storing matrix \b B.
* @param (in) offB      Offset of the first element of the matrix \b B in the
*                      buffer object. Counted in elements.
* @param (in) ldb       Leading dimension of matrix \b B. For detailed
*                      description, see clblasStrsm().
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasInvalidDevice if a target device does not support floating
*        point arithmetic with double precision;
*   - \b clblasInvalidValue if either \b offA or \b offB exceeds the size
*        of the respective buffer object;
*   - the same error codes as the clblasStrsm() function otherwise
*
* @ingroup TRSM
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasZtrsmNative(JNIEnv *env, jclass cls, jint order, jint side, jint uplo, jint transA, jint diag, jlong M, jlong N, jdoubleArray alpha, jobject A, jlong offA, jlong lda, jobject B, jlong offB, jlong ldb, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // side is primitive
    // uplo is primitive
    // transA is primitive
    // diag is primitive
    // M is primitive
    // N is primitive
    if (alpha == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'alpha' is null for clblasZtrsm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasZtrsm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // lda is primitive
    if (B == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasZtrsm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offB is primitive
    // ldb is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasZtrsm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasZtrsm(order=%d, side=%d, uplo=%d, transA=%d, diag=%d, M=%ld, N=%ld, alpha=%p, A=%p, offA=%ld, lda=%ld, B=%p, offB=%ld, ldb=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, side, uplo, transA, diag, M, N, alpha, A, offA, lda, B, offB, ldb, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasSide side_native;
    clblasUplo uplo_native;
    clblasTranspose transA_native;
    clblasDiag diag_native;
    size_t M_native = 0;
    size_t N_native = 0;
    DoubleComplex alpha_native;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    size_t lda_native = 0;
    cl_mem B_native = nullptr;
    size_t offB_native = 0;
    size_t ldb_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    side_native = (clblasSide)side;
    uplo_native = (clblasUplo)uplo;
    transA_native = (clblasTranspose)transA;
    diag_native = (clblasDiag)diag;
    M_native = (size_t)M;
    N_native = (size_t)N;
    if (!init_DoubleComplex(env, alpha, alpha_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    lda_native = (size_t)lda;
    if (!init_cl_mem(env, B, B_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offB_native = (size_t)offB;
    ldb_native = (size_t)ldb;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasZtrsm(order_native, side_native, uplo_native, transA_native, diag_native, M_native, N_native, alpha_native, A_native, offA_native, lda_native, B_native, offB_native, ldb_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // side is primitive
    // uplo is primitive
    // transA is primitive
    // diag is primitive
    // M is primitive
    // N is primitive
    if (!release_DoubleComplex(env, alpha_native, alpha, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // A is a read-only native pointer
    // offA is primitive
    // lda is primitive
    // B is a read-only native pointer
    // offB is primitive
    // ldb is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**@}*/
/**
* <pre>
* @defgroup SYRK SYRK - Symmetric rank-k update of a matrix
* @ingroup BLAS3
* </pre>
*/
/**@{*/
/**
* <pre>
* Rank-k update of a symmetric matrix with float elements.
*        Extended version.
*
* Rank-k updates:
*   - \f$ C \leftarrow \alpha A A^T + \beta C \f$
*   - \f$ C \leftarrow \alpha A^T A + \beta C \f$
*
* where \b C is a symmetric matrix.
*
* @param (in) order      Row/column order.
* @param (in) uplo       The triangle in matrix \b C being referenced.
* @param (in) transA     How matrix \b A is to be transposed.
* @param (in) N          Number of rows and columns in matrix \b C.
* @param (in) K          Number of columns of the matrix \b A if it is not
*                       transposed, and number of rows otherwise.
* @param (in) alpha      The factor of matrix \b A.
* @param (in) A          Buffer object storing the matrix \b A.
* @param (in) offA       Offset of the first element of the matrix \b A in the
*                       buffer object. Counted in elements.
* @param (in) lda        Leading dimension of matrix \b A. It cannot be
*                       less than \b K if \b A is
*                       in the row-major format, and less than \b N
*                       otherwise.
* @param (in) beta       The factor of the matrix \b C.
* @param (out) C         Buffer object storing matrix \b C.
* @param (in) offC       Offset of the first element of the matrix \b C in the
*                       buffer object. Counted in elements.
* @param (in) ldc        Leading dimension of matric \b C. It cannot be less
*                       than \b N.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasInvalidValue if either \b offA or \b offC exceeds the size
*        of the respective buffer object;
*   - the same error codes as the clblasSsyrk() function otherwise.
*
* @ingroup SYRK
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasSsyrkNative(JNIEnv *env, jclass cls, jint order, jint uplo, jint transA, jlong N, jlong K, jfloat alpha, jobject A, jlong offA, jlong lda, jfloat beta, jobject C, jlong offC, jlong ldc, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // transA is primitive
    // N is primitive
    // K is primitive
    // alpha is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasSsyrk");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // lda is primitive
    // beta is primitive
    if (C == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'C' is null for clblasSsyrk");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offC is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasSsyrk");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasSsyrk(order=%d, uplo=%d, transA=%d, N=%ld, K=%ld, alpha=%f, A=%p, offA=%ld, lda=%ld, beta=%f, C=%p, offC=%ld, ldc=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, transA, N, K, alpha, A, offA, lda, beta, C, offC, ldc, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    clblasTranspose transA_native;
    size_t N_native = 0;
    size_t K_native = 0;
    cl_float alpha_native;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    size_t lda_native = 0;
    cl_float beta_native;
    cl_mem C_native = nullptr;
    size_t offC_native = 0;
    size_t ldc_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    transA_native = (clblasTranspose)transA;
    N_native = (size_t)N;
    K_native = (size_t)K;
    alpha_native = (cl_float)alpha;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    lda_native = (size_t)lda;
    beta_native = (cl_float)beta;
    if (!init_cl_mem(env, C, C_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offC_native = (size_t)offC;
    ldc_native = (size_t)ldc;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasSsyrk(order_native, uplo_native, transA_native, N_native, K_native, alpha_native, A_native, offA_native, lda_native, beta_native, C_native, offC_native, ldc_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // transA is primitive
    // N is primitive
    // K is primitive
    // alpha is primitive
    // A is a read-only native pointer
    // offA is primitive
    // lda is primitive
    // beta is primitive
    // C is a read-only native pointer
    // offC is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* @example example_ssyrk.c
* This is an example of how to use the @ref clblasSsyrkEx function.
* </pre>
*/
/**
* <pre>
* Rank-k update of a symmetric matrix with double elements.
*        Extended version.
*
* Rank-k updates:
*   - \f$ C \leftarrow \alpha A A^T + \beta C \f$
*   - \f$ C \leftarrow \alpha A^T A + \beta C \f$
*
* where \b C is a symmetric matrix.
*
* @param (in) order      Row/column order.
* @param (in) uplo       The triangle in matrix \b C being referenced.
* @param (in) transA     How matrix \b A is to be transposed.
* @param (in) N          Number of rows and columns in matrix \b C.
* @param (in) K          Number of columns of the matrix \b A if it is not
*                       transposed, and number of rows otherwise.
* @param (in) alpha      The factor of matrix \b A.
* @param (in) A          Buffer object storing the matrix \b A.
* @param (in) offA       Offset of the first element of the matrix \b A in the
*                       buffer object. Counted in elements.
* @param (in) lda        Leading dimension of matrix \b A. For detailed
*                       description, see clblasSsyrk().
* @param (in) beta       The factor of the matrix \b C.
* @param (out) C         Buffer object storing matrix \b C.
* @param (in) offC       Offset of the first element of the matrix \b C in the
*                       buffer object. Counted in elements.
* @param (in) ldc        Leading dimension of matrix \b C. It cannot be less
*                       than \b N.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasInvalidDevice if a target device does not support floating
*        point arithmetic with double precision;
*   - \b clblasInvalidValue if either \b offA or \b offC exceeds the size
*        of the respective buffer object;
*   - the same error codes as the clblasSsyrk() function otherwise.
*
* @ingroup SYRK
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasDsyrkNative(JNIEnv *env, jclass cls, jint order, jint uplo, jint transA, jlong N, jlong K, jdouble alpha, jobject A, jlong offA, jlong lda, jdouble beta, jobject C, jlong offC, jlong ldc, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // transA is primitive
    // N is primitive
    // K is primitive
    // alpha is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasDsyrk");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // lda is primitive
    // beta is primitive
    if (C == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'C' is null for clblasDsyrk");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offC is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasDsyrk");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasDsyrk(order=%d, uplo=%d, transA=%d, N=%ld, K=%ld, alpha=%lf, A=%p, offA=%ld, lda=%ld, beta=%lf, C=%p, offC=%ld, ldc=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, transA, N, K, alpha, A, offA, lda, beta, C, offC, ldc, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    clblasTranspose transA_native;
    size_t N_native = 0;
    size_t K_native = 0;
    cl_double alpha_native;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    size_t lda_native = 0;
    cl_double beta_native;
    cl_mem C_native = nullptr;
    size_t offC_native = 0;
    size_t ldc_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    transA_native = (clblasTranspose)transA;
    N_native = (size_t)N;
    K_native = (size_t)K;
    alpha_native = (cl_double)alpha;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    lda_native = (size_t)lda;
    beta_native = (cl_double)beta;
    if (!init_cl_mem(env, C, C_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offC_native = (size_t)offC;
    ldc_native = (size_t)ldc;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasDsyrk(order_native, uplo_native, transA_native, N_native, K_native, alpha_native, A_native, offA_native, lda_native, beta_native, C_native, offC_native, ldc_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // transA is primitive
    // N is primitive
    // K is primitive
    // alpha is primitive
    // A is a read-only native pointer
    // offA is primitive
    // lda is primitive
    // beta is primitive
    // C is a read-only native pointer
    // offC is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* Rank-k update of a symmetric matrix with complex float elements.
*        Extended version.
*
* Rank-k updates:
*   - \f$ C \leftarrow \alpha A A^T + \beta C \f$
*   - \f$ C \leftarrow \alpha A^T A + \beta C \f$
*
* where \b C is a symmetric matrix.
*
* @param (in) order      Row/column order.
* @param (in) uplo       The triangle in matrix \b C being referenced.
* @param (in) transA     How matrix \b A is to be transposed.
* @param (in) N          Number of rows and columns in matrix \b C.
* @param (in) K          Number of columns of the matrix \b A if it is not
*                       transposed, and number of rows otherwise.
* @param (in) alpha      The factor of matrix \b A.
* @param (in) A          Buffer object storing the matrix \b A.
* @param (in) offA       Offset of the first element of the matrix \b A in the
*                       buffer object. Counted in elements.
* @param (in) lda        Leading dimension of matrix \b A. For detailed
*                       description, see clblasSsyrk().
* @param (in) beta       The factor of the matrix \b C.
* @param (out) C         Buffer object storing matrix \b C.
* @param (in) offC       Offset of the first element of the matrix \b C in the
*                       buffer object. Counted in elements.
* @param (in) ldc        Leading dimension of matrix \b C. It cannot be less
*                       than \b N.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasInvalidValue if either \b offA or \b offC exceeds the size
*        of the respective buffer object;
*   - \b clblasInvalidValue if \b transA is set to \ref clblasConjTrans.
*   - the same error codes as the clblasSsyrk() function otherwise.
*
* @ingroup SYRK
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasCsyrkNative(JNIEnv *env, jclass cls, jint order, jint uplo, jint transA, jlong N, jlong K, jfloatArray alpha, jobject A, jlong offA, jlong lda, jfloatArray beta, jobject C, jlong offC, jlong ldc, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // transA is primitive
    // N is primitive
    // K is primitive
    if (alpha == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'alpha' is null for clblasCsyrk");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasCsyrk");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // lda is primitive
    if (beta == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'beta' is null for clblasCsyrk");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (C == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'C' is null for clblasCsyrk");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offC is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasCsyrk");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasCsyrk(order=%d, uplo=%d, transA=%d, N=%ld, K=%ld, alpha=%p, A=%p, offA=%ld, lda=%ld, beta=%p, C=%p, offC=%ld, ldc=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, transA, N, K, alpha, A, offA, lda, beta, C, offC, ldc, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    clblasTranspose transA_native;
    size_t N_native = 0;
    size_t K_native = 0;
    FloatComplex alpha_native;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    size_t lda_native = 0;
    FloatComplex beta_native;
    cl_mem C_native = nullptr;
    size_t offC_native = 0;
    size_t ldc_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    transA_native = (clblasTranspose)transA;
    N_native = (size_t)N;
    K_native = (size_t)K;
    if (!init_FloatComplex(env, alpha, alpha_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    lda_native = (size_t)lda;
    if (!init_FloatComplex(env, beta, beta_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_mem(env, C, C_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offC_native = (size_t)offC;
    ldc_native = (size_t)ldc;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasCsyrk(order_native, uplo_native, transA_native, N_native, K_native, alpha_native, A_native, offA_native, lda_native, beta_native, C_native, offC_native, ldc_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // transA is primitive
    // N is primitive
    // K is primitive
    if (!release_FloatComplex(env, alpha_native, alpha, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // A is a read-only native pointer
    // offA is primitive
    // lda is primitive
    if (!release_FloatComplex(env, beta_native, beta, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // C is a read-only native pointer
    // offC is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* Rank-k update of a symmetric matrix with complex double elements.
*        Extended version.
*
* Rank-k updates:
*   - \f$ C \leftarrow \alpha A A^T + \beta C \f$
*   - \f$ C \leftarrow \alpha A^T A + \beta C \f$
*
* where \b C is a symmetric matrix.
*
* @param (in) order      Row/column order.
* @param (in) uplo       The triangle in matrix \b C being referenced.
* @param (in) transA     How matrix \b A is to be transposed.
* @param (in) N          Number of rows and columns in matrix \b C.
* @param (in) K          Number of columns of the matrix \b A if it is not
*                       transposed, and number of rows otherwise.
* @param (in) alpha      The factor of matrix \b A.
* @param (in) A          Buffer object storing the matrix \b A.
* @param (in) offA       Offset of the first element of the matrix \b A in the
*                       buffer object. Counted in elements.
* @param (in) lda        Leading dimension of matrix \b A. For detailed
*                       description, see clblasSsyrk().
* @param (in) beta       The factor of the matrix \b C.
* @param (out) C         Buffer object storing matrix \b C.
* @param (in) offC       Offset of the first element of the matrix \b C in the
*                       buffer object. Counted in elements.
* @param (in) ldc        Leading dimension of matrix \b C. It cannot be less
*                       than \b N.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasInvalidDevice if a target device does not support floating
*         point arithmetic with double precision;
*   - \b clblasInvalidValue if either \b offA or \b offC exceeds the size
*        of the respective buffer object;
*   - \b clblasInvalidValue if \b transA is set to \ref clblasConjTrans.
*   - the same error codes as the clblasSsyrk() function otherwise.
*
* @ingroup SYRK
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasZsyrkNative(JNIEnv *env, jclass cls, jint order, jint uplo, jint transA, jlong N, jlong K, jdoubleArray alpha, jobject A, jlong offA, jlong lda, jdoubleArray beta, jobject C, jlong offC, jlong ldc, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // transA is primitive
    // N is primitive
    // K is primitive
    if (alpha == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'alpha' is null for clblasZsyrk");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasZsyrk");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // lda is primitive
    if (beta == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'beta' is null for clblasZsyrk");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (C == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'C' is null for clblasZsyrk");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offC is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasZsyrk");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasZsyrk(order=%d, uplo=%d, transA=%d, N=%ld, K=%ld, alpha=%p, A=%p, offA=%ld, lda=%ld, beta=%p, C=%p, offC=%ld, ldc=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, transA, N, K, alpha, A, offA, lda, beta, C, offC, ldc, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    clblasTranspose transA_native;
    size_t N_native = 0;
    size_t K_native = 0;
    DoubleComplex alpha_native;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    size_t lda_native = 0;
    DoubleComplex beta_native;
    cl_mem C_native = nullptr;
    size_t offC_native = 0;
    size_t ldc_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    transA_native = (clblasTranspose)transA;
    N_native = (size_t)N;
    K_native = (size_t)K;
    if (!init_DoubleComplex(env, alpha, alpha_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    lda_native = (size_t)lda;
    if (!init_DoubleComplex(env, beta, beta_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_mem(env, C, C_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offC_native = (size_t)offC;
    ldc_native = (size_t)ldc;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasZsyrk(order_native, uplo_native, transA_native, N_native, K_native, alpha_native, A_native, offA_native, lda_native, beta_native, C_native, offC_native, ldc_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // transA is primitive
    // N is primitive
    // K is primitive
    if (!release_DoubleComplex(env, alpha_native, alpha, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // A is a read-only native pointer
    // offA is primitive
    // lda is primitive
    if (!release_DoubleComplex(env, beta_native, beta, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // C is a read-only native pointer
    // offC is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**@}*/
/**
* <pre>
* @defgroup SYR2K SYR2K - Symmetric rank-2k update to a matrix
* @ingroup BLAS3
* </pre>
*/
/**@{*/
/**
* <pre>
* Rank-2k update of a symmetric matrix with float elements.
*        Extended version.
*
* Rank-k updates:
*   - \f$ C \leftarrow \alpha A B^T + \alpha B A^T + \beta C \f$
*   - \f$ C \leftarrow \alpha A^T B + \alpha B^T A \beta C \f$
*
* where \b C is a symmetric matrix.
*
* @param (in) order      Row/column order.
* @param (in) uplo       The triangle in matrix \b C being referenced.
* @param (in) transAB    How matrices \b A and \b B is to be transposed.
* @param (in) N          Number of rows and columns in matrix \b C.
* @param (in) K          Number of columns of the matrices \b A and \b B if they
*                       are not transposed, and number of rows otherwise.
* @param (in) alpha      The factor of matrices \b A and \b B.
* @param (in) A          Buffer object storing matrix \b A.
* @param (in) offA       Offset of the first element of the matrix \b A in the
*                       buffer object. Counted in elements.
* @param (in) lda        Leading dimension of matrix \b A. It cannot be less
*                       than \b K if \b A is
*                       in the row-major format, and less than \b N
*                       otherwise.
* @param (in) B          Buffer object storing matrix \b B.
* @param (in) offB       Offset of the first element of the matrix \b B in the
*                       buffer object. Counted in elements.
* @param (in) ldb        Leading dimension of matrix \b B. It cannot be less
*                       less than \b K if \b B matches to the op(\b B) matrix
*                       in the row-major format, and less than \b N
*                       otherwise.
* @param (in) beta       The factor of matrix \b C.
* @param (out) C         Buffer object storing matrix \b C.
* @param (in) offC       Offset of the first element of the matrix \b C in the
*                       buffer object. Counted in elements.
* @param (in) ldc        Leading dimension of matrix \b C. It cannot be less
*                       than \b N.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasInvalidValue if either \b offA, \b offB or \b offC exceeds
*        the size of the respective buffer object;
*   - the same error codes as the clblasSsyr2k() function otherwise.
*
* @ingroup SYR2K
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasSsyr2kNative(JNIEnv *env, jclass cls, jint order, jint uplo, jint transAB, jlong N, jlong K, jfloat alpha, jobject A, jlong offA, jlong lda, jobject B, jlong offB, jlong ldb, jfloat beta, jobject C, jlong offC, jlong ldc, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // transAB is primitive
    // N is primitive
    // K is primitive
    // alpha is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasSsyr2k");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // lda is primitive
    if (B == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasSsyr2k");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offB is primitive
    // ldb is primitive
    // beta is primitive
    if (C == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'C' is null for clblasSsyr2k");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offC is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasSsyr2k");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasSsyr2k(order=%d, uplo=%d, transAB=%d, N=%ld, K=%ld, alpha=%f, A=%p, offA=%ld, lda=%ld, B=%p, offB=%ld, ldb=%ld, beta=%f, C=%p, offC=%ld, ldc=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, transAB, N, K, alpha, A, offA, lda, B, offB, ldb, beta, C, offC, ldc, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    clblasTranspose transAB_native;
    size_t N_native = 0;
    size_t K_native = 0;
    cl_float alpha_native;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    size_t lda_native = 0;
    cl_mem B_native = nullptr;
    size_t offB_native = 0;
    size_t ldb_native = 0;
    cl_float beta_native;
    cl_mem C_native = nullptr;
    size_t offC_native = 0;
    size_t ldc_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    transAB_native = (clblasTranspose)transAB;
    N_native = (size_t)N;
    K_native = (size_t)K;
    alpha_native = (cl_float)alpha;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    lda_native = (size_t)lda;
    if (!init_cl_mem(env, B, B_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offB_native = (size_t)offB;
    ldb_native = (size_t)ldb;
    beta_native = (cl_float)beta;
    if (!init_cl_mem(env, C, C_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offC_native = (size_t)offC;
    ldc_native = (size_t)ldc;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasSsyr2k(order_native, uplo_native, transAB_native, N_native, K_native, alpha_native, A_native, offA_native, lda_native, B_native, offB_native, ldb_native, beta_native, C_native, offC_native, ldc_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // transAB is primitive
    // N is primitive
    // K is primitive
    // alpha is primitive
    // A is a read-only native pointer
    // offA is primitive
    // lda is primitive
    // B is a read-only native pointer
    // offB is primitive
    // ldb is primitive
    // beta is primitive
    // C is a read-only native pointer
    // offC is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* @example example_ssyr2k.c
* This is an example of how to use the @ref clblasSsyr2kEx function.
* </pre>
*/
/**
* <pre>
* Rank-2k update of a symmetric matrix with double elements.
*        Extended version.
*
* Rank-k updates:
*   - \f$ C \leftarrow \alpha A B^T + \alpha B A^T + \beta C \f$
*   - \f$ C \leftarrow \alpha A^T B + \alpha B^T A \beta C \f$
*
* where \b C is a symmetric matrix.
*
* @param (in) order      Row/column order.
* @param (in) uplo       The triangle in matrix \b C being referenced.
* @param (in) transAB    How matrices \b A and \b B is to be transposed.
* @param (in) N          Number of rows and columns in matrix \b C.
* @param (in) K          Number of columns of the matrices \b A and \b B if they
*                       are not transposed, and number of rows otherwise.
* @param (in) alpha      The factor of matrices \b A and \b B.
* @param (in) A          Buffer object storing matrix \b A.
* @param (in) offA       Offset of the first element of the matrix \b A in the
*                       buffer object. Counted in elements.
* @param (in) lda        Leading dimension of matrix \b A. For detailed
*                       description, see clblasSsyr2k().
* @param (in) B          Buffer object storing matrix \b B.
* @param (in) offB       Offset of the first element of the matrix \b B in the
*                       buffer object. Counted in elements.
* @param (in) ldb        Leading dimension of matrix \b B. For detailed
*                       description, see clblasSsyr2k().
* @param (in) beta       The factor of matrix \b C.
* @param (out) C         Buffer object storing matrix \b C.
* @param (in) offC       Offset of the first element of the matrix \b C in the
*                       buffer object. Counted in elements.
* @param (in) ldc        Leading dimension of matrix \b C. It cannot be less
*                       than \b N.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasInvalidDevice if a target device does not support floating
*        point arithmetic with double precision;
*   - \b clblasInvalidValue if either \b offA, \b offB or \b offC exceeds
*        the size of the respective buffer object;
*   - the same error codes as the clblasSsyr2k() function otherwise.
*
* @ingroup SYR2K
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasDsyr2kNative(JNIEnv *env, jclass cls, jint order, jint uplo, jint transAB, jlong N, jlong K, jdouble alpha, jobject A, jlong offA, jlong lda, jobject B, jlong offB, jlong ldb, jdouble beta, jobject C, jlong offC, jlong ldc, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // transAB is primitive
    // N is primitive
    // K is primitive
    // alpha is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasDsyr2k");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // lda is primitive
    if (B == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasDsyr2k");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offB is primitive
    // ldb is primitive
    // beta is primitive
    if (C == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'C' is null for clblasDsyr2k");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offC is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasDsyr2k");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasDsyr2k(order=%d, uplo=%d, transAB=%d, N=%ld, K=%ld, alpha=%lf, A=%p, offA=%ld, lda=%ld, B=%p, offB=%ld, ldb=%ld, beta=%lf, C=%p, offC=%ld, ldc=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, transAB, N, K, alpha, A, offA, lda, B, offB, ldb, beta, C, offC, ldc, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    clblasTranspose transAB_native;
    size_t N_native = 0;
    size_t K_native = 0;
    cl_double alpha_native;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    size_t lda_native = 0;
    cl_mem B_native = nullptr;
    size_t offB_native = 0;
    size_t ldb_native = 0;
    cl_double beta_native;
    cl_mem C_native = nullptr;
    size_t offC_native = 0;
    size_t ldc_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    transAB_native = (clblasTranspose)transAB;
    N_native = (size_t)N;
    K_native = (size_t)K;
    alpha_native = (cl_double)alpha;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    lda_native = (size_t)lda;
    if (!init_cl_mem(env, B, B_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offB_native = (size_t)offB;
    ldb_native = (size_t)ldb;
    beta_native = (cl_double)beta;
    if (!init_cl_mem(env, C, C_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offC_native = (size_t)offC;
    ldc_native = (size_t)ldc;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasDsyr2k(order_native, uplo_native, transAB_native, N_native, K_native, alpha_native, A_native, offA_native, lda_native, B_native, offB_native, ldb_native, beta_native, C_native, offC_native, ldc_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // transAB is primitive
    // N is primitive
    // K is primitive
    // alpha is primitive
    // A is a read-only native pointer
    // offA is primitive
    // lda is primitive
    // B is a read-only native pointer
    // offB is primitive
    // ldb is primitive
    // beta is primitive
    // C is a read-only native pointer
    // offC is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* Rank-2k update of a symmetric matrix with complex float elements.
*        Extended version.
*
* Rank-k updates:
*   - \f$ C \leftarrow \alpha A B^T + \alpha B A^T + \beta C \f$
*   - \f$ C \leftarrow \alpha A^T B + \alpha B^T A \beta C \f$
*
* where \b C is a symmetric matrix.
*
* @param (in) order      Row/column order.
* @param (in) uplo       The triangle in matrix \b C being referenced.
* @param (in) transAB    How matrices \b A and \b B is to be transposed.
* @param (in) N          Number of rows and columns in matrix \b C.
* @param (in) K          Number of columns of the matrices \b A and \b B if they
*                       are not transposed, and number of rows otherwise.
* @param (in) alpha      The factor of matrices \b A and \b B.
* @param (in) A          Buffer object storing matrix \b A.
* @param (in) offA       Offset of the first element of the matrix \b A in the
*                       buffer object. Counted in elements.
* @param (in) lda        Leading dimension of matrix \b A. For detailed
*                       description, see clblasSsyr2k().
* @param (in) B          Buffer object storing matrix \b B.
* @param (in) offB       Offset of the first element of the matrix \b B in the
*                       buffer object. Counted in elements.
* @param (in) ldb        Leading dimension of matrix \b B. For detailed
*                       description, see clblasSsyr2k().
* @param (in) beta       The factor of matrix \b C.
* @param (out) C         Buffer object storing matrix \b C.
* @param (in) offC       Offset of the first element of the matrix \b C in the
*                       buffer object. Counted in elements.
* @param (in) ldc        Leading dimension of matrix \b C. It cannot be less
*                       than \b N.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasInvalidValue if either \b offA, \b offB or \b offC exceeds
*        the size of the respective buffer object;
*   - \b clblasInvalidValue if \b transAB is set to \ref clblasConjTrans.
*   - the same error codes as the clblasSsyr2k() function otherwise.
*
* @ingroup SYR2K
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasCsyr2kNative(JNIEnv *env, jclass cls, jint order, jint uplo, jint transAB, jlong N, jlong K, jfloatArray alpha, jobject A, jlong offA, jlong lda, jobject B, jlong offB, jlong ldb, jfloatArray beta, jobject C, jlong offC, jlong ldc, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // transAB is primitive
    // N is primitive
    // K is primitive
    if (alpha == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'alpha' is null for clblasCsyr2k");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasCsyr2k");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // lda is primitive
    if (B == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasCsyr2k");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offB is primitive
    // ldb is primitive
    if (beta == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'beta' is null for clblasCsyr2k");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (C == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'C' is null for clblasCsyr2k");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offC is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasCsyr2k");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasCsyr2k(order=%d, uplo=%d, transAB=%d, N=%ld, K=%ld, alpha=%p, A=%p, offA=%ld, lda=%ld, B=%p, offB=%ld, ldb=%ld, beta=%p, C=%p, offC=%ld, ldc=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, transAB, N, K, alpha, A, offA, lda, B, offB, ldb, beta, C, offC, ldc, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    clblasTranspose transAB_native;
    size_t N_native = 0;
    size_t K_native = 0;
    FloatComplex alpha_native;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    size_t lda_native = 0;
    cl_mem B_native = nullptr;
    size_t offB_native = 0;
    size_t ldb_native = 0;
    FloatComplex beta_native;
    cl_mem C_native = nullptr;
    size_t offC_native = 0;
    size_t ldc_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    transAB_native = (clblasTranspose)transAB;
    N_native = (size_t)N;
    K_native = (size_t)K;
    if (!init_FloatComplex(env, alpha, alpha_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    lda_native = (size_t)lda;
    if (!init_cl_mem(env, B, B_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offB_native = (size_t)offB;
    ldb_native = (size_t)ldb;
    if (!init_FloatComplex(env, beta, beta_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_mem(env, C, C_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offC_native = (size_t)offC;
    ldc_native = (size_t)ldc;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasCsyr2k(order_native, uplo_native, transAB_native, N_native, K_native, alpha_native, A_native, offA_native, lda_native, B_native, offB_native, ldb_native, beta_native, C_native, offC_native, ldc_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // transAB is primitive
    // N is primitive
    // K is primitive
    if (!release_FloatComplex(env, alpha_native, alpha, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // A is a read-only native pointer
    // offA is primitive
    // lda is primitive
    // B is a read-only native pointer
    // offB is primitive
    // ldb is primitive
    if (!release_FloatComplex(env, beta_native, beta, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // C is a read-only native pointer
    // offC is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* Rank-2k update of a symmetric matrix with complex double elements.
*        Extended version.
*
* Rank-k updates:
*   - \f$ C \leftarrow \alpha A B^T + \alpha B A^T + \beta C \f$
*   - \f$ C \leftarrow \alpha A^T B + \alpha B^T A \beta C \f$
*
* where \b C is a symmetric matrix.
*
* @param (in) order      Row/column order.
* @param (in) uplo       The triangle in matrix \b C being referenced.
* @param (in) transAB    How matrices \b A and \b B is to be transposed.
* @param (in) N          Number of rows and columns in matrix \b C.
* @param (in) K          Number of columns of the matrices \b A and \b B if they
*                       are not transposed, and number of rows otherwise.
* @param (in) alpha      The factor of matrices \b A and \b B.
* @param (in) A          Buffer object storing matrix \b A.
* @param (in) offA       Offset of the first element of the matrix \b A in the
*                       buffer object. Counted in elements.
* @param (in) lda        Leading dimension of matrix \b A. For detailed
*                       description, see clblasSsyr2k().
* @param (in) B          Buffer object storing matrix \b B.
* @param (in) offB       Offset of the first element of the matrix \b B in the
*                       buffer object. Counted in elements.
* @param (in) ldb        Leading dimension of matrix \b B. For detailed
*                       description, see clblasSsyr2k().
* @param (in) beta       The factor of matrix \b C.
* @param (out) C         Buffer object storing matrix \b C.
* @param (in) offC       Offset of the first element of the matrix \b C in the
*                       buffer object. Counted in elements.
* @param (in) ldc        Leading dimension of matrix \b C. It cannot be less
*                       than \b N.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasInvalidDevice if a target device does not support floating
*        point arithmetic with double precision;
*   - \b clblasInvalidValue if either \b offA, \b offB or \b offC exceeds
*        the size of the respective buffer object;
*   - \b clblasInvalidValue if \b transAB is set to \ref clblasConjTrans.
*   - the same error codes as the clblasSsyr2k() function otherwise.
*
* @ingroup SYR2K
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasZsyr2kNative(JNIEnv *env, jclass cls, jint order, jint uplo, jint transAB, jlong N, jlong K, jdoubleArray alpha, jobject A, jlong offA, jlong lda, jobject B, jlong offB, jlong ldb, jdoubleArray beta, jobject C, jlong offC, jlong ldc, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // transAB is primitive
    // N is primitive
    // K is primitive
    if (alpha == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'alpha' is null for clblasZsyr2k");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasZsyr2k");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // lda is primitive
    if (B == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasZsyr2k");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offB is primitive
    // ldb is primitive
    if (beta == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'beta' is null for clblasZsyr2k");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (C == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'C' is null for clblasZsyr2k");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offC is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasZsyr2k");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasZsyr2k(order=%d, uplo=%d, transAB=%d, N=%ld, K=%ld, alpha=%p, A=%p, offA=%ld, lda=%ld, B=%p, offB=%ld, ldb=%ld, beta=%p, C=%p, offC=%ld, ldc=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, transAB, N, K, alpha, A, offA, lda, B, offB, ldb, beta, C, offC, ldc, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    clblasTranspose transAB_native;
    size_t N_native = 0;
    size_t K_native = 0;
    DoubleComplex alpha_native;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    size_t lda_native = 0;
    cl_mem B_native = nullptr;
    size_t offB_native = 0;
    size_t ldb_native = 0;
    DoubleComplex beta_native;
    cl_mem C_native = nullptr;
    size_t offC_native = 0;
    size_t ldc_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    transAB_native = (clblasTranspose)transAB;
    N_native = (size_t)N;
    K_native = (size_t)K;
    if (!init_DoubleComplex(env, alpha, alpha_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    lda_native = (size_t)lda;
    if (!init_cl_mem(env, B, B_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offB_native = (size_t)offB;
    ldb_native = (size_t)ldb;
    if (!init_DoubleComplex(env, beta, beta_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_mem(env, C, C_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offC_native = (size_t)offC;
    ldc_native = (size_t)ldc;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasZsyr2k(order_native, uplo_native, transAB_native, N_native, K_native, alpha_native, A_native, offA_native, lda_native, B_native, offB_native, ldb_native, beta_native, C_native, offC_native, ldc_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // transAB is primitive
    // N is primitive
    // K is primitive
    if (!release_DoubleComplex(env, alpha_native, alpha, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // A is a read-only native pointer
    // offA is primitive
    // lda is primitive
    // B is a read-only native pointer
    // offB is primitive
    // ldb is primitive
    if (!release_DoubleComplex(env, beta_native, beta, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // C is a read-only native pointer
    // offC is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**@}*/
/**
* <pre>
* @defgroup SYMM SYMM  - Symmetric matrix-matrix multiply
* @ingroup BLAS3
* </pre>
*/
/**@{*/
/**
* <pre>
* Matrix-matrix product of symmetric rectangular matrices with float
* elements.
*
* Matrix-matrix products:
*   - \f$ C \leftarrow \alpha A B + \beta C \f$
*   - \f$ C \leftarrow \alpha B A + \beta C \f$
*
* @param (in) order     Row/column order.
* @param (in) side		The side of triangular matrix.
* @param (in) uplo		The triangle in matrix being referenced.
* @param (in) M         Number of rows in matrices \b B and \b C.
* @param (in) N         Number of columns in matrices \b B and \b C.
* @param (in) alpha     The factor of matrix \b A.
* @param (in) A         Buffer object storing matrix \b A.
* @param (in) offa      Offset of the first element of the matrix \b A in the
*                      buffer object. Counted in elements.
* @param (in) lda       Leading dimension of matrix \b A. It cannot be less
*                      than \b M when the \b side parameter is set to
*                      \b clblasLeft,\n or less than \b N when the
*                      parameter is set to \b clblasRight.
* @param (in) B         Buffer object storing matrix \b B.
* @param (in) offb      Offset of the first element of the matrix \b B in the
*                      buffer object. Counted in elements.
* @param (in) ldb       Leading dimension of matrix \b B. It cannot be less
*                      than \b N when the \b order parameter is set to
*                      \b clblasRowMajor,\n or less than \b M
*                      when it is set to \b clblasColumnMajor.
* @param (in) beta      The factor of matrix \b C.
* @param (out) C        Buffer object storing matrix \b C.
* @param (in) offc      Offset of the first element of the matrix \b C in the
*                      buffer object. Counted in elements.
* @param (in) ldc       Leading dimension of matrix \b C. It cannot be less
*                      than \b N when the \b order parameter is set to
*                      \b clblasRowMajor,\n or less than \b M when
*                      it is set to \b clblasColumnMajorOrder.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events			  Event objects per each command queue that identify
*								  a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasNotInitialized if clblasSetup() was not called;
*   - \b clblasInvalidValue if invalid parameters are passed:
*     - \b M or \b N is zero, or
*     - any of the leading dimensions is invalid;
*     - the matrix sizes lead to accessing outsize of any of the buffers;
*   - \b clblasInvalidMemObject if A, B, or C object is invalid,
*     or an image object rather than the buffer one;
*   - \b clblasOutOfResources if you use image-based function implementation
*     and no suitable scratch image available;
*   - \b clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   - \b clblasInvalidCommandQueue if the passed command queue is invalid;
*   - \b clblasInvalidContext if a context a passed command queue belongs to
*     was released;
*   - \b clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   - \b clblasCompilerNotAvailable if a compiler is not available;
*   - \b clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
* @ingroup SYMM
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasSsymmNative(JNIEnv *env, jclass cls, jint order, jint side, jint uplo, jlong M, jlong N, jfloat alpha, jobject A, jlong offa, jlong lda, jobject B, jlong offb, jlong ldb, jfloat beta, jobject C, jlong offc, jlong ldc, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // side is primitive
    // uplo is primitive
    // M is primitive
    // N is primitive
    // alpha is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasSsymm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    if (B == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasSsymm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offb is primitive
    // ldb is primitive
    // beta is primitive
    if (C == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'C' is null for clblasSsymm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offc is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasSsymm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasSsymm(order=%d, side=%d, uplo=%d, M=%ld, N=%ld, alpha=%f, A=%p, offa=%ld, lda=%ld, B=%p, offb=%ld, ldb=%ld, beta=%f, C=%p, offc=%ld, ldc=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, side, uplo, M, N, alpha, A, offa, lda, B, offb, ldb, beta, C, offc, ldc, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasSide side_native;
    clblasUplo uplo_native;
    size_t M_native = 0;
    size_t N_native = 0;
    cl_float alpha_native;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_mem B_native = nullptr;
    size_t offb_native = 0;
    size_t ldb_native = 0;
    cl_float beta_native;
    cl_mem C_native = nullptr;
    size_t offc_native = 0;
    size_t ldc_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    side_native = (clblasSide)side;
    uplo_native = (clblasUplo)uplo;
    M_native = (size_t)M;
    N_native = (size_t)N;
    alpha_native = (cl_float)alpha;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    if (!init_cl_mem(env, B, B_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offb_native = (size_t)offb;
    ldb_native = (size_t)ldb;
    beta_native = (cl_float)beta;
    if (!init_cl_mem(env, C, C_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offc_native = (size_t)offc;
    ldc_native = (size_t)ldc;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasSsymm(order_native, side_native, uplo_native, M_native, N_native, alpha_native, A_native, offa_native, lda_native, B_native, offb_native, ldb_native, beta_native, C_native, offc_native, ldc_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // side is primitive
    // uplo is primitive
    // M is primitive
    // N is primitive
    // alpha is primitive
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // B is a read-only native pointer
    // offb is primitive
    // ldb is primitive
    // beta is primitive
    // C is a read-only native pointer
    // offc is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* @example example_ssymm.c
* This is an example of how to use the @ref clblasSsymm function.
* </pre>
*/
/**
* <pre>
* Matrix-matrix product of symmetric rectangular matrices with double
* elements.
*
* Matrix-matrix products:
*   - \f$ C \leftarrow \alpha A B + \beta C \f$
*   - \f$ C \leftarrow \alpha B A + \beta C \f$
*
* @param (in) order     Row/column order.
* @param (in) side		The side of triangular matrix.
* @param (in) uplo		The triangle in matrix being referenced.
* @param (in) M         Number of rows in matrices \b B and \b C.
* @param (in) N         Number of columns in matrices \b B and \b C.
* @param (in) alpha     The factor of matrix \b A.
* @param (in) A         Buffer object storing matrix \b A.
* @param (in) offa      Offset of the first element of the matrix \b A in the
*                      buffer object. Counted in elements.
* @param (in) lda       Leading dimension of matrix \b A. It cannot be less
*                      than \b M when the \b side parameter is set to
*                      \b clblasLeft,\n or less than \b N when the
*                      parameter is set to \b clblasRight.
* @param (in) B         Buffer object storing matrix \b B.
* @param (in) offb      Offset of the first element of the matrix \b B in the
*                      buffer object. Counted in elements.
* @param (in) ldb       Leading dimension of matrix \b B. It cannot be less
*                      than \b N when the \b order parameter is set to
*                      \b clblasRowMajor,\n or less than \b M
*                      when it is set to \b clblasColumnMajor.
* @param (in) beta      The factor of matrix \b C.
* @param (out) C        Buffer object storing matrix \b C.
* @param (in) offc      Offset of the first element of the matrix \b C in the
*                      buffer object. Counted in elements.
* @param (in) ldc       Leading dimension of matrix \b C. It cannot be less
*                      than \b N when the \b order parameter is set to
*                      \b clblasRowMajor,\n or less than \b M when
*                      it is set to \b clblasColumnMajorOrder.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events			  Event objects per each command queue that identify
*								  a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasInvalidDevice if a target device does not support floating
*     point arithmetic with double precision;
*   - the same error codes as the clblasSsymm() function otherwise.
*
* @ingroup SYMM
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasDsymmNative(JNIEnv *env, jclass cls, jint order, jint side, jint uplo, jlong M, jlong N, jdouble alpha, jobject A, jlong offa, jlong lda, jobject B, jlong offb, jlong ldb, jdouble beta, jobject C, jlong offc, jlong ldc, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // side is primitive
    // uplo is primitive
    // M is primitive
    // N is primitive
    // alpha is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasDsymm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    if (B == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasDsymm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offb is primitive
    // ldb is primitive
    // beta is primitive
    if (C == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'C' is null for clblasDsymm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offc is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasDsymm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasDsymm(order=%d, side=%d, uplo=%d, M=%ld, N=%ld, alpha=%lf, A=%p, offa=%ld, lda=%ld, B=%p, offb=%ld, ldb=%ld, beta=%lf, C=%p, offc=%ld, ldc=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, side, uplo, M, N, alpha, A, offa, lda, B, offb, ldb, beta, C, offc, ldc, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasSide side_native;
    clblasUplo uplo_native;
    size_t M_native = 0;
    size_t N_native = 0;
    cl_double alpha_native;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_mem B_native = nullptr;
    size_t offb_native = 0;
    size_t ldb_native = 0;
    cl_double beta_native;
    cl_mem C_native = nullptr;
    size_t offc_native = 0;
    size_t ldc_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    side_native = (clblasSide)side;
    uplo_native = (clblasUplo)uplo;
    M_native = (size_t)M;
    N_native = (size_t)N;
    alpha_native = (cl_double)alpha;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    if (!init_cl_mem(env, B, B_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offb_native = (size_t)offb;
    ldb_native = (size_t)ldb;
    beta_native = (cl_double)beta;
    if (!init_cl_mem(env, C, C_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offc_native = (size_t)offc;
    ldc_native = (size_t)ldc;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasDsymm(order_native, side_native, uplo_native, M_native, N_native, alpha_native, A_native, offa_native, lda_native, B_native, offb_native, ldb_native, beta_native, C_native, offc_native, ldc_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // side is primitive
    // uplo is primitive
    // M is primitive
    // N is primitive
    // alpha is primitive
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // B is a read-only native pointer
    // offb is primitive
    // ldb is primitive
    // beta is primitive
    // C is a read-only native pointer
    // offc is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* Matrix-matrix product of symmetric rectangular matrices with
* float-complex elements.
*
* Matrix-matrix products:
*   - \f$ C \leftarrow \alpha A B + \beta C \f$
*   - \f$ C \leftarrow \alpha B A + \beta C \f$
*
* @param (in) order     Row/column order.
* @param (in) side		The side of triangular matrix.
* @param (in) uplo		The triangle in matrix being referenced.
* @param (in) M         Number of rows in matrices \b B and \b C.
* @param (in) N         Number of columns in matrices \b B and \b C.
* @param (in) alpha     The factor of matrix \b A.
* @param (in) A         Buffer object storing matrix \b A.
* @param (in) offa      Offset of the first element of the matrix \b A in the
*                      buffer object. Counted in elements.
* @param (in) lda       Leading dimension of matrix \b A. It cannot be less
*                      than \b M when the \b side parameter is set to
*                      \b clblasLeft,\n or less than \b N when the
*                      parameter is set to \b clblasRight.
* @param (in) B         Buffer object storing matrix \b B.
* @param (in) offb      Offset of the first element of the matrix \b B in the
*                      buffer object. Counted in elements.
* @param (in) ldb       Leading dimension of matrix \b B. It cannot be less
*                      than \b N when the \b order parameter is set to
*                      \b clblasRowMajor,\n or less than \b M
*                      when it is set to \b clblasColumnMajor.
* @param (in) beta      The factor of matrix \b C.
* @param (out) C        Buffer object storing matrix \b C.
* @param (in) offc      Offset of the first element of the matrix \b C in the
*                      buffer object. Counted in elements.
* @param (in) ldc       Leading dimension of matrix \b C. It cannot be less
*                      than \b N when the \b order parameter is set to
*                      \b clblasRowMajor,\n or less than \b M when
*                      it is set to \b clblasColumnMajorOrder.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events			  Event objects per each command queue that identify
*								  a particular kernel execution instance.
*
* @return The same result as the clblasSsymm() function.
*
* @ingroup SYMM
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasCsymmNative(JNIEnv *env, jclass cls, jint order, jint side, jint uplo, jlong M, jlong N, jfloatArray alpha, jobject A, jlong offa, jlong lda, jobject B, jlong offb, jlong ldb, jfloatArray beta, jobject C, jlong offc, jlong ldc, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // side is primitive
    // uplo is primitive
    // M is primitive
    // N is primitive
    if (alpha == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'alpha' is null for clblasCsymm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasCsymm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    if (B == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasCsymm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offb is primitive
    // ldb is primitive
    if (beta == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'beta' is null for clblasCsymm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (C == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'C' is null for clblasCsymm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offc is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasCsymm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasCsymm(order=%d, side=%d, uplo=%d, M=%ld, N=%ld, alpha=%p, A=%p, offa=%ld, lda=%ld, B=%p, offb=%ld, ldb=%ld, beta=%p, C=%p, offc=%ld, ldc=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, side, uplo, M, N, alpha, A, offa, lda, B, offb, ldb, beta, C, offc, ldc, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasSide side_native;
    clblasUplo uplo_native;
    size_t M_native = 0;
    size_t N_native = 0;
    cl_float2 alpha_native;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_mem B_native = nullptr;
    size_t offb_native = 0;
    size_t ldb_native = 0;
    cl_float2 beta_native;
    cl_mem C_native = nullptr;
    size_t offc_native = 0;
    size_t ldc_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    side_native = (clblasSide)side;
    uplo_native = (clblasUplo)uplo;
    M_native = (size_t)M;
    N_native = (size_t)N;
    if (!init_cl_float2(env, alpha, alpha_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    if (!init_cl_mem(env, B, B_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offb_native = (size_t)offb;
    ldb_native = (size_t)ldb;
    if (!init_cl_float2(env, beta, beta_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_mem(env, C, C_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offc_native = (size_t)offc;
    ldc_native = (size_t)ldc;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasCsymm(order_native, side_native, uplo_native, M_native, N_native, alpha_native, A_native, offa_native, lda_native, B_native, offb_native, ldb_native, beta_native, C_native, offc_native, ldc_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // side is primitive
    // uplo is primitive
    // M is primitive
    // N is primitive
    if (!release_cl_float2(env, alpha_native, alpha, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // B is a read-only native pointer
    // offb is primitive
    // ldb is primitive
    if (!release_cl_float2(env, beta_native, beta, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // C is a read-only native pointer
    // offc is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* Matrix-matrix product of symmetric rectangular matrices with
* double-complex elements.
*
* Matrix-matrix products:
*   - \f$ C \leftarrow \alpha A B + \beta C \f$
*   - \f$ C \leftarrow \alpha B A + \beta C \f$
*
* @param (in) order     Row/column order.
* @param (in) side		The side of triangular matrix.
* @param (in) uplo		The triangle in matrix being referenced.
* @param (in) M         Number of rows in matrices \b B and \b C.
* @param (in) N         Number of columns in matrices \b B and \b C.
* @param (in) alpha     The factor of matrix \b A.
* @param (in) A         Buffer object storing matrix \b A.
* @param (in) offa      Offset of the first element of the matrix \b A in the
*                      buffer object. Counted in elements.
* @param (in) lda       Leading dimension of matrix \b A. It cannot be less
*                      than \b M when the \b side parameter is set to
*                      \b clblasLeft,\n or less than \b N when the
*                      parameter is set to \b clblasRight.
* @param (in) B         Buffer object storing matrix \b B.
* @param (in) offb      Offset of the first element of the matrix \b B in the
*                      buffer object. Counted in elements.
* @param (in) ldb       Leading dimension of matrix \b B. It cannot be less
*                      than \b N when the \b order parameter is set to
*                      \b clblasRowMajor,\n or less than \b M
*                      when it is set to \b clblasColumnMajor.
* @param (in) beta      The factor of matrix \b C.
* @param (out) C        Buffer object storing matrix \b C.
* @param (in) offc      Offset of the first element of the matrix \b C in the
*                      buffer object. Counted in elements.
* @param (in) ldc       Leading dimension of matrix \b C. It cannot be less
*                      than \b N when the \b order parameter is set to
*                      \b clblasRowMajor,\n or less than \b M when
*                      it is set to \b clblasColumnMajorOrder.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events			  Event objects per each command queue that identify
*								  a particular kernel execution instance.
*
* @return The same result as the clblasDsymm() function.
*
* @ingroup SYMM
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasZsymmNative(JNIEnv *env, jclass cls, jint order, jint side, jint uplo, jlong M, jlong N, jdoubleArray alpha, jobject A, jlong offa, jlong lda, jobject B, jlong offb, jlong ldb, jdoubleArray beta, jobject C, jlong offc, jlong ldc, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // side is primitive
    // uplo is primitive
    // M is primitive
    // N is primitive
    if (alpha == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'alpha' is null for clblasZsymm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasZsymm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    if (B == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasZsymm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offb is primitive
    // ldb is primitive
    if (beta == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'beta' is null for clblasZsymm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (C == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'C' is null for clblasZsymm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offc is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasZsymm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasZsymm(order=%d, side=%d, uplo=%d, M=%ld, N=%ld, alpha=%p, A=%p, offa=%ld, lda=%ld, B=%p, offb=%ld, ldb=%ld, beta=%p, C=%p, offc=%ld, ldc=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, side, uplo, M, N, alpha, A, offa, lda, B, offb, ldb, beta, C, offc, ldc, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasSide side_native;
    clblasUplo uplo_native;
    size_t M_native = 0;
    size_t N_native = 0;
    cl_double2 alpha_native;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_mem B_native = nullptr;
    size_t offb_native = 0;
    size_t ldb_native = 0;
    cl_double2 beta_native;
    cl_mem C_native = nullptr;
    size_t offc_native = 0;
    size_t ldc_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    side_native = (clblasSide)side;
    uplo_native = (clblasUplo)uplo;
    M_native = (size_t)M;
    N_native = (size_t)N;
    if (!init_cl_double2(env, alpha, alpha_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    if (!init_cl_mem(env, B, B_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offb_native = (size_t)offb;
    ldb_native = (size_t)ldb;
    if (!init_cl_double2(env, beta, beta_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_mem(env, C, C_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offc_native = (size_t)offc;
    ldc_native = (size_t)ldc;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasZsymm(order_native, side_native, uplo_native, M_native, N_native, alpha_native, A_native, offa_native, lda_native, B_native, offb_native, ldb_native, beta_native, C_native, offc_native, ldc_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // side is primitive
    // uplo is primitive
    // M is primitive
    // N is primitive
    if (!release_cl_double2(env, alpha_native, alpha, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // B is a read-only native pointer
    // offb is primitive
    // ldb is primitive
    if (!release_cl_double2(env, beta_native, beta, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // C is a read-only native pointer
    // offc is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**@}*/
/**
* <pre>
* @defgroup HEMM HEMM  - Hermitian matrix-matrix multiplication
* @ingroup BLAS3
* </pre>
*/
/**@{*/
/**
* <pre>
* Matrix-matrix product of hermitian rectangular matrices with
* float-complex elements.
*
* Matrix-matrix products:
*   - \f$ C \leftarrow \alpha A B + \beta C \f$
*   - \f$ C \leftarrow \alpha B A + \beta C \f$
*
* @param (in) order     Row/column order.
* @param (in) side		The side of triangular matrix.
* @param (in) uplo		The triangle in matrix being referenced.
* @param (in) M         Number of rows in matrices \b B and \b C.
* @param (in) N         Number of columns in matrices \b B and \b C.
* @param (in) alpha     The factor of matrix \b A.
* @param (in) A         Buffer object storing matrix \b A.
* @param (in) offa      Offset of the first element of the matrix \b A in the
*                      buffer object. Counted in elements.
* @param (in) lda       Leading dimension of matrix \b A. It cannot be less
*                      than \b M when the \b side parameter is set to
*                      \b clblasLeft,\n or less than \b N when the
*                      parameter is set to \b clblasRight.
* @param (in) B         Buffer object storing matrix \b B.
* @param (in) offb      Offset of the first element of the matrix \b B in the
*                      buffer object. Counted in elements.
* @param (in) ldb       Leading dimension of matrix \b B. It cannot be less
*                      than \b N when the \b order parameter is set to
*                      \b clblasRowMajor,\n or less than \b M
*                      when it is set to \b clblasColumnMajor.
* @param (in) beta      The factor of matrix \b C.
* @param (out) C        Buffer object storing matrix \b C.
* @param (in) offc      Offset of the first element of the matrix \b C in the
*                      buffer object. Counted in elements.
* @param (in) ldc       Leading dimension of matrix \b C. It cannot be less
*                      than \b N when the \b order parameter is set to
*                      \b clblasRowMajor,\n or less than \b M when
*                      it is set to \b clblasColumnMajorOrder.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasNotInitialized if clblasSetup() was not called;
*   - \b clblasInvalidValue if invalid parameters are passed:
*     - \b M or \b N is zero, or
*     - any of the leading dimensions is invalid;
*     - the matrix sizes lead to accessing outsize of any of the buffers;
*   - \b clblasInvalidMemObject if A, B, or C object is invalid,
*     or an image object rather than the buffer one;
*   - \b clblasOutOfResources if you use image-based function implementation
*     and no suitable scratch image available;
*   - \b clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   - \b clblasInvalidCommandQueue if the passed command queue is invalid;
*   - \b clblasInvalidContext if a context a passed command queue belongs to
*     was released;
*   - \b clblasInvalidOperation if kernel compilation relating to a previous
*     call has not completed for any of the target devices;
*   - \b clblasCompilerNotAvailable if a compiler is not available;
*   - \b clblasBuildProgramFailure if there is a failure to build a program
*     executable.
*
* @ingroup HEMM
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasChemmNative(JNIEnv *env, jclass cls, jint order, jint side, jint uplo, jlong M, jlong N, jfloatArray alpha, jobject A, jlong offa, jlong lda, jobject B, jlong offb, jlong ldb, jfloatArray beta, jobject C, jlong offc, jlong ldc, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // side is primitive
    // uplo is primitive
    // M is primitive
    // N is primitive
    if (alpha == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'alpha' is null for clblasChemm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasChemm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    if (B == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasChemm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offb is primitive
    // ldb is primitive
    if (beta == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'beta' is null for clblasChemm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (C == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'C' is null for clblasChemm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offc is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasChemm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasChemm(order=%d, side=%d, uplo=%d, M=%ld, N=%ld, alpha=%p, A=%p, offa=%ld, lda=%ld, B=%p, offb=%ld, ldb=%ld, beta=%p, C=%p, offc=%ld, ldc=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, side, uplo, M, N, alpha, A, offa, lda, B, offb, ldb, beta, C, offc, ldc, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasSide side_native;
    clblasUplo uplo_native;
    size_t M_native = 0;
    size_t N_native = 0;
    cl_float2 alpha_native;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_mem B_native = nullptr;
    size_t offb_native = 0;
    size_t ldb_native = 0;
    cl_float2 beta_native;
    cl_mem C_native = nullptr;
    size_t offc_native = 0;
    size_t ldc_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    side_native = (clblasSide)side;
    uplo_native = (clblasUplo)uplo;
    M_native = (size_t)M;
    N_native = (size_t)N;
    if (!init_cl_float2(env, alpha, alpha_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    if (!init_cl_mem(env, B, B_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offb_native = (size_t)offb;
    ldb_native = (size_t)ldb;
    if (!init_cl_float2(env, beta, beta_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_mem(env, C, C_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offc_native = (size_t)offc;
    ldc_native = (size_t)ldc;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasChemm(order_native, side_native, uplo_native, M_native, N_native, alpha_native, A_native, offa_native, lda_native, B_native, offb_native, ldb_native, beta_native, C_native, offc_native, ldc_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // side is primitive
    // uplo is primitive
    // M is primitive
    // N is primitive
    if (!release_cl_float2(env, alpha_native, alpha, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // B is a read-only native pointer
    // offb is primitive
    // ldb is primitive
    if (!release_cl_float2(env, beta_native, beta, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // C is a read-only native pointer
    // offc is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* @example example_chemm.cpp
* This is an example of how to use the @ref clblasChemm function.
* </pre>
*/
/**
* <pre>
* Matrix-matrix product of hermitian rectangular matrices with
* double-complex elements.
*
* Matrix-matrix products:
*   - \f$ C \leftarrow \alpha A B + \beta C \f$
*   - \f$ C \leftarrow \alpha B A + \beta C \f$
*
* @param (in) order     Row/column order.
* @param (in) side		The side of triangular matrix.
* @param (in) uplo		The triangle in matrix being referenced.
* @param (in) M         Number of rows in matrices \b B and \b C.
* @param (in) N         Number of columns in matrices \b B and \b C.
* @param (in) alpha     The factor of matrix \b A.
* @param (in) A         Buffer object storing matrix \b A.
* @param (in) offa      Offset of the first element of the matrix \b A in the
*                      buffer object. Counted in elements.
* @param (in) lda       Leading dimension of matrix \b A. It cannot be less
*                      than \b M when the \b side parameter is set to
*                      \b clblasLeft,\n or less than \b N when the
*                      parameter is set to \b clblasRight.
* @param (in) B         Buffer object storing matrix \b B.
* @param (in) offb      Offset of the first element of the matrix \b B in the
*                      buffer object. Counted in elements.
* @param (in) ldb       Leading dimension of matrix \b B. It cannot be less
*                      than \b N when the \b order parameter is set to
*                      \b clblasRowMajor,\n or less than \b M
*                      when it is set to \b clblasColumnMajor.
* @param (in) beta      The factor of matrix \b C.
* @param (out) C        Buffer object storing matrix \b C.
* @param (in) offc      Offset of the first element of the matrix \b C in the
*                      buffer object. Counted in elements.
* @param (in) ldc       Leading dimension of matrix \b C. It cannot be less
*                      than \b N when the \b order parameter is set to
*                      \b clblasRowMajor,\n or less than \b M when
*                      it is set to \b clblasColumnMajorOrder.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasInvalidDevice if a target device does not support floating
*     point arithmetic with double precision;
*   - the same error codes as the clblasChemm() function otherwise.
*
* @ingroup HEMM
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasZhemmNative(JNIEnv *env, jclass cls, jint order, jint side, jint uplo, jlong M, jlong N, jdoubleArray alpha, jobject A, jlong offa, jlong lda, jobject B, jlong offb, jlong ldb, jdoubleArray beta, jobject C, jlong offc, jlong ldc, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // side is primitive
    // uplo is primitive
    // M is primitive
    // N is primitive
    if (alpha == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'alpha' is null for clblasZhemm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasZhemm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    if (B == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasZhemm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offb is primitive
    // ldb is primitive
    if (beta == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'beta' is null for clblasZhemm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (C == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'C' is null for clblasZhemm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offc is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasZhemm");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasZhemm(order=%d, side=%d, uplo=%d, M=%ld, N=%ld, alpha=%p, A=%p, offa=%ld, lda=%ld, B=%p, offb=%ld, ldb=%ld, beta=%p, C=%p, offc=%ld, ldc=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, side, uplo, M, N, alpha, A, offa, lda, B, offb, ldb, beta, C, offc, ldc, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasSide side_native;
    clblasUplo uplo_native;
    size_t M_native = 0;
    size_t N_native = 0;
    cl_double2 alpha_native;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_mem B_native = nullptr;
    size_t offb_native = 0;
    size_t ldb_native = 0;
    cl_double2 beta_native;
    cl_mem C_native = nullptr;
    size_t offc_native = 0;
    size_t ldc_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    side_native = (clblasSide)side;
    uplo_native = (clblasUplo)uplo;
    M_native = (size_t)M;
    N_native = (size_t)N;
    if (!init_cl_double2(env, alpha, alpha_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    if (!init_cl_mem(env, B, B_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offb_native = (size_t)offb;
    ldb_native = (size_t)ldb;
    if (!init_cl_double2(env, beta, beta_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_mem(env, C, C_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offc_native = (size_t)offc;
    ldc_native = (size_t)ldc;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasZhemm(order_native, side_native, uplo_native, M_native, N_native, alpha_native, A_native, offa_native, lda_native, B_native, offb_native, ldb_native, beta_native, C_native, offc_native, ldc_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // side is primitive
    // uplo is primitive
    // M is primitive
    // N is primitive
    if (!release_cl_double2(env, alpha_native, alpha, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // B is a read-only native pointer
    // offb is primitive
    // ldb is primitive
    if (!release_cl_double2(env, beta_native, beta, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // C is a read-only native pointer
    // offc is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**@}*/
/**
* <pre>
* @defgroup HERK HERK  - Hermitian rank-k update to a matrix
* @ingroup BLAS3
* </pre>
*/
/**@{*/
/**
* <pre>
* Rank-k update of a hermitian matrix with float-complex elements.
*
* Rank-k updates:
*   - \f$ C \leftarrow \alpha A A^H + \beta C \f$
*   - \f$ C \leftarrow \alpha A^H A + \beta C \f$
*
* where \b C is a hermitian matrix.
*
* @param (in) order      Row/column order.
* @param (in) uplo       The triangle in matrix \b C being referenced.
* @param (in) transA     How matrix \b A is to be transposed.
* @param (in) N          Number of rows and columns in matrix \b C.
* @param (in) K          Number of columns of the matrix \b A if it is not
*                       transposed, and number of rows otherwise.
* @param (in) alpha      The factor of matrix \b A.
* @param (in) A          Buffer object storing the matrix \b A.
* @param (in) offa       Offset in number of elements for the first element in matrix \b A.
* @param (in) lda        Leading dimension of matrix \b A. It cannot be
*                       less than \b K if \b A is
*                       in the row-major format, and less than \b N
*                       otherwise.
* @param (in) beta       The factor of the matrix \b C.
* @param (out) C         Buffer object storing matrix \b C.
* @param (in) offc       Offset in number of elements for the first element in matrix \b C.
* @param (in) ldc        Leading dimension of matric \b C. It cannot be less
*                       than \b N.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasNotInitialized if clblasSetup() was not called;
*   - \b clblasInvalidValue if invalid parameters are passed:
*     - either \b N or \b K is zero, or
*     - any of the leading dimensions is invalid;
*     - the matrix sizes lead to accessing outsize of any of the buffers;
*   - \b clblasInvalidMemObject if either \b A or \b C object is
*     invalid, or an image object rather than the buffer one;
*   - \b clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   - \b clblasInvalidCommandQueue if the passed command queue is invalid;
*   - \b clblasInvalidContext if a context a passed command queue belongs to
*     was released.
*
* @ingroup HERK
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasCherkNative(JNIEnv *env, jclass cls, jint order, jint uplo, jint transA, jlong N, jlong K, jfloat alpha, jobject A, jlong offa, jlong lda, jfloat beta, jobject C, jlong offc, jlong ldc, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // transA is primitive
    // N is primitive
    // K is primitive
    // alpha is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasCherk");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    // beta is primitive
    if (C == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'C' is null for clblasCherk");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offc is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasCherk");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasCherk(order=%d, uplo=%d, transA=%d, N=%ld, K=%ld, alpha=%f, A=%p, offa=%ld, lda=%ld, beta=%f, C=%p, offc=%ld, ldc=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, transA, N, K, alpha, A, offa, lda, beta, C, offc, ldc, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    clblasTranspose transA_native;
    size_t N_native = 0;
    size_t K_native = 0;
    float alpha_native = 0.0f;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    float beta_native = 0.0f;
    cl_mem C_native = nullptr;
    size_t offc_native = 0;
    size_t ldc_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    transA_native = (clblasTranspose)transA;
    N_native = (size_t)N;
    K_native = (size_t)K;
    alpha_native = (float)alpha;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    beta_native = (float)beta;
    if (!init_cl_mem(env, C, C_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offc_native = (size_t)offc;
    ldc_native = (size_t)ldc;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasCherk(order_native, uplo_native, transA_native, N_native, K_native, alpha_native, A_native, offa_native, lda_native, beta_native, C_native, offc_native, ldc_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // transA is primitive
    // N is primitive
    // K is primitive
    // alpha is primitive
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // beta is primitive
    // C is a read-only native pointer
    // offc is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* @example example_cherk.cpp
* This is an example of how to use the @ref clblasCherk function.
* </pre>
*/
/**
* <pre>
* Rank-k update of a hermitian matrix with double-complex elements.
*
* Rank-k updates:
*   - \f$ C \leftarrow \alpha A A^H + \beta C \f$
*   - \f$ C \leftarrow \alpha A^H A + \beta C \f$
*
* where \b C is a hermitian matrix.
*
* @param (in) order      Row/column order.
* @param (in) uplo       The triangle in matrix \b C being referenced.
* @param (in) transA     How matrix \b A is to be transposed.
* @param (in) N          Number of rows and columns in matrix \b C.
* @param (in) K          Number of columns of the matrix \b A if it is not
*                       transposed, and number of rows otherwise.
* @param (in) alpha      The factor of matrix \b A.
* @param (in) A          Buffer object storing the matrix \b A.
* @param (in) offa       Offset in number of elements for the first element in matrix \b A.
* @param (in) lda        Leading dimension of matrix \b A. It cannot be
*                       less than \b K if \b A is
*                       in the row-major format, and less than \b N
*                       otherwise.
* @param (in) beta       The factor of the matrix \b C.
* @param (out) C         Buffer object storing matrix \b C.
* @param (in) offc       Offset in number of elements for the first element in matrix \b C.
* @param (in) ldc        Leading dimension of matric \b C. It cannot be less
*                       than \b N.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasInvalidDevice if a target device does not support floating
*     point arithmetic with double precision;
*   - the same error codes as the clblasCherk() function otherwise.
*
* @ingroup HERK
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasZherkNative(JNIEnv *env, jclass cls, jint order, jint uplo, jint transA, jlong N, jlong K, jdouble alpha, jobject A, jlong offa, jlong lda, jdouble beta, jobject C, jlong offc, jlong ldc, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // transA is primitive
    // N is primitive
    // K is primitive
    // alpha is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasZherk");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    // beta is primitive
    if (C == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'C' is null for clblasZherk");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offc is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasZherk");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasZherk(order=%d, uplo=%d, transA=%d, N=%ld, K=%ld, alpha=%lf, A=%p, offa=%ld, lda=%ld, beta=%lf, C=%p, offc=%ld, ldc=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, transA, N, K, alpha, A, offa, lda, beta, C, offc, ldc, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    clblasTranspose transA_native;
    size_t N_native = 0;
    size_t K_native = 0;
    double alpha_native = 0.0;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    double beta_native = 0.0;
    cl_mem C_native = nullptr;
    size_t offc_native = 0;
    size_t ldc_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    transA_native = (clblasTranspose)transA;
    N_native = (size_t)N;
    K_native = (size_t)K;
    alpha_native = (double)alpha;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    beta_native = (double)beta;
    if (!init_cl_mem(env, C, C_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offc_native = (size_t)offc;
    ldc_native = (size_t)ldc;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasZherk(order_native, uplo_native, transA_native, N_native, K_native, alpha_native, A_native, offa_native, lda_native, beta_native, C_native, offc_native, ldc_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // transA is primitive
    // N is primitive
    // K is primitive
    // alpha is primitive
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // beta is primitive
    // C is a read-only native pointer
    // offc is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**@}*/
/**
* <pre>
* @defgroup HER2K HER2K  - Hermitian rank-2k update to a matrix
* @ingroup BLAS3
* </pre>
*/
/**@{*/
/**
* <pre>
* Rank-2k update of a hermitian matrix with float-complex elements.
*
* Rank-k updates:
*   - \f$ C \leftarrow \alpha A B^H + conj( \alpha ) B A^H + \beta C \f$
*   - \f$ C \leftarrow \alpha A^H B + conj( \alpha ) B^H A + \beta C \f$
*
* where \b C is a hermitian matrix.
*
* @param (in) order      Row/column order.
* @param (in) uplo       The triangle in matrix \b C being referenced.
* @param (in) trans      How matrix \b A is to be transposed.
* @param (in) N          Number of rows and columns in matrix \b C.
* @param (in) K          Number of columns of the matrix \b A if it is not
*                       transposed, and number of rows otherwise.
* @param (in) alpha      The factor of matrix \b A.
* @param (in) A          Buffer object storing the matrix \b A.
* @param (in) offa       Offset in number of elements for the first element in matrix \b A.
* @param (in) lda        Leading dimension of matrix \b A. It cannot be
*                       less than \b K if \b A is
*                       in the row-major format, and less than \b N
*                       otherwise. Vice-versa for transpose case.
* @param (in) B          Buffer object storing the matrix \b B.
* @param (in) offb       Offset in number of elements for the first element in matrix \b B.
* @param (in) ldb        Leading dimension of matrix \b B. It cannot be
*                       less than \b K if \b B is
*                       in the row-major format, and less than \b N
*                       otherwise. Vice-versa for transpose case
* @param (in) beta       The factor of the matrix \b C.
* @param (out) C         Buffer object storing matrix \b C.
* @param (in) offc       Offset in number of elements for the first element in matrix \b C.
* @param (in) ldc        Leading dimension of matric \b C. It cannot be less
*                       than \b N.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasNotInitialized if clblasSetup() was not called;
*   - \b clblasInvalidValue if invalid parameters are passed:
*     - either \b N or \b K is zero, or
*     - any of the leading dimensions is invalid;
*     - the matrix sizes lead to accessing outsize of any of the buffers;
*   - \b clblasInvalidMemObject if either \b A , \b B or \b C object is
*     invalid, or an image object rather than the buffer one;
*   - \b clblasOutOfHostMemory if the library can't allocate memory for
*     internal structures;
*   - \b clblasInvalidCommandQueue if the passed command queue is invalid;
*   - \b clblasInvalidContext if a context a passed command queue belongs to
*     was released.
*
* @ingroup HER2K
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasCher2kNative(JNIEnv *env, jclass cls, jint order, jint uplo, jint trans, jlong N, jlong K, jfloatArray alpha, jobject A, jlong offa, jlong lda, jobject B, jlong offb, jlong ldb, jfloat beta, jobject C, jlong offc, jlong ldc, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // N is primitive
    // K is primitive
    if (alpha == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'alpha' is null for clblasCher2k");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasCher2k");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    if (B == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasCher2k");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offb is primitive
    // ldb is primitive
    // beta is primitive
    if (C == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'C' is null for clblasCher2k");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offc is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasCher2k");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasCher2k(order=%d, uplo=%d, trans=%d, N=%ld, K=%ld, alpha=%p, A=%p, offa=%ld, lda=%ld, B=%p, offb=%ld, ldb=%ld, beta=%f, C=%p, offc=%ld, ldc=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, trans, N, K, alpha, A, offa, lda, B, offb, ldb, beta, C, offc, ldc, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    clblasTranspose trans_native;
    size_t N_native = 0;
    size_t K_native = 0;
    FloatComplex alpha_native;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_mem B_native = nullptr;
    size_t offb_native = 0;
    size_t ldb_native = 0;
    cl_float beta_native;
    cl_mem C_native = nullptr;
    size_t offc_native = 0;
    size_t ldc_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    trans_native = (clblasTranspose)trans;
    N_native = (size_t)N;
    K_native = (size_t)K;
    if (!init_FloatComplex(env, alpha, alpha_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    if (!init_cl_mem(env, B, B_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offb_native = (size_t)offb;
    ldb_native = (size_t)ldb;
    beta_native = (cl_float)beta;
    if (!init_cl_mem(env, C, C_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offc_native = (size_t)offc;
    ldc_native = (size_t)ldc;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasCher2k(order_native, uplo_native, trans_native, N_native, K_native, alpha_native, A_native, offa_native, lda_native, B_native, offb_native, ldb_native, beta_native, C_native, offc_native, ldc_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // N is primitive
    // K is primitive
    if (!release_FloatComplex(env, alpha_native, alpha, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // B is a read-only native pointer
    // offb is primitive
    // ldb is primitive
    // beta is primitive
    // C is a read-only native pointer
    // offc is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* @example example_cher2k.c
* This is an example of how to use the @ref clblasCher2k function.
* </pre>
*/
/**
* <pre>
* Rank-2k update of a hermitian matrix with double-complex elements.
*
* Rank-k updates:
*   - \f$ C \leftarrow \alpha A B^H + conj( \alpha ) B A^H + \beta C \f$
*   - \f$ C \leftarrow \alpha A^H B + conj( \alpha ) B^H A + \beta C \f$
*
* where \b C is a hermitian matrix.
*
* @param (in) order      Row/column order.
* @param (in) uplo       The triangle in matrix \b C being referenced.
* @param (in) trans      How matrix \b A is to be transposed.
* @param (in) N          Number of rows and columns in matrix \b C.
* @param (in) K          Number of columns of the matrix \b A if it is not
*                       transposed, and number of rows otherwise.
* @param (in) alpha      The factor of matrix \b A.
* @param (in) A          Buffer object storing the matrix \b A.
* @param (in) offa       Offset in number of elements for the first element in matrix \b A.
* @param (in) lda        Leading dimension of matrix \b A. It cannot be
*                       less than \b K if \b A is
*                       in the row-major format, and less than \b N
*                       otherwise. Vice-versa for transpose case.
* @param (in) B          Buffer object storing the matrix \b B.
* @param (in) offb       Offset in number of elements for the first element in matrix \b B.
* @param (in) ldb        Leading dimension of matrix \b B. It cannot be
*                       less than \b K if B is
*                       in the row-major format, and less than \b N
*                       otherwise. Vice-versa for transpose case.
* @param (in) beta       The factor of the matrix \b C.
* @param (out) C         Buffer object storing matrix \b C.
* @param (in) offc       Offset in number of elements for the first element in matrix \b C.
* @param (in) ldc        Leading dimension of matric \b C. It cannot be less
*                       than \b N.
* @param (in) numCommandQueues    Number of OpenCL command queues in which the
*                                task is to be performed.
* @param (in) commandQueues       OpenCL command queues.
* @param (in) numEventsInWaitList Number of events in the event wait list.
* @param (in) eventWaitList       Event wait list.
* @param (in) events     Event objects per each command queue that identify
*                       a particular kernel execution instance.
*
* @return
*   - \b clblasSuccess on success;
*   - \b clblasInvalidDevice if a target device does not support floating
*     point arithmetic with double precision;
*   - the same error codes as the clblasCher2k() function otherwise.
*
* @ingroup HER2K
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasZher2kNative(JNIEnv *env, jclass cls, jint order, jint uplo, jint trans, jlong N, jlong K, jdoubleArray alpha, jobject A, jlong offa, jlong lda, jobject B, jlong offb, jlong ldb, jdouble beta, jobject C, jlong offc, jlong ldc, jint numCommandQueues, jobjectArray commandQueues, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // N is primitive
    // K is primitive
    if (alpha == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'alpha' is null for clblasZher2k");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasZher2k");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offa is primitive
    // lda is primitive
    if (B == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasZher2k");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offb is primitive
    // ldb is primitive
    // beta is primitive
    if (C == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'C' is null for clblasZher2k");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offc is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (commandQueues == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'commandQueues' is null for clblasZher2k");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasZher2k(order=%d, uplo=%d, trans=%d, N=%ld, K=%ld, alpha=%p, A=%p, offa=%ld, lda=%ld, B=%p, offb=%ld, ldb=%ld, beta=%lf, C=%p, offc=%ld, ldc=%ld, numCommandQueues=%d, commandQueues=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, uplo, trans, N, K, alpha, A, offa, lda, B, offb, ldb, beta, C, offc, ldc, numCommandQueues, commandQueues, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    clblasUplo uplo_native;
    clblasTranspose trans_native;
    size_t N_native = 0;
    size_t K_native = 0;
    DoubleComplex alpha_native;
    cl_mem A_native = nullptr;
    size_t offa_native = 0;
    size_t lda_native = 0;
    cl_mem B_native = nullptr;
    size_t offb_native = 0;
    size_t ldb_native = 0;
    cl_double beta_native;
    cl_mem C_native = nullptr;
    size_t offc_native = 0;
    size_t ldc_native = 0;
    cl_uint numCommandQueues_native;
    cl_command_queue* commandQueues_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    uplo_native = (clblasUplo)uplo;
    trans_native = (clblasTranspose)trans;
    N_native = (size_t)N;
    K_native = (size_t)K;
    if (!init_DoubleComplex(env, alpha, alpha_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offa_native = (size_t)offa;
    lda_native = (size_t)lda;
    if (!init_cl_mem(env, B, B_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offb_native = (size_t)offb;
    ldb_native = (size_t)ldb;
    beta_native = (cl_double)beta;
    if (!init_cl_mem(env, C, C_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offc_native = (size_t)offc;
    ldc_native = (size_t)ldc;
    numCommandQueues_native = (cl_uint)numCommandQueues;
    if (!init_cl_command_queue_list(env, commandQueues, commandQueues_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, numCommandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasZher2k(order_native, uplo_native, trans_native, N_native, K_native, alpha_native, A_native, offa_native, lda_native, B_native, offb_native, ldb_native, beta_native, C_native, offc_native, ldc_native, numCommandQueues_native, commandQueues_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // uplo is primitive
    // trans is primitive
    // N is primitive
    // K is primitive
    if (!release_DoubleComplex(env, alpha_native, alpha, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // A is a read-only native pointer
    // offa is primitive
    // lda is primitive
    // B is a read-only native pointer
    // offb is primitive
    // ldb is primitive
    // beta is primitive
    // C is a read-only native pointer
    // offc is primitive
    // ldc is primitive
    // numCommandQueues is primitive
    if (!release_cl_command_queue_list(env, commandQueues_native, commandQueues, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, numCommandQueues, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**@}*/
/**
* <pre>
* Helper function to compute leading dimension and size of a matrix
*
* @param (in) order	matrix ordering
* @param (in) rows	number of rows
* @param (in) columns	number of column
* @param (in) elemsize	element size
* @param (in) padding	additional padding on the leading dimension
* @param (out) ld	if non-NULL *ld is filled with the leading dimension
*			in elements
* @param (out) fullsize	if non-NULL *fullsize is filled with the byte size
*
* @return
*   - \b clblasSuccess for success
*   - \b clblasInvalidValue if:
*	 - \b elementsize is 0
*	 - \b row and \b colums are both equal to 0
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasMatrixSizeInfoNative(JNIEnv *env, jclass cls, jint order, jlong rows, jlong columns, jlong elemsize, jlong padding, jlongArray ld, jlongArray fullsize)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // rows is primitive
    // columns is primitive
    // elemsize is primitive
    // padding is primitive
    // ld may be NULL
    // fullsize may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasMatrixSizeInfo(order=%d, rows=%ld, columns=%ld, elemsize=%ld, padding=%ld, ld=%p, fullsize=%p)\n",
        order, rows, columns, elemsize, padding, ld, fullsize);

    // Native variable declarations
    clblasOrder order_native;
    size_t rows_native = 0;
    size_t columns_native = 0;
    size_t elemsize_native = 0;
    size_t padding_native = 0;
    size_t ld_native = 0;
    size_t fullsize_native = 0;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    rows_native = (size_t)rows;
    columns_native = (size_t)columns;
    elemsize_native = (size_t)elemsize;
    padding_native = (size_t)padding;
    // ld is set here
    // fullsize is set here

    // Native function call
    clblasStatus jniResult_native = clblasMatrixSizeInfo(order_native, rows_native, columns_native, elemsize_native, padding_native, &ld_native, &fullsize_native);

    // Write back native variable values
    // order is primitive
    // rows is primitive
    // columns is primitive
    // elemsize is primitive
    // padding is primitive
    if (!set(env, ld, 0, (jlong)ld_native)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!set(env, fullsize, 0, (jlong)fullsize_native)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* Allocates matrix on device and computes ld and size
*
* @param (in) context	OpenCL context
* @param (in) order	Row/column order.
* @param (in) rows	number of rows
* @param (in) columns	number of columns
* @param (in) elemsize	element size
* @param (in) padding	additional padding on the leading dimension
* @param (out) ld	if non-NULL *ld is filled with the leading dimension
*			in elements
* @param (out) fullsize	if non-NULL *fullsize is filled with the byte size
* @param (in) err	Error code (see \b clCreateBuffer() )
*
* @return
*   - OpenCL memory object of the allocated matrix
* </pre>
*/
JNIEXPORT jobject JNICALL Java_org_jocl_blas_CLBLAS_clblasCreateMatrixNative(JNIEnv *env, jclass cls, jobject context, jint order, jlong rows, jlong columns, jlong elemsize, jlong padding, jlongArray ld, jlongArray fullsize, jintArray err)
{
    // Null-checks for non-primitive arguments
    if (context == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'context' is null for clblasCreateMatrix");
        return nullptr;
    }
    // order is primitive
    // rows is primitive
    // columns is primitive
    // elemsize is primitive
    // padding is primitive
    // ld may be NULL
    // fullsize may be NULL
    // err may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasCreateMatrix(context=%p, order=%d, rows=%ld, columns=%ld, elemsize=%ld, padding=%ld, ld=%p, fullsize=%p, err=%p)\n",
        context, order, rows, columns, elemsize, padding, ld, fullsize, err);

    // Native variable declarations
    cl_context context_native;
    clblasOrder order_native;
    size_t rows_native = 0;
    size_t columns_native = 0;
    size_t elemsize_native = 0;
    size_t padding_native = 0;
    size_t ld_native = 0;
    size_t fullsize_native = 0;
    cl_int err_native;

    // Obtain native variable values
    if (!init_cl_context(env, context, context_native, true)) return nullptr;
    order_native = (clblasOrder)order;
    rows_native = (size_t)rows;
    columns_native = (size_t)columns;
    elemsize_native = (size_t)elemsize;
    padding_native = (size_t)padding;
    // ld is set here
    // fullsize is set here
    // err is set here

    // Native function call
    cl_mem jniResult_native = clblasCreateMatrix(context_native, order_native, rows_native, columns_native, elemsize_native, padding_native, &ld_native, &fullsize_native, &err_native);

    // Write back native variable values
    // context is a read-only native pointer
    // order is primitive
    // rows is primitive
    // columns is primitive
    // elemsize is primitive
    // padding is primitive
    if (!set(env, ld, 0, (jlong)ld_native)) return nullptr;
    if (!set(env, fullsize, 0, (jlong)fullsize_native)) return nullptr;
    if (!set(env, err, 0, (jint)err_native)) return nullptr;

    // Return the result
    return create_cl_mem(env, jniResult_native);
}

/**
* <pre>
* Allocates matrix on device with specified size and ld and computes its size
*
* @param (in) context	OpenCL context
* @param (in) order	Row/column order.
* @param (in) rows	number of rows
* @param (in) columns	number of columns
* @param (in) elemsize	element size
* @param (in) padding	additional padding on the leading dimension
* @param (out) ld	the length of the leading dimensions. It cannot
*                      be less than \b columns when the \b order parameter is set to
*                      \b clblasRowMajor,\n or less than \b rows when the
*                      parameter is set to \b clblasColumnMajor.
* @param (out) fullsize	if non-NULL *fullsize is filled with the byte size
* @param (in) err	Error code (see \b clCreateBuffer() )
*
* @return
*   - OpenCL memory object of the allocated matrix
* </pre>
*/
JNIEXPORT jobject JNICALL Java_org_jocl_blas_CLBLAS_clblasCreateMatrixWithLdNative(JNIEnv *env, jclass cls, jobject context, jint order, jlong rows, jlong columns, jlong elemsize, jlong ld, jlongArray fullsize, jintArray err)
{
    // Null-checks for non-primitive arguments
    if (context == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'context' is null for clblasCreateMatrixWithLd");
        return nullptr;
    }
    // order is primitive
    // rows is primitive
    // columns is primitive
    // elemsize is primitive
    // ld is primitive
    // fullsize may be NULL
    // err may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasCreateMatrixWithLd(context=%p, order=%d, rows=%ld, columns=%ld, elemsize=%ld, ld=%ld, fullsize=%p, err=%p)\n",
        context, order, rows, columns, elemsize, ld, fullsize, err);

    // Native variable declarations
    cl_context context_native;
    clblasOrder order_native;
    size_t rows_native = 0;
    size_t columns_native = 0;
    size_t elemsize_native = 0;
    size_t ld_native = 0;
    size_t fullsize_native = 0;
    cl_int err_native;

    // Obtain native variable values
    if (!init_cl_context(env, context, context_native, true)) return nullptr;
    order_native = (clblasOrder)order;
    rows_native = (size_t)rows;
    columns_native = (size_t)columns;
    elemsize_native = (size_t)elemsize;
    ld_native = (size_t)ld;
    // fullsize is set here
    // err is set here

    // Native function call
    cl_mem jniResult_native = clblasCreateMatrixWithLd(context_native, order_native, rows_native, columns_native, elemsize_native, ld_native, &fullsize_native, &err_native);

    // Write back native variable values
    // context is a read-only native pointer
    // order is primitive
    // rows is primitive
    // columns is primitive
    // elemsize is primitive
    // ld is primitive
    if (!set(env, fullsize, 0, (jlong)fullsize_native)) return nullptr;
    if (!set(env, err, 0, (jint)err_native)) return nullptr;

    // Return the result
    return create_cl_mem(env, jniResult_native);
}

/**
* <pre>
* Allocates matrix on device and initialize from existing similar matrix
*	  on host. See \b clblasCreateMatrixBuffer().
*
* @param (in) ld	leading dimension in elements
* @param (in) host 	base address of host matrix data
* @param (in) off_host 	host matrix offset in elements
* @param (in) ld_host 	leading dimension of host matrix in elements
* @param (in) command_queue 		specifies the OpenCL queue
* @param (in) numEventsInWaitList 	specifies the number of OpenCL events
*	   	    		        to wait for
* @param (in) eventWaitList 		specifies the list of OpenCL events to
*					wait for
*
* @return
*   - OpenCL memory object of the allocated matrix
* </pre>
*/
JNIEXPORT jobject JNICALL Java_org_jocl_blas_CLBLAS_clblasCreateMatrixFromHostNative(JNIEnv *env, jclass cls, jobject context, jint order, jlong rows, jlong columns, jlong elemsize, jlong ld, jobject host, jlong off_host, jlong ld_host, jobject command_queue, jint numEventsInWaitList, jobjectArray eventWaitList, jintArray err)
{
    // Null-checks for non-primitive arguments
    if (context == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'context' is null for clblasCreateMatrixFromHost");
        return nullptr;
    }
    // order is primitive
    // rows is primitive
    // columns is primitive
    // elemsize is primitive
    // ld is primitive
    if (host == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'host' is null for clblasCreateMatrixFromHost");
        return nullptr;
    }
    // off_host is primitive
    // ld_host is primitive
    if (command_queue == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'command_queue' is null for clblasCreateMatrixFromHost");
        return nullptr;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // err may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasCreateMatrixFromHost(context=%p, order=%d, rows=%ld, columns=%ld, elemsize=%ld, ld=%ld, host=%p, off_host=%ld, ld_host=%ld, command_queue=%p, numEventsInWaitList=%d, eventWaitList=%p, err=%p)\n",
        context, order, rows, columns, elemsize, ld, host, off_host, ld_host, command_queue, numEventsInWaitList, eventWaitList, err);

    // Native variable declarations
    cl_context context_native;
    clblasOrder order_native;
    size_t rows_native = 0;
    size_t columns_native = 0;
    size_t elemsize_native = 0;
    size_t ld_native = 0;
    void* host_native;
    size_t off_host_native = 0;
    size_t ld_host_native = 0;
    cl_command_queue command_queue_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_int err_native;

    // Obtain native variable values
    if (!init_cl_context(env, context, context_native, true)) return nullptr;
    order_native = (clblasOrder)order;
    rows_native = (size_t)rows;
    columns_native = (size_t)columns;
    elemsize_native = (size_t)elemsize;
    ld_native = (size_t)ld;
    PointerData *host_pointerData = initPointerData(env, host);
    if (host_pointerData == NULL)
    {
        return nullptr;
    }
    host_native = (void*)host_pointerData->pointer;
    off_host_native = (size_t)off_host;
    ld_host_native = (size_t)ld_host;
    if (!init_cl_command_queue(env, command_queue, command_queue_native, true)) return nullptr;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return nullptr;
    // err is set here

    // Native function call
    cl_mem jniResult_native = clblasCreateMatrixFromHost(context_native, order_native, rows_native, columns_native, elemsize_native, ld_native, host_native, off_host_native, ld_host_native, command_queue_native, numEventsInWaitList_native, eventWaitList_native, &err_native);

    // Write back native variable values
    // context is a read-only native pointer
    // order is primitive
    // rows is primitive
    // columns is primitive
    // elemsize is primitive
    // ld is primitive
    if (!releasePointerData(env, host_pointerData, JNI_ABORT)) return nullptr;
    // off_host is primitive
    // ld_host is primitive
    // command_queue is a read-only native pointer
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return nullptr;
    if (!set(env, err, 0, (jint)err_native)) return nullptr;

    // Return the result
    return create_cl_mem(env, jniResult_native);
}

/**
* <pre>
* Copies synchronously a sub-matrix from host (A) to device (B).
*
* @param (in) order			matrix ordering
* @param (in) element_size		element size
* @param (in) A				specifies the source matrix on the host
* @param (in) offA			specifies the offset of matrix A in
*					elements
* @param (in) ldA			specifies the leading dimension of
* 					matrix A in elements
* @param (in) nrA			specifies the number of rows of A
*					in elements
* @param (in) ncA			specifies the number of columns of A
*					in elements
* @param (in) xA			specifies the top-left x position to
* 					copy from A
* @param (in) yA			specifies the top-left y position to
* 					copy from A
* @param (in) B				specifies the destination matrix on the
*					device
* @param (in) offB			specifies the offset of matrix B in
*					elements
* @param (in) ldB 			specifies the leading dimension of
* 					matrix B in bytes
* @param (in) nrB 			specifies the number of rows of B
*					in elements
* @param (in) ncB 			specifies the number of columns of B
*					in elements
* @param (in) xB 			specifies the top-left x position to
*					copy from B
* @param (in) yB 			specifies the top-left y position to
*					copy from B
* @param (in) nx 			specifies the number of elements to
*					copy according to the x dimension (rows)
* @param (in) ny 			specifies the number of elements to
*					copy according to the y dimension
*					(columns)
* @param (in) command_queue 		specifies the OpenCL queue
* @param (in) numEventsInWaitList 	specifies the number of OpenCL events
*	   	    		        to wait for
* @param (in) eventWaitList 		specifies the list of OpenCL events to
*					wait for
*
* @return
*   - \b clblasSuccess for success
*   - \b clblasInvalidValue if:
*	- \b xA + \b offA + \b nx is superior to number of columns of A
*      - \b xB + \b offB + \b nx is superior to number of columns of B
*      - \b yA + \b ny is superior to number of rows of A
*      - \b yB + \b ny is superior to number of rows of B
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasWriteSubMatrixNative(JNIEnv *env, jclass cls, jint order, jlong element_size, jobject A, jlong offA, jlong ldA, jlong nrA, jlong ncA, jlong xA, jlong yA, jobject B, jlong offB, jlong ldB, jlong nrB, jlong ncB, jlong xB, jlong yB, jlong nx, jlong ny, jobject command_queue, jint numEventsInWaitList, jobjectArray eventWaitList)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // element_size is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasWriteSubMatrix");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // ldA is primitive
    // nrA is primitive
    // ncA is primitive
    // xA is primitive
    // yA is primitive
    if (B == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasWriteSubMatrix");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offB is primitive
    // ldB is primitive
    // nrB is primitive
    // ncB is primitive
    // xB is primitive
    // yB is primitive
    // nx is primitive
    // ny is primitive
    if (command_queue == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'command_queue' is null for clblasWriteSubMatrix");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasWriteSubMatrix(order=%d, element_size=%ld, A=%p, offA=%ld, ldA=%ld, nrA=%ld, ncA=%ld, xA=%ld, yA=%ld, B=%p, offB=%ld, ldB=%ld, nrB=%ld, ncB=%ld, xB=%ld, yB=%ld, nx=%ld, ny=%ld, command_queue=%p, numEventsInWaitList=%d, eventWaitList=%p)\n",
        order, element_size, A, offA, ldA, nrA, ncA, xA, yA, B, offB, ldB, nrB, ncB, xB, yB, nx, ny, command_queue, numEventsInWaitList, eventWaitList);

    // Native variable declarations
    clblasOrder order_native;
    size_t element_size_native = 0;
    void* A_native;
    size_t offA_native = 0;
    size_t ldA_native = 0;
    size_t nrA_native = 0;
    size_t ncA_native = 0;
    size_t xA_native = 0;
    size_t yA_native = 0;
    cl_mem B_native = nullptr;
    size_t offB_native = 0;
    size_t ldB_native = 0;
    size_t nrB_native = 0;
    size_t ncB_native = 0;
    size_t xB_native = 0;
    size_t yB_native = 0;
    size_t nx_native = 0;
    size_t ny_native = 0;
    cl_command_queue command_queue_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    element_size_native = (size_t)element_size;
    PointerData *A_pointerData = initPointerData(env, A);
    if (A_pointerData == NULL)
    {
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    A_native = (void*)A_pointerData->pointer;
    offA_native = (size_t)offA;
    ldA_native = (size_t)ldA;
    nrA_native = (size_t)nrA;
    ncA_native = (size_t)ncA;
    xA_native = (size_t)xA;
    yA_native = (size_t)yA;
    if (!init_cl_mem(env, B, B_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offB_native = (size_t)offB;
    ldB_native = (size_t)ldB;
    nrB_native = (size_t)nrB;
    ncB_native = (size_t)ncB;
    xB_native = (size_t)xB;
    yB_native = (size_t)yB;
    nx_native = (size_t)nx;
    ny_native = (size_t)ny;
    if (!init_cl_command_queue(env, command_queue, command_queue_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasWriteSubMatrix(order_native, element_size_native, A_native, offA_native, ldA_native, nrA_native, ncA_native, xA_native, yA_native, B_native, offB_native, ldB_native, nrB_native, ncB_native, xB_native, yB_native, nx_native, ny_native, command_queue_native, numEventsInWaitList_native, eventWaitList_native);

    // Write back native variable values
    // order is primitive
    // element_size is primitive
    if (!releasePointerData(env, A_pointerData, JNI_ABORT)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // offA is primitive
    // ldA is primitive
    // nrA is primitive
    // ncA is primitive
    // xA is primitive
    // yA is primitive
    // B is a read-only native pointer
    // offB is primitive
    // ldB is primitive
    // nrB is primitive
    // ncB is primitive
    // xB is primitive
    // yB is primitive
    // nx is primitive
    // ny is primitive
    // command_queue is a read-only native pointer
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* Copies asynchronously a sub-matrix from host (A) to device (B).
*	  See \b clblasWriteSubMatrix().
*
* @param (out) event 	Event objects per each command queue that identify a
*			particular kernel execution instance.
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasWriteSubMatrixAsyncNative(JNIEnv *env, jclass cls, jint order, jlong element_size, jobject A, jlong offA, jlong ldA, jlong nrA, jlong ncA, jlong xA, jlong yA, jobject B, jlong offB, jlong ldB, jlong nrB, jlong ncB, jlong xB, jlong yB, jlong nx, jlong ny, jobject command_queue, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray event)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // element_size is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasWriteSubMatrixAsync");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // ldA is primitive
    // nrA is primitive
    // ncA is primitive
    // xA is primitive
    // yA is primitive
    if (B == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasWriteSubMatrixAsync");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offB is primitive
    // ldB is primitive
    // nrB is primitive
    // ncB is primitive
    // xB is primitive
    // yB is primitive
    // nx is primitive
    // ny is primitive
    if (command_queue == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'command_queue' is null for clblasWriteSubMatrixAsync");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // event may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasWriteSubMatrixAsync(order=%d, element_size=%ld, A=%p, offA=%ld, ldA=%ld, nrA=%ld, ncA=%ld, xA=%ld, yA=%ld, B=%p, offB=%ld, ldB=%ld, nrB=%ld, ncB=%ld, xB=%ld, yB=%ld, nx=%ld, ny=%ld, command_queue=%p, numEventsInWaitList=%d, eventWaitList=%p, event=%p)\n",
        order, element_size, A, offA, ldA, nrA, ncA, xA, yA, B, offB, ldB, nrB, ncB, xB, yB, nx, ny, command_queue, numEventsInWaitList, eventWaitList, event);

    // Native variable declarations
    clblasOrder order_native;
    size_t element_size_native = 0;
    void* A_native;
    size_t offA_native = 0;
    size_t ldA_native = 0;
    size_t nrA_native = 0;
    size_t ncA_native = 0;
    size_t xA_native = 0;
    size_t yA_native = 0;
    cl_mem B_native = nullptr;
    size_t offB_native = 0;
    size_t ldB_native = 0;
    size_t nrB_native = 0;
    size_t ncB_native = 0;
    size_t xB_native = 0;
    size_t yB_native = 0;
    size_t nx_native = 0;
    size_t ny_native = 0;
    cl_command_queue command_queue_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* event_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    element_size_native = (size_t)element_size;
    PointerData *A_pointerData = initPointerData(env, A);
    if (A_pointerData == NULL)
    {
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    A_native = (void*)A_pointerData->pointer;
    offA_native = (size_t)offA;
    ldA_native = (size_t)ldA;
    nrA_native = (size_t)nrA;
    ncA_native = (size_t)ncA;
    xA_native = (size_t)xA;
    yA_native = (size_t)yA;
    if (!init_cl_mem(env, B, B_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offB_native = (size_t)offB;
    ldB_native = (size_t)ldB;
    nrB_native = (size_t)nrB;
    ncB_native = (size_t)ncB;
    xB_native = (size_t)xB;
    yB_native = (size_t)yB;
    nx_native = (size_t)nx;
    ny_native = (size_t)ny;
    if (!init_cl_command_queue(env, command_queue, command_queue_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    cl_event event_object_native;
    if (event != nullptr)
    {
        event_native = &event_object_native;
    }

    // Native function call
    clblasStatus jniResult_native = clblasWriteSubMatrixAsync(order_native, element_size_native, A_native, offA_native, ldA_native, nrA_native, ncA_native, xA_native, yA_native, B_native, offB_native, ldB_native, nrB_native, ncB_native, xB_native, yB_native, nx_native, ny_native, command_queue_native, numEventsInWaitList_native, eventWaitList_native, event_native);

    // Write back native variable values
    // order is primitive
    // element_size is primitive
    if (!releasePointerData(env, A_pointerData, JNI_ABORT)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // offA is primitive
    // ldA is primitive
    // nrA is primitive
    // ncA is primitive
    // xA is primitive
    // yA is primitive
    // B is a read-only native pointer
    // offB is primitive
    // ldB is primitive
    // nrB is primitive
    // ncB is primitive
    // xB is primitive
    // yB is primitive
    // nx is primitive
    // ny is primitive
    // command_queue is a read-only native pointer
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event(env, event_native, event, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* Copies a sub-matrix from device (A) to host (B).
*	  See \b clblasWriteSubMatrix().
*
* @param (in) A		specifies the source matrix on the device
* @param (in) B		specifies the destination matrix on the host
*
* @return
*   - see \b clblasWriteSubMatrix()
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasReadSubMatrixNative(JNIEnv *env, jclass cls, jint order, jlong element_size, jobject A, jlong offA, jlong ldA, jlong nrA, jlong ncA, jlong xA, jlong yA, jobject B, jlong offB, jlong ldB, jlong nrB, jlong ncB, jlong xB, jlong yB, jlong nx, jlong ny, jobject command_queue, jint numEventsInWaitList, jobjectArray eventWaitList)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // element_size is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasReadSubMatrix");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // ldA is primitive
    // nrA is primitive
    // ncA is primitive
    // xA is primitive
    // yA is primitive
    if (B == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasReadSubMatrix");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offB is primitive
    // ldB is primitive
    // nrB is primitive
    // ncB is primitive
    // xB is primitive
    // yB is primitive
    // nx is primitive
    // ny is primitive
    if (command_queue == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'command_queue' is null for clblasReadSubMatrix");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasReadSubMatrix(order=%d, element_size=%ld, A=%p, offA=%ld, ldA=%ld, nrA=%ld, ncA=%ld, xA=%ld, yA=%ld, B=%p, offB=%ld, ldB=%ld, nrB=%ld, ncB=%ld, xB=%ld, yB=%ld, nx=%ld, ny=%ld, command_queue=%p, numEventsInWaitList=%d, eventWaitList=%p)\n",
        order, element_size, A, offA, ldA, nrA, ncA, xA, yA, B, offB, ldB, nrB, ncB, xB, yB, nx, ny, command_queue, numEventsInWaitList, eventWaitList);

    // Native variable declarations
    clblasOrder order_native;
    size_t element_size_native = 0;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    size_t ldA_native = 0;
    size_t nrA_native = 0;
    size_t ncA_native = 0;
    size_t xA_native = 0;
    size_t yA_native = 0;
    void* B_native;
    size_t offB_native = 0;
    size_t ldB_native = 0;
    size_t nrB_native = 0;
    size_t ncB_native = 0;
    size_t xB_native = 0;
    size_t yB_native = 0;
    size_t nx_native = 0;
    size_t ny_native = 0;
    cl_command_queue command_queue_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    element_size_native = (size_t)element_size;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    ldA_native = (size_t)ldA;
    nrA_native = (size_t)nrA;
    ncA_native = (size_t)ncA;
    xA_native = (size_t)xA;
    yA_native = (size_t)yA;
    PointerData *B_pointerData = initPointerData(env, B);
    if (B_pointerData == NULL)
    {
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    B_native = (void*)B_pointerData->pointer;
    offB_native = (size_t)offB;
    ldB_native = (size_t)ldB;
    nrB_native = (size_t)nrB;
    ncB_native = (size_t)ncB;
    xB_native = (size_t)xB;
    yB_native = (size_t)yB;
    nx_native = (size_t)nx;
    ny_native = (size_t)ny;
    if (!init_cl_command_queue(env, command_queue, command_queue_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasReadSubMatrix(order_native, element_size_native, A_native, offA_native, ldA_native, nrA_native, ncA_native, xA_native, yA_native, B_native, offB_native, ldB_native, nrB_native, ncB_native, xB_native, yB_native, nx_native, ny_native, command_queue_native, numEventsInWaitList_native, eventWaitList_native);

    // Write back native variable values
    // order is primitive
    // element_size is primitive
    // A is a read-only native pointer
    // offA is primitive
    // ldA is primitive
    // nrA is primitive
    // ncA is primitive
    // xA is primitive
    // yA is primitive
    if (!releasePointerData(env, B_pointerData, 0)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // offB is primitive
    // ldB is primitive
    // nrB is primitive
    // ncB is primitive
    // xB is primitive
    // yB is primitive
    // nx is primitive
    // ny is primitive
    // command_queue is a read-only native pointer
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* Copies asynchronously a sub-matrix from device (A) to host (B).
* 	  See \b clblasReadSubMatrix() and \b clblasWriteSubMatrixAsync().
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasReadSubMatrixAsyncNative(JNIEnv *env, jclass cls, jint order, jlong element_size, jobject A, jlong offA, jlong ldA, jlong nrA, jlong ncA, jlong xA, jlong yA, jobject B, jlong offB, jlong ldB, jlong nrB, jlong ncB, jlong xB, jlong yB, jlong nx, jlong ny, jobject command_queue, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray event)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // element_size is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasReadSubMatrixAsync");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // ldA is primitive
    // nrA is primitive
    // ncA is primitive
    // xA is primitive
    // yA is primitive
    if (B == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasReadSubMatrixAsync");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offB is primitive
    // ldB is primitive
    // nrB is primitive
    // ncB is primitive
    // xB is primitive
    // yB is primitive
    // nx is primitive
    // ny is primitive
    if (command_queue == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'command_queue' is null for clblasReadSubMatrixAsync");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // event may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasReadSubMatrixAsync(order=%d, element_size=%ld, A=%p, offA=%ld, ldA=%ld, nrA=%ld, ncA=%ld, xA=%ld, yA=%ld, B=%p, offB=%ld, ldB=%ld, nrB=%ld, ncB=%ld, xB=%ld, yB=%ld, nx=%ld, ny=%ld, command_queue=%p, numEventsInWaitList=%d, eventWaitList=%p, event=%p)\n",
        order, element_size, A, offA, ldA, nrA, ncA, xA, yA, B, offB, ldB, nrB, ncB, xB, yB, nx, ny, command_queue, numEventsInWaitList, eventWaitList, event);

    // Native variable declarations
    clblasOrder order_native;
    size_t element_size_native = 0;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    size_t ldA_native = 0;
    size_t nrA_native = 0;
    size_t ncA_native = 0;
    size_t xA_native = 0;
    size_t yA_native = 0;
    void* B_native;
    size_t offB_native = 0;
    size_t ldB_native = 0;
    size_t nrB_native = 0;
    size_t ncB_native = 0;
    size_t xB_native = 0;
    size_t yB_native = 0;
    size_t nx_native = 0;
    size_t ny_native = 0;
    cl_command_queue command_queue_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* event_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    element_size_native = (size_t)element_size;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    ldA_native = (size_t)ldA;
    nrA_native = (size_t)nrA;
    ncA_native = (size_t)ncA;
    xA_native = (size_t)xA;
    yA_native = (size_t)yA;
    PointerData *B_pointerData = initPointerData(env, B);
    if (B_pointerData == NULL)
    {
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    B_native = (void*)B_pointerData->pointer;
    offB_native = (size_t)offB;
    ldB_native = (size_t)ldB;
    nrB_native = (size_t)nrB;
    ncB_native = (size_t)ncB;
    xB_native = (size_t)xB;
    yB_native = (size_t)yB;
    nx_native = (size_t)nx;
    ny_native = (size_t)ny;
    if (!init_cl_command_queue(env, command_queue, command_queue_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    cl_event event_object_native;
    if (event != nullptr)
    {
        event_native = &event_object_native;
    }

    // Native function call
    clblasStatus jniResult_native = clblasReadSubMatrixAsync(order_native, element_size_native, A_native, offA_native, ldA_native, nrA_native, ncA_native, xA_native, yA_native, B_native, offB_native, ldB_native, nrB_native, ncB_native, xB_native, yB_native, nx_native, ny_native, command_queue_native, numEventsInWaitList_native, eventWaitList_native, event_native);

    // Write back native variable values
    // order is primitive
    // element_size is primitive
    // A is a read-only native pointer
    // offA is primitive
    // ldA is primitive
    // nrA is primitive
    // ncA is primitive
    // xA is primitive
    // yA is primitive
    if (!releasePointerData(env, B_pointerData, 0)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // offB is primitive
    // ldB is primitive
    // nrB is primitive
    // ncB is primitive
    // xB is primitive
    // yB is primitive
    // nx is primitive
    // ny is primitive
    // command_queue is a read-only native pointer
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event(env, event_native, event, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* Copies a sub-matrix from device (A) to device (B).
*	  See \b clblasWriteSubMatrix().
*
* @param (in) A		specifies the source matrix on the device
* @param (in) B		specifies the destination matrix on the device
*
* @return
*   - see \b clblasWriteSubMatrix()
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasCopySubMatrixNative(JNIEnv *env, jclass cls, jint order, jlong element_size, jobject A, jlong offA, jlong ldA, jlong nrA, jlong ncA, jlong xA, jlong yA, jobject B, jlong offB, jlong ldB, jlong nrB, jlong ncB, jlong xB, jlong yB, jlong nx, jlong ny, jobject command_queue, jint numEventsInWaitList, jobjectArray eventWaitList)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // element_size is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasCopySubMatrix");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // ldA is primitive
    // nrA is primitive
    // ncA is primitive
    // xA is primitive
    // yA is primitive
    if (B == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasCopySubMatrix");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offB is primitive
    // ldB is primitive
    // nrB is primitive
    // ncB is primitive
    // xB is primitive
    // yB is primitive
    // nx is primitive
    // ny is primitive
    if (command_queue == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'command_queue' is null for clblasCopySubMatrix");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasCopySubMatrix(order=%d, element_size=%ld, A=%p, offA=%ld, ldA=%ld, nrA=%ld, ncA=%ld, xA=%ld, yA=%ld, B=%p, offB=%ld, ldB=%ld, nrB=%ld, ncB=%ld, xB=%ld, yB=%ld, nx=%ld, ny=%ld, command_queue=%p, numEventsInWaitList=%d, eventWaitList=%p)\n",
        order, element_size, A, offA, ldA, nrA, ncA, xA, yA, B, offB, ldB, nrB, ncB, xB, yB, nx, ny, command_queue, numEventsInWaitList, eventWaitList);

    // Native variable declarations
    clblasOrder order_native;
    size_t element_size_native = 0;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    size_t ldA_native = 0;
    size_t nrA_native = 0;
    size_t ncA_native = 0;
    size_t xA_native = 0;
    size_t yA_native = 0;
    cl_mem B_native = nullptr;
    size_t offB_native = 0;
    size_t ldB_native = 0;
    size_t nrB_native = 0;
    size_t ncB_native = 0;
    size_t xB_native = 0;
    size_t yB_native = 0;
    size_t nx_native = 0;
    size_t ny_native = 0;
    cl_command_queue command_queue_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    element_size_native = (size_t)element_size;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    ldA_native = (size_t)ldA;
    nrA_native = (size_t)nrA;
    ncA_native = (size_t)ncA;
    xA_native = (size_t)xA;
    yA_native = (size_t)yA;
    if (!init_cl_mem(env, B, B_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offB_native = (size_t)offB;
    ldB_native = (size_t)ldB;
    nrB_native = (size_t)nrB;
    ncB_native = (size_t)ncB;
    xB_native = (size_t)xB;
    yB_native = (size_t)yB;
    nx_native = (size_t)nx;
    ny_native = (size_t)ny;
    if (!init_cl_command_queue(env, command_queue, command_queue_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasCopySubMatrix(order_native, element_size_native, A_native, offA_native, ldA_native, nrA_native, ncA_native, xA_native, yA_native, B_native, offB_native, ldB_native, nrB_native, ncB_native, xB_native, yB_native, nx_native, ny_native, command_queue_native, numEventsInWaitList_native, eventWaitList_native);

    // Write back native variable values
    // order is primitive
    // element_size is primitive
    // A is a read-only native pointer
    // offA is primitive
    // ldA is primitive
    // nrA is primitive
    // ncA is primitive
    // xA is primitive
    // yA is primitive
    // B is a read-only native pointer
    // offB is primitive
    // ldB is primitive
    // nrB is primitive
    // ncB is primitive
    // xB is primitive
    // yB is primitive
    // nx is primitive
    // ny is primitive
    // command_queue is a read-only native pointer
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* Copies asynchronously a sub-matrix from device (A) to device (B).
*        See \b clblasCopySubMatrix() and \b clblasWriteSubMatrixAsync().
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasCopySubMatrixAsyncNative(JNIEnv *env, jclass cls, jint order, jlong element_size, jobject A, jlong offA, jlong ldA, jlong nrA, jlong ncA, jlong xA, jlong yA, jobject B, jlong offB, jlong ldB, jlong nrB, jlong ncB, jlong xB, jlong yB, jlong nx, jlong ny, jobject command_queue, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray event)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // element_size is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasCopySubMatrixAsync");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // ldA is primitive
    // nrA is primitive
    // ncA is primitive
    // xA is primitive
    // yA is primitive
    if (B == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasCopySubMatrixAsync");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offB is primitive
    // ldB is primitive
    // nrB is primitive
    // ncB is primitive
    // xB is primitive
    // yB is primitive
    // nx is primitive
    // ny is primitive
    if (command_queue == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'command_queue' is null for clblasCopySubMatrixAsync");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // event may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasCopySubMatrixAsync(order=%d, element_size=%ld, A=%p, offA=%ld, ldA=%ld, nrA=%ld, ncA=%ld, xA=%ld, yA=%ld, B=%p, offB=%ld, ldB=%ld, nrB=%ld, ncB=%ld, xB=%ld, yB=%ld, nx=%ld, ny=%ld, command_queue=%p, numEventsInWaitList=%d, eventWaitList=%p, event=%p)\n",
        order, element_size, A, offA, ldA, nrA, ncA, xA, yA, B, offB, ldB, nrB, ncB, xB, yB, nx, ny, command_queue, numEventsInWaitList, eventWaitList, event);

    // Native variable declarations
    clblasOrder order_native;
    size_t element_size_native = 0;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    size_t ldA_native = 0;
    size_t nrA_native = 0;
    size_t ncA_native = 0;
    size_t xA_native = 0;
    size_t yA_native = 0;
    cl_mem B_native = nullptr;
    size_t offB_native = 0;
    size_t ldB_native = 0;
    size_t nrB_native = 0;
    size_t ncB_native = 0;
    size_t xB_native = 0;
    size_t yB_native = 0;
    size_t nx_native = 0;
    size_t ny_native = 0;
    cl_command_queue command_queue_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* event_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    element_size_native = (size_t)element_size;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    ldA_native = (size_t)ldA;
    nrA_native = (size_t)nrA;
    ncA_native = (size_t)ncA;
    xA_native = (size_t)xA;
    yA_native = (size_t)yA;
    if (!init_cl_mem(env, B, B_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offB_native = (size_t)offB;
    ldB_native = (size_t)ldB;
    nrB_native = (size_t)nrB;
    ncB_native = (size_t)ncB;
    xB_native = (size_t)xB;
    yB_native = (size_t)yB;
    nx_native = (size_t)nx;
    ny_native = (size_t)ny;
    if (!init_cl_command_queue(env, command_queue, command_queue_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    cl_event event_object_native;
    if (event != nullptr)
    {
        event_native = &event_object_native;
    }

    // Native function call
    clblasStatus jniResult_native = clblasCopySubMatrixAsync(order_native, element_size_native, A_native, offA_native, ldA_native, nrA_native, ncA_native, xA_native, yA_native, B_native, offB_native, ldB_native, nrB_native, ncB_native, xB_native, yB_native, nx_native, ny_native, command_queue_native, numEventsInWaitList_native, eventWaitList_native, event_native);

    // Write back native variable values
    // order is primitive
    // element_size is primitive
    // A is a read-only native pointer
    // offA is primitive
    // ldA is primitive
    // nrA is primitive
    // ncA is primitive
    // xA is primitive
    // yA is primitive
    // B is a read-only native pointer
    // offB is primitive
    // ldB is primitive
    // nrB is primitive
    // ncB is primitive
    // xB is primitive
    // yB is primitive
    // nx is primitive
    // ny is primitive
    // command_queue is a read-only native pointer
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event(env, event_native, event, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* Copies synchronously a vector from host (A) to device (B).
*	  See \b clblasWriteSubMatrix().
*
* @param (in) A		specifies the source vector on the host
* @param (in) B		specifies the destination vector on the device
*
* @return
*   - see \b clblasWriteSubMatrix()
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasWriteVectorNative(JNIEnv *env, jclass cls, jlong nb_elem, jlong element_size, jobject A, jlong offA, jobject B, jlong offB, jobject command_queue, jint numEventsInWaitList, jobjectArray eventWaitList)
{
    // Null-checks for non-primitive arguments
    // nb_elem is primitive
    // element_size is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasWriteVector");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    if (B == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasWriteVector");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offB is primitive
    if (command_queue == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'command_queue' is null for clblasWriteVector");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasWriteVector(nb_elem=%ld, element_size=%ld, A=%p, offA=%ld, B=%p, offB=%ld, command_queue=%p, numEventsInWaitList=%d, eventWaitList=%p)\n",
        nb_elem, element_size, A, offA, B, offB, command_queue, numEventsInWaitList, eventWaitList);

    // Native variable declarations
    size_t nb_elem_native = 0;
    size_t element_size_native = 0;
    void* A_native;
    size_t offA_native = 0;
    cl_mem B_native = nullptr;
    size_t offB_native = 0;
    cl_command_queue command_queue_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;

    // Obtain native variable values
    nb_elem_native = (size_t)nb_elem;
    element_size_native = (size_t)element_size;
    PointerData *A_pointerData = initPointerData(env, A);
    if (A_pointerData == NULL)
    {
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    A_native = (void*)A_pointerData->pointer;
    offA_native = (size_t)offA;
    if (!init_cl_mem(env, B, B_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offB_native = (size_t)offB;
    if (!init_cl_command_queue(env, command_queue, command_queue_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasWriteVector(nb_elem_native, element_size_native, A_native, offA_native, B_native, offB_native, command_queue_native, numEventsInWaitList_native, eventWaitList_native);

    // Write back native variable values
    // nb_elem is primitive
    // element_size is primitive
    if (!releasePointerData(env, A_pointerData, JNI_ABORT)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // offA is primitive
    // B is a read-only native pointer
    // offB is primitive
    // command_queue is a read-only native pointer
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* Copies asynchronously a vector from host (A) to device (B).
* 	  See \b clblasWriteVector() and \b clblasWriteSubMatrixAsync().
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasWriteVectorAsyncNative(JNIEnv *env, jclass cls, jlong nb_elem, jlong element_size, jobject A, jlong offA, jobject B, jlong offB, jobject command_queue, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // nb_elem is primitive
    // element_size is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasWriteVectorAsync");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    if (B == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasWriteVectorAsync");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offB is primitive
    if (command_queue == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'command_queue' is null for clblasWriteVectorAsync");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasWriteVectorAsync(nb_elem=%ld, element_size=%ld, A=%p, offA=%ld, B=%p, offB=%ld, command_queue=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        nb_elem, element_size, A, offA, B, offB, command_queue, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t nb_elem_native = 0;
    size_t element_size_native = 0;
    void* A_native;
    size_t offA_native = 0;
    cl_mem B_native = nullptr;
    size_t offB_native = 0;
    cl_command_queue command_queue_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    nb_elem_native = (size_t)nb_elem;
    element_size_native = (size_t)element_size;
    PointerData *A_pointerData = initPointerData(env, A);
    if (A_pointerData == NULL)
    {
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    A_native = (void*)A_pointerData->pointer;
    offA_native = (size_t)offA;
    if (!init_cl_mem(env, B, B_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offB_native = (size_t)offB;
    if (!init_cl_command_queue(env, command_queue, command_queue_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, 1, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasWriteVectorAsync(nb_elem_native, element_size_native, A_native, offA_native, B_native, offB_native, command_queue_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // nb_elem is primitive
    // element_size is primitive
    if (!releasePointerData(env, A_pointerData, JNI_ABORT)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // offA is primitive
    // B is a read-only native pointer
    // offB is primitive
    // command_queue is a read-only native pointer
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, 1, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* Copies synchronously a vector from device (A) to host (B).
*	  See \b clblasReadSubMatrix().
*
* @param (in) A		specifies the source vector on the device
* @param (in) B		specifies the destination vector on the host
*
* @return
*   - see \b clblasReadSubMatrix()
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasReadVectorNative(JNIEnv *env, jclass cls, jlong nb_elem, jlong element_size, jobject A, jlong offA, jobject B, jlong offB, jobject command_queue, jint numEventsInWaitList, jobjectArray eventWaitList)
{
    // Null-checks for non-primitive arguments
    // nb_elem is primitive
    // element_size is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasReadVector");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    if (B == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasReadVector");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offB is primitive
    if (command_queue == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'command_queue' is null for clblasReadVector");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasReadVector(nb_elem=%ld, element_size=%ld, A=%p, offA=%ld, B=%p, offB=%ld, command_queue=%p, numEventsInWaitList=%d, eventWaitList=%p)\n",
        nb_elem, element_size, A, offA, B, offB, command_queue, numEventsInWaitList, eventWaitList);

    // Native variable declarations
    size_t nb_elem_native = 0;
    size_t element_size_native = 0;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    void* B_native;
    size_t offB_native = 0;
    cl_command_queue command_queue_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;

    // Obtain native variable values
    nb_elem_native = (size_t)nb_elem;
    element_size_native = (size_t)element_size;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    PointerData *B_pointerData = initPointerData(env, B);
    if (B_pointerData == NULL)
    {
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    B_native = (void*)B_pointerData->pointer;
    offB_native = (size_t)offB;
    if (!init_cl_command_queue(env, command_queue, command_queue_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasReadVector(nb_elem_native, element_size_native, A_native, offA_native, B_native, offB_native, command_queue_native, numEventsInWaitList_native, eventWaitList_native);

    // Write back native variable values
    // nb_elem is primitive
    // element_size is primitive
    // A is a read-only native pointer
    // offA is primitive
    if (!releasePointerData(env, B_pointerData, 0)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // offB is primitive
    // command_queue is a read-only native pointer
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* Copies asynchronously a vector from device (A) to host (B).
* 	  See \b clblasReadVector() and \b clblasWriteSubMatrixAsync().
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasReadVectorAsyncNative(JNIEnv *env, jclass cls, jlong nb_elem, jlong element_size, jobject A, jlong offA, jobject B, jlong offB, jobject command_queue, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // nb_elem is primitive
    // element_size is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasReadVectorAsync");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    if (B == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasReadVectorAsync");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offB is primitive
    if (command_queue == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'command_queue' is null for clblasReadVectorAsync");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasReadVectorAsync(nb_elem=%ld, element_size=%ld, A=%p, offA=%ld, B=%p, offB=%ld, command_queue=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        nb_elem, element_size, A, offA, B, offB, command_queue, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t nb_elem_native = 0;
    size_t element_size_native = 0;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    void* B_native;
    size_t offB_native = 0;
    cl_command_queue command_queue_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    nb_elem_native = (size_t)nb_elem;
    element_size_native = (size_t)element_size;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    PointerData *B_pointerData = initPointerData(env, B);
    if (B_pointerData == NULL)
    {
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    B_native = (void*)B_pointerData->pointer;
    offB_native = (size_t)offB;
    if (!init_cl_command_queue(env, command_queue, command_queue_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, 1, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasReadVectorAsync(nb_elem_native, element_size_native, A_native, offA_native, B_native, offB_native, command_queue_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // nb_elem is primitive
    // element_size is primitive
    // A is a read-only native pointer
    // offA is primitive
    if (!releasePointerData(env, B_pointerData, 0)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // offB is primitive
    // command_queue is a read-only native pointer
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, 1, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* Copies synchronously a vector from device (A) to device (B).
*	  See \b clblasCopySubMatrix().
*
* @param (in) A		specifies the source vector on the device
* @param (in) B		specifies the destination vector on the device
*
* @return
*   - see \b clblasCopySubMatrix()
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasCopyVectorNative(JNIEnv *env, jclass cls, jlong nb_elem, jlong element_size, jobject A, jlong offA, jobject B, jlong offB, jobject command_queue, jint numEventsInWaitList, jobjectArray eventWaitList)
{
    // Null-checks for non-primitive arguments
    // nb_elem is primitive
    // element_size is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasCopyVector");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    if (B == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasCopyVector");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offB is primitive
    if (command_queue == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'command_queue' is null for clblasCopyVector");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasCopyVector(nb_elem=%ld, element_size=%ld, A=%p, offA=%ld, B=%p, offB=%ld, command_queue=%p, numEventsInWaitList=%d, eventWaitList=%p)\n",
        nb_elem, element_size, A, offA, B, offB, command_queue, numEventsInWaitList, eventWaitList);

    // Native variable declarations
    size_t nb_elem_native = 0;
    size_t element_size_native = 0;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    cl_mem B_native = nullptr;
    size_t offB_native = 0;
    cl_command_queue command_queue_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;

    // Obtain native variable values
    nb_elem_native = (size_t)nb_elem;
    element_size_native = (size_t)element_size;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    if (!init_cl_mem(env, B, B_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offB_native = (size_t)offB;
    if (!init_cl_command_queue(env, command_queue, command_queue_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasCopyVector(nb_elem_native, element_size_native, A_native, offA_native, B_native, offB_native, command_queue_native, numEventsInWaitList_native, eventWaitList_native);

    // Write back native variable values
    // nb_elem is primitive
    // element_size is primitive
    // A is a read-only native pointer
    // offA is primitive
    // B is a read-only native pointer
    // offB is primitive
    // command_queue is a read-only native pointer
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* Copies asynchronously a vector from device (A) to device (B).
* 	  See \b clblasCopyVector() and \b clblasWriteSubMatrixAsync().
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasCopyVectorAsyncNative(JNIEnv *env, jclass cls, jlong nb_elem, jlong element_size, jobject A, jlong offA, jobject B, jlong offB, jobject command_queue, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // nb_elem is primitive
    // element_size is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasCopyVectorAsync");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    if (B == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasCopyVectorAsync");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offB is primitive
    if (command_queue == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'command_queue' is null for clblasCopyVectorAsync");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasCopyVectorAsync(nb_elem=%ld, element_size=%ld, A=%p, offA=%ld, B=%p, offB=%ld, command_queue=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        nb_elem, element_size, A, offA, B, offB, command_queue, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    size_t nb_elem_native = 0;
    size_t element_size_native = 0;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    cl_mem B_native = nullptr;
    size_t offB_native = 0;
    cl_command_queue command_queue_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    nb_elem_native = (size_t)nb_elem;
    element_size_native = (size_t)element_size;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    if (!init_cl_mem(env, B, B_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offB_native = (size_t)offB;
    if (!init_cl_command_queue(env, command_queue, command_queue_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, 1, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasCopyVectorAsync(nb_elem_native, element_size_native, A_native, offA_native, B_native, offB_native, command_queue_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // nb_elem is primitive
    // element_size is primitive
    // A is a read-only native pointer
    // offA is primitive
    // B is a read-only native pointer
    // offB is primitive
    // command_queue is a read-only native pointer
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, 1, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* Copies synchronously a whole matrix from host (A) to device (B).
*        See \b clblasWriteSubMatrix().
*
* @param (in) A		specifies the source matrix on the host
* @param (in) B		specifies the destination matrix on the device
*
* @return
*   - see \b clblasWriteSubMatrix()
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasWriteMatrixNative(JNIEnv *env, jclass cls, jint order, jlong sx, jlong sy, jlong element_size, jobject A, jlong offA, jlong ldA, jobject B, jlong offB, jlong ldB, jobject command_queue, jint numEventsInWaitList, jobjectArray eventWaitList)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // sx is primitive
    // sy is primitive
    // element_size is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasWriteMatrix");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // ldA is primitive
    if (B == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasWriteMatrix");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offB is primitive
    // ldB is primitive
    if (command_queue == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'command_queue' is null for clblasWriteMatrix");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasWriteMatrix(order=%d, sx=%ld, sy=%ld, element_size=%ld, A=%p, offA=%ld, ldA=%ld, B=%p, offB=%ld, ldB=%ld, command_queue=%p, numEventsInWaitList=%d, eventWaitList=%p)\n",
        order, sx, sy, element_size, A, offA, ldA, B, offB, ldB, command_queue, numEventsInWaitList, eventWaitList);

    // Native variable declarations
    clblasOrder order_native;
    size_t sx_native = 0;
    size_t sy_native = 0;
    size_t element_size_native = 0;
    void* A_native;
    size_t offA_native = 0;
    size_t ldA_native = 0;
    cl_mem B_native = nullptr;
    size_t offB_native = 0;
    size_t ldB_native = 0;
    cl_command_queue command_queue_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    sx_native = (size_t)sx;
    sy_native = (size_t)sy;
    element_size_native = (size_t)element_size;
    PointerData *A_pointerData = initPointerData(env, A);
    if (A_pointerData == NULL)
    {
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    A_native = (void*)A_pointerData->pointer;
    offA_native = (size_t)offA;
    ldA_native = (size_t)ldA;
    if (!init_cl_mem(env, B, B_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offB_native = (size_t)offB;
    ldB_native = (size_t)ldB;
    if (!init_cl_command_queue(env, command_queue, command_queue_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasWriteMatrix(order_native, sx_native, sy_native, element_size_native, A_native, offA_native, ldA_native, B_native, offB_native, ldB_native, command_queue_native, numEventsInWaitList_native, eventWaitList_native);

    // Write back native variable values
    // order is primitive
    // sx is primitive
    // sy is primitive
    // element_size is primitive
    if (!releasePointerData(env, A_pointerData, JNI_ABORT)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // offA is primitive
    // ldA is primitive
    // B is a read-only native pointer
    // offB is primitive
    // ldB is primitive
    // command_queue is a read-only native pointer
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* Copies asynchronously a vector from host (A) to device (B).
*        See \b clblasWriteMatrix() and \b clblasWriteSubMatrixAsync().
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasWriteMatrixAsyncNative(JNIEnv *env, jclass cls, jint order, jlong sx, jlong sy, jlong element_size, jobject A, jlong offA, jlong ldA, jobject B, jlong offB, jlong ldB, jobject command_queue, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // sx is primitive
    // sy is primitive
    // element_size is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasWriteMatrixAsync");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // ldA is primitive
    if (B == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasWriteMatrixAsync");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offB is primitive
    // ldB is primitive
    if (command_queue == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'command_queue' is null for clblasWriteMatrixAsync");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasWriteMatrixAsync(order=%d, sx=%ld, sy=%ld, element_size=%ld, A=%p, offA=%ld, ldA=%ld, B=%p, offB=%ld, ldB=%ld, command_queue=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, sx, sy, element_size, A, offA, ldA, B, offB, ldB, command_queue, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    size_t sx_native = 0;
    size_t sy_native = 0;
    size_t element_size_native = 0;
    void* A_native;
    size_t offA_native = 0;
    size_t ldA_native = 0;
    cl_mem B_native = nullptr;
    size_t offB_native = 0;
    size_t ldB_native = 0;
    cl_command_queue command_queue_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    sx_native = (size_t)sx;
    sy_native = (size_t)sy;
    element_size_native = (size_t)element_size;
    PointerData *A_pointerData = initPointerData(env, A);
    if (A_pointerData == NULL)
    {
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    A_native = (void*)A_pointerData->pointer;
    offA_native = (size_t)offA;
    ldA_native = (size_t)ldA;
    if (!init_cl_mem(env, B, B_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offB_native = (size_t)offB;
    ldB_native = (size_t)ldB;
    if (!init_cl_command_queue(env, command_queue, command_queue_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, 1, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasWriteMatrixAsync(order_native, sx_native, sy_native, element_size_native, A_native, offA_native, ldA_native, B_native, offB_native, ldB_native, command_queue_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // sx is primitive
    // sy is primitive
    // element_size is primitive
    if (!releasePointerData(env, A_pointerData, JNI_ABORT)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // offA is primitive
    // ldA is primitive
    // B is a read-only native pointer
    // offB is primitive
    // ldB is primitive
    // command_queue is a read-only native pointer
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, 1, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* Copies synchronously a whole matrix from device (A) to host (B).
*	  See \b clblasReadSubMatrix().
*
* @param (in) A		specifies the source vector on the device
* @param (in) B		specifies the destination vector on the host
*
* @return
*   - see \b clblasReadSubMatrix()
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasReadMatrixNative(JNIEnv *env, jclass cls, jint order, jlong sx, jlong sy, jlong element_size, jobject A, jlong offA, jlong ldA, jobject B, jlong offB, jlong ldB, jobject command_queue, jint numEventsInWaitList, jobjectArray eventWaitList)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // sx is primitive
    // sy is primitive
    // element_size is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasReadMatrix");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // ldA is primitive
    if (B == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasReadMatrix");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offB is primitive
    // ldB is primitive
    if (command_queue == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'command_queue' is null for clblasReadMatrix");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasReadMatrix(order=%d, sx=%ld, sy=%ld, element_size=%ld, A=%p, offA=%ld, ldA=%ld, B=%p, offB=%ld, ldB=%ld, command_queue=%p, numEventsInWaitList=%d, eventWaitList=%p)\n",
        order, sx, sy, element_size, A, offA, ldA, B, offB, ldB, command_queue, numEventsInWaitList, eventWaitList);

    // Native variable declarations
    clblasOrder order_native;
    size_t sx_native = 0;
    size_t sy_native = 0;
    size_t element_size_native = 0;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    size_t ldA_native = 0;
    void* B_native;
    size_t offB_native = 0;
    size_t ldB_native = 0;
    cl_command_queue command_queue_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    sx_native = (size_t)sx;
    sy_native = (size_t)sy;
    element_size_native = (size_t)element_size;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    ldA_native = (size_t)ldA;
    PointerData *B_pointerData = initPointerData(env, B);
    if (B_pointerData == NULL)
    {
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    B_native = (void*)B_pointerData->pointer;
    offB_native = (size_t)offB;
    ldB_native = (size_t)ldB;
    if (!init_cl_command_queue(env, command_queue, command_queue_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasReadMatrix(order_native, sx_native, sy_native, element_size_native, A_native, offA_native, ldA_native, B_native, offB_native, ldB_native, command_queue_native, numEventsInWaitList_native, eventWaitList_native);

    // Write back native variable values
    // order is primitive
    // sx is primitive
    // sy is primitive
    // element_size is primitive
    // A is a read-only native pointer
    // offA is primitive
    // ldA is primitive
    if (!releasePointerData(env, B_pointerData, 0)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // offB is primitive
    // ldB is primitive
    // command_queue is a read-only native pointer
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* Copies asynchronously a vector from device (A) to host (B).
*        See \b clblasReadMatrix() and \b clblasWriteSubMatrixAsync().
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasReadMatrixAsyncNative(JNIEnv *env, jclass cls, jint order, jlong sx, jlong sy, jlong element_size, jobject A, jlong offA, jlong ldA, jobject B, jlong offB, jlong ldB, jobject command_queue, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // sx is primitive
    // sy is primitive
    // element_size is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasReadMatrixAsync");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // ldA is primitive
    if (B == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasReadMatrixAsync");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offB is primitive
    // ldB is primitive
    if (command_queue == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'command_queue' is null for clblasReadMatrixAsync");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasReadMatrixAsync(order=%d, sx=%ld, sy=%ld, element_size=%ld, A=%p, offA=%ld, ldA=%ld, B=%p, offB=%ld, ldB=%ld, command_queue=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, sx, sy, element_size, A, offA, ldA, B, offB, ldB, command_queue, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    size_t sx_native = 0;
    size_t sy_native = 0;
    size_t element_size_native = 0;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    size_t ldA_native = 0;
    void* B_native;
    size_t offB_native = 0;
    size_t ldB_native = 0;
    cl_command_queue command_queue_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    sx_native = (size_t)sx;
    sy_native = (size_t)sy;
    element_size_native = (size_t)element_size;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    ldA_native = (size_t)ldA;
    PointerData *B_pointerData = initPointerData(env, B);
    if (B_pointerData == NULL)
    {
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    B_native = (void*)B_pointerData->pointer;
    offB_native = (size_t)offB;
    ldB_native = (size_t)ldB;
    if (!init_cl_command_queue(env, command_queue, command_queue_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, 1, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasReadMatrixAsync(order_native, sx_native, sy_native, element_size_native, A_native, offA_native, ldA_native, B_native, offB_native, ldB_native, command_queue_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // sx is primitive
    // sy is primitive
    // element_size is primitive
    // A is a read-only native pointer
    // offA is primitive
    // ldA is primitive
    if (!releasePointerData(env, B_pointerData, 0)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // offB is primitive
    // ldB is primitive
    // command_queue is a read-only native pointer
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, 1, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* Copies synchronously a whole matrix from device (A) to device (B).
*	  See \b clblasCopySubMatrix().
*
* @param (in) A		specifies the source matrix on the device
* @param (in) B		specifies the destination matrix on the device
*
* @return
*   - see \b clblasCopySubMatrix()
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasCopyMatrixNative(JNIEnv *env, jclass cls, jint order, jlong sx, jlong sy, jlong element_size, jobject A, jlong offA, jlong ldA, jobject B, jlong offB, jlong ldB, jobject command_queue, jint numEventsInWaitList, jobjectArray eventWaitList)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // sx is primitive
    // sy is primitive
    // element_size is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasCopyMatrix");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // ldA is primitive
    if (B == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasCopyMatrix");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offB is primitive
    // ldB is primitive
    if (command_queue == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'command_queue' is null for clblasCopyMatrix");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasCopyMatrix(order=%d, sx=%ld, sy=%ld, element_size=%ld, A=%p, offA=%ld, ldA=%ld, B=%p, offB=%ld, ldB=%ld, command_queue=%p, numEventsInWaitList=%d, eventWaitList=%p)\n",
        order, sx, sy, element_size, A, offA, ldA, B, offB, ldB, command_queue, numEventsInWaitList, eventWaitList);

    // Native variable declarations
    clblasOrder order_native;
    size_t sx_native = 0;
    size_t sy_native = 0;
    size_t element_size_native = 0;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    size_t ldA_native = 0;
    cl_mem B_native = nullptr;
    size_t offB_native = 0;
    size_t ldB_native = 0;
    cl_command_queue command_queue_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    sx_native = (size_t)sx;
    sy_native = (size_t)sy;
    element_size_native = (size_t)element_size;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    ldA_native = (size_t)ldA;
    if (!init_cl_mem(env, B, B_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offB_native = (size_t)offB;
    ldB_native = (size_t)ldB;
    if (!init_cl_command_queue(env, command_queue, command_queue_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasCopyMatrix(order_native, sx_native, sy_native, element_size_native, A_native, offA_native, ldA_native, B_native, offB_native, ldB_native, command_queue_native, numEventsInWaitList_native, eventWaitList_native);

    // Write back native variable values
    // order is primitive
    // sx is primitive
    // sy is primitive
    // element_size is primitive
    // A is a read-only native pointer
    // offA is primitive
    // ldA is primitive
    // B is a read-only native pointer
    // offB is primitive
    // ldB is primitive
    // command_queue is a read-only native pointer
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* Copies asynchronously a vector from device (A) to device (B).
*        See \b clblasCopyMatrix() and \b clblasWriteSubMatrixAsync().
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasCopyMatrixAsyncNative(JNIEnv *env, jclass cls, jint order, jlong sx, jlong sy, jlong element_size, jobject A, jlong offA, jlong ldA, jobject B, jlong offB, jlong ldB, jobject command_queue, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray events)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // sx is primitive
    // sy is primitive
    // element_size is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasCopyMatrixAsync");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // ldA is primitive
    if (B == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'B' is null for clblasCopyMatrixAsync");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offB is primitive
    // ldB is primitive
    if (command_queue == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'command_queue' is null for clblasCopyMatrixAsync");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // events may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasCopyMatrixAsync(order=%d, sx=%ld, sy=%ld, element_size=%ld, A=%p, offA=%ld, ldA=%ld, B=%p, offB=%ld, ldB=%ld, command_queue=%p, numEventsInWaitList=%d, eventWaitList=%p, events=%p)\n",
        order, sx, sy, element_size, A, offA, ldA, B, offB, ldB, command_queue, numEventsInWaitList, eventWaitList, events);

    // Native variable declarations
    clblasOrder order_native;
    size_t sx_native = 0;
    size_t sy_native = 0;
    size_t element_size_native = 0;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    size_t ldA_native = 0;
    cl_mem B_native = nullptr;
    size_t offB_native = 0;
    size_t ldB_native = 0;
    cl_command_queue command_queue_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* events_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    sx_native = (size_t)sx;
    sy_native = (size_t)sy;
    element_size_native = (size_t)element_size;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    ldA_native = (size_t)ldA;
    if (!init_cl_mem(env, B, B_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offB_native = (size_t)offB;
    ldB_native = (size_t)ldB;
    if (!init_cl_command_queue(env, command_queue, command_queue_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!init_cl_event_list(env, events, events_native, 1, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasCopyMatrixAsync(order_native, sx_native, sy_native, element_size_native, A_native, offA_native, ldA_native, B_native, offB_native, ldB_native, command_queue_native, numEventsInWaitList_native, eventWaitList_native, events_native);

    // Write back native variable values
    // order is primitive
    // sx is primitive
    // sy is primitive
    // element_size is primitive
    // A is a read-only native pointer
    // offA is primitive
    // ldA is primitive
    // B is a read-only native pointer
    // offB is primitive
    // ldB is primitive
    // command_queue is a read-only native pointer
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event_list(env, events_native, events, 1, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* Fill synchronously a vector with a pattern of a size element_size_bytes
*
* @param (in) nb_elem             specifies the number of element in buffer A
* @param (in) element_size        specifies the size of one element of A. Supported sizes correspond
*                                element size used in clBLAS (1,2,4,8,16)
* @param (in) A		          specifies the source vector on the device
* @param (in) offA                specifies the offset of matrix A in
*				  elements
* @param (in) pattern             specifies the host address of the pattern to fill with (element_size_bytes)
* @param (in) command_queue 	  specifies the OpenCL queue
* @param (in) numEventsInWaitList specifies the number of OpenCL events
*	   	    		  to wait for
* @param (in) eventWaitList 	  specifies the list of OpenCL events to
*				  wait for
* @return
*   - see \b clblasWriteSubMatrix()
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasFillVectorNative(JNIEnv *env, jclass cls, jlong nb_elem, jlong element_size, jobject A, jlong offA, jobject host, jobject command_queue, jint numEventsInWaitList, jobjectArray eventWaitList)
{
    // Null-checks for non-primitive arguments
    // nb_elem is primitive
    // element_size is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasFillVector");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    if (host == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'host' is null for clblasFillVector");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (command_queue == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'command_queue' is null for clblasFillVector");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasFillVector(nb_elem=%ld, element_size=%ld, A=%p, offA=%ld, host=%p, command_queue=%p, numEventsInWaitList=%d, eventWaitList=%p)\n",
        nb_elem, element_size, A, offA, host, command_queue, numEventsInWaitList, eventWaitList);

    // Native variable declarations
    size_t nb_elem_native = 0;
    size_t element_size_native = 0;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    void* host_native;
    cl_command_queue command_queue_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;

    // Obtain native variable values
    nb_elem_native = (size_t)nb_elem;
    element_size_native = (size_t)element_size;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    PointerData *host_pointerData = initPointerData(env, host);
    if (host_pointerData == NULL)
    {
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    host_native = (void*)host_pointerData->pointer;
    if (!init_cl_command_queue(env, command_queue, command_queue_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasFillVector(nb_elem_native, element_size_native, A_native, offA_native, host_native, command_queue_native, numEventsInWaitList_native, eventWaitList_native);

    // Write back native variable values
    // nb_elem is primitive
    // element_size is primitive
    // A is a read-only native pointer
    // offA is primitive
    if (!releasePointerData(env, host_pointerData, JNI_ABORT)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // command_queue is a read-only native pointer
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* Fill asynchronously a vector with a pattern of a size element_size_bytes
*	  See \b clblasFillVector().
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasFillVectorAsyncNative(JNIEnv *env, jclass cls, jlong nb_elem, jlong element_size, jobject A, jlong offA, jobject pattern, jobject command_queue, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray event)
{
    // Null-checks for non-primitive arguments
    // nb_elem is primitive
    // element_size is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasFillVectorAsync");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    if (pattern == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'pattern' is null for clblasFillVectorAsync");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (command_queue == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'command_queue' is null for clblasFillVectorAsync");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // event may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasFillVectorAsync(nb_elem=%ld, element_size=%ld, A=%p, offA=%ld, pattern=%p, command_queue=%p, numEventsInWaitList=%d, eventWaitList=%p, event=%p)\n",
        nb_elem, element_size, A, offA, pattern, command_queue, numEventsInWaitList, eventWaitList, event);

    // Native variable declarations
    size_t nb_elem_native = 0;
    size_t element_size_native = 0;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    void* pattern_native;
    cl_command_queue command_queue_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* event_native;

    // Obtain native variable values
    nb_elem_native = (size_t)nb_elem;
    element_size_native = (size_t)element_size;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    PointerData *pattern_pointerData = initPointerData(env, pattern);
    if (pattern_pointerData == NULL)
    {
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    pattern_native = (void*)pattern_pointerData->pointer;
    if (!init_cl_command_queue(env, command_queue, command_queue_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    cl_event event_object_native;
    if (event != nullptr)
    {
        event_native = &event_object_native;
    }

    // Native function call
    clblasStatus jniResult_native = clblasFillVectorAsync(nb_elem_native, element_size_native, A_native, offA_native, pattern_native, command_queue_native, numEventsInWaitList_native, eventWaitList_native, event_native);

    // Write back native variable values
    // nb_elem is primitive
    // element_size is primitive
    // A is a read-only native pointer
    // offA is primitive
    if (!releasePointerData(env, pattern_pointerData, JNI_ABORT)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // command_queue is a read-only native pointer
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event(env, event_native, event, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* Fill synchronously a matrix with a pattern of a size element_size_bytes
*
* @param (in) order               specifies the matrix order
* @param (in) element_size        specifies the size of one element of A. Supported sizes correspond
*                                element size used in clBLAS (1,2,4,8,16)
* @param (in) A		          specifies the source vector on the device
* @param (in) offA                specifies the offset of matrix A in
* @param (in) ldA                 specifies the leading dimension of A
* @param (in) nrA                 specifies the number of row in A
* @param (in) ncA                 specifies the number of column in A
* @param (in) pattern             specifies the host address of the pattern to fill with (element_size_bytes)
* @param (in) command_queue 	  specifies the OpenCL queue
* @param (in) numEventsInWaitList specifies the number of OpenCL events to wait for
* @param (in) eventWaitList 	  specifies the list of OpenCL events to wait for
* @return
*   - see \b clblasWriteSubMatrix()
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasFillMatrixNative(JNIEnv *env, jclass cls, jint order, jlong element_size, jobject A, jlong offA, jlong ldA, jlong nrA, jlong ncA, jobject pattern, jobject command_queue, jint numEventsInWaitList, jobjectArray eventWaitList)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // element_size is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasFillMatrix");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // ldA is primitive
    // nrA is primitive
    // ncA is primitive
    if (pattern == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'pattern' is null for clblasFillMatrix");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (command_queue == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'command_queue' is null for clblasFillMatrix");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasFillMatrix(order=%d, element_size=%ld, A=%p, offA=%ld, ldA=%ld, nrA=%ld, ncA=%ld, pattern=%p, command_queue=%p, numEventsInWaitList=%d, eventWaitList=%p)\n",
        order, element_size, A, offA, ldA, nrA, ncA, pattern, command_queue, numEventsInWaitList, eventWaitList);

    // Native variable declarations
    clblasOrder order_native;
    size_t element_size_native = 0;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    size_t ldA_native = 0;
    size_t nrA_native = 0;
    size_t ncA_native = 0;
    void* pattern_native;
    cl_command_queue command_queue_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    element_size_native = (size_t)element_size;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    ldA_native = (size_t)ldA;
    nrA_native = (size_t)nrA;
    ncA_native = (size_t)ncA;
    PointerData *pattern_pointerData = initPointerData(env, pattern);
    if (pattern_pointerData == NULL)
    {
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    pattern_native = (void*)pattern_pointerData->pointer;
    if (!init_cl_command_queue(env, command_queue, command_queue_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasFillMatrix(order_native, element_size_native, A_native, offA_native, ldA_native, nrA_native, ncA_native, pattern_native, command_queue_native, numEventsInWaitList_native, eventWaitList_native);

    // Write back native variable values
    // order is primitive
    // element_size is primitive
    // A is a read-only native pointer
    // offA is primitive
    // ldA is primitive
    // nrA is primitive
    // ncA is primitive
    if (!releasePointerData(env, pattern_pointerData, JNI_ABORT)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // command_queue is a read-only native pointer
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* Partially fill a sub-matrix with a pattern of a size element_size_bytes
*
*
* @param (in) order               specifies the matrix order
* @param (in) element_size        specifies the size of one element of A. Supported values
*                                are to element sizes used in clBLAS - that is 1, 2, 4, 8 or 16
* @param (in) offA                specifies the offset of matrix A in elements
* @param (in) ldA                 specifies the leading dimension of A in elements
* @param (in) nrA		  specifies the number of rows of A
*				  in elements
* @param (in) ncA		  specifies the number of columns of A
*				  in elements
* @param (in) xA		  specifies the top-left x position to
* 				  copy from A
* @param (in) yA		  specifies the top-left y position to
* 				  copy from A
* @param (in) nx 		  specifies the number of elements to
*				  copy according to the x dimension (rows)
* @param (in) ny 		  specifies the number of elements to
*				  copy according to the y dimension
*				  (columns)
* @param (in) pattern             specifies the host address of the pattern to fill with (element_size_bytes)
* @param (in) command_queue 	  specifies the OpenCL queue
* @param (in) numEventsInWaitList specifies the number of OpenCL events to wait for
* @param (in) eventWaitList 	  specifies the list of OpenCL events to wait for
* @return
*   - see \b clblasWriteSubMatrix()
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasFillSubMatrixNative(JNIEnv *env, jclass cls, jint order, jlong element_size, jobject A, jlong offA, jlong ldA, jlong nrA, jlong ncA, jlong xA, jlong yA, jlong nx, jlong ny, jobject pattern, jobject command_queue, jint numEventsInWaitList, jobjectArray eventWaitList)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // element_size is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasFillSubMatrix");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // ldA is primitive
    // nrA is primitive
    // ncA is primitive
    // xA is primitive
    // yA is primitive
    // nx is primitive
    // ny is primitive
    if (pattern == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'pattern' is null for clblasFillSubMatrix");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (command_queue == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'command_queue' is null for clblasFillSubMatrix");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasFillSubMatrix(order=%d, element_size=%ld, A=%p, offA=%ld, ldA=%ld, nrA=%ld, ncA=%ld, xA=%ld, yA=%ld, nx=%ld, ny=%ld, pattern=%p, command_queue=%p, numEventsInWaitList=%d, eventWaitList=%p)\n",
        order, element_size, A, offA, ldA, nrA, ncA, xA, yA, nx, ny, pattern, command_queue, numEventsInWaitList, eventWaitList);

    // Native variable declarations
    clblasOrder order_native;
    size_t element_size_native = 0;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    size_t ldA_native = 0;
    size_t nrA_native = 0;
    size_t ncA_native = 0;
    size_t xA_native = 0;
    size_t yA_native = 0;
    size_t nx_native = 0;
    size_t ny_native = 0;
    void* pattern_native;
    cl_command_queue command_queue_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    element_size_native = (size_t)element_size;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    ldA_native = (size_t)ldA;
    nrA_native = (size_t)nrA;
    ncA_native = (size_t)ncA;
    xA_native = (size_t)xA;
    yA_native = (size_t)yA;
    nx_native = (size_t)nx;
    ny_native = (size_t)ny;
    PointerData *pattern_pointerData = initPointerData(env, pattern);
    if (pattern_pointerData == NULL)
    {
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    pattern_native = (void*)pattern_pointerData->pointer;
    if (!init_cl_command_queue(env, command_queue, command_queue_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Native function call
    clblasStatus jniResult_native = clblasFillSubMatrix(order_native, element_size_native, A_native, offA_native, ldA_native, nrA_native, ncA_native, xA_native, yA_native, nx_native, ny_native, pattern_native, command_queue_native, numEventsInWaitList_native, eventWaitList_native);

    // Write back native variable values
    // order is primitive
    // element_size is primitive
    // A is a read-only native pointer
    // offA is primitive
    // ldA is primitive
    // nrA is primitive
    // ncA is primitive
    // xA is primitive
    // yA is primitive
    // nx is primitive
    // ny is primitive
    if (!releasePointerData(env, pattern_pointerData, JNI_ABORT)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // command_queue is a read-only native pointer
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}

/**
* <pre>
* Asynchronous asynchronously fill a sub-matrix with a pattern of a size element_size_bytes
*	  See \b clblasFillSubMatrix().
* </pre>
*/
JNIEXPORT jint JNICALL Java_org_jocl_blas_CLBLAS_clblasFillSubMatrixAsyncNative(JNIEnv *env, jclass cls, jint order, jlong element_size, jobject A, jlong offA, jlong ldA, jlong sxA, jlong syA, jint xA, jint yA, jlong nx, jlong ny, jobject host, jobject command_queue, jint numEventsInWaitList, jobjectArray eventWaitList, jobjectArray event)
{
    // Null-checks for non-primitive arguments
    // order is primitive
    // element_size is primitive
    if (A == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'A' is null for clblasFillSubMatrixAsync");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // offA is primitive
    // ldA is primitive
    // sxA is primitive
    // syA is primitive
    // xA is primitive
    // yA is primitive
    // nx is primitive
    // ny is primitive
    if (host == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'host' is null for clblasFillSubMatrixAsync");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    if (command_queue == NULL)
    {
        ThrowByName(env, "java/lang/NullPointerException", "Parameter 'command_queue' is null for clblasFillSubMatrixAsync");
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    // numEventsInWaitList is primitive
    // eventWaitList may be NULL
    // event may be NULL

    // Log message
    Logger::log(LOG_TRACE, "Executing clblasFillSubMatrixAsync(order=%d, element_size=%ld, A=%p, offA=%ld, ldA=%ld, sxA=%ld, syA=%ld, xA=%d, yA=%d, nx=%ld, ny=%ld, host=%p, command_queue=%p, numEventsInWaitList=%d, eventWaitList=%p, event=%p)\n",
        order, element_size, A, offA, ldA, sxA, syA, xA, yA, nx, ny, host, command_queue, numEventsInWaitList, eventWaitList, event);

    // Native variable declarations
    clblasOrder order_native;
    size_t element_size_native = 0;
    cl_mem A_native = nullptr;
    size_t offA_native = 0;
    size_t ldA_native = 0;
    size_t sxA_native = 0;
    size_t syA_native = 0;
    int xA_native = 0;
    int yA_native = 0;
    size_t nx_native = 0;
    size_t ny_native = 0;
    void* host_native;
    cl_command_queue command_queue_native;
    cl_uint numEventsInWaitList_native;
    cl_event* eventWaitList_native;
    cl_event* event_native;

    // Obtain native variable values
    order_native = (clblasOrder)order;
    element_size_native = (size_t)element_size;
    if (!init_cl_mem(env, A, A_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    offA_native = (size_t)offA;
    ldA_native = (size_t)ldA;
    sxA_native = (size_t)sxA;
    syA_native = (size_t)syA;
    xA_native = (int)xA;
    yA_native = (int)yA;
    nx_native = (size_t)nx;
    ny_native = (size_t)ny;
    PointerData *host_pointerData = initPointerData(env, host);
    if (host_pointerData == NULL)
    {
        return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    }
    host_native = (void*)host_pointerData->pointer;
    if (!init_cl_command_queue(env, command_queue, command_queue_native, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    numEventsInWaitList_native = (cl_uint)numEventsInWaitList;
    if (!init_cl_event_list(env, eventWaitList, eventWaitList_native, numEventsInWaitList, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    cl_event event_object_native;
    if (event != nullptr)
    {
        event_native = &event_object_native;
    }

    // Native function call
    clblasStatus jniResult_native = clblasFillSubMatrixAsync(order_native, element_size_native, A_native, offA_native, ldA_native, sxA_native, syA_native, xA_native, yA_native, nx_native, ny_native, host_native, command_queue_native, numEventsInWaitList_native, eventWaitList_native, event_native);

    // Write back native variable values
    // order is primitive
    // element_size is primitive
    // A is a read-only native pointer
    // offA is primitive
    // ldA is primitive
    // sxA is primitive
    // syA is primitive
    // xA is primitive
    // yA is primitive
    // nx is primitive
    // ny is primitive
    if (!releasePointerData(env, host_pointerData, JNI_ABORT)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    // command_queue is a read-only native pointer
    // numEventsInWaitList is primitive
    if (!release_cl_event_list(env, eventWaitList_native, eventWaitList, numEventsInWaitList, false)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;
    if (!release_cl_event(env, event_native, event, true)) return JOCL_BLAS_STATUS_INTERNAL_ERROR;

    // Return the result
    jint jniResult;
    jniResult = (jint)jniResult_native;
    return jniResult;
}




